"use strict";(self.webpackChunkjoyride=self.webpackChunkjoyride||[]).push([[579],{4691:(t,i,r)=>{r.d(i,{S:()=>s});class s{constructor(){this.mask=1}set(t){this.mask=(1<<t|0)>>>0}enable(t){this.mask|=1<<t|0}enableAll(){this.mask=-1}toggle(t){this.mask^=1<<t|0}disable(t){this.mask&=~(1<<t|0)}disableAll(){this.mask=0}test(t){return 0!=(this.mask&t.mask)}isEnabled(t){return 0!=(this.mask&(1<<t|0))}}},5579:(t,i,r)=>{r.r(i),r.d(i,{Raycaster:()=>n});var s=r(2081),e=r(4691);class n{constructor(t,i,r=0,n=1/0){this.ray=new s.z(t,i),this.near=r,this.far=n,this.camera=null,this.layers=new e.S,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(t,i){this.ray.set(t,i)}setFromCamera(t,i){i.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(i.matrixWorld),this.ray.direction.set(t.x,t.y,.5).unproject(i).sub(this.ray.origin).normalize(),this.camera=i):i.isOrthographicCamera?(this.ray.origin.set(t.x,t.y,(i.near+i.far)/(i.near-i.far)).unproject(i),this.ray.direction.set(0,0,-1).transformDirection(i.matrixWorld),this.camera=i):console.error("THREE.Raycaster: Unsupported camera type: "+i.type)}intersectObject(t,i=!0,r=[]){return a(t,this,r,i),r.sort(o),r}intersectObjects(t,i=!0,r=[]){for(let s=0,e=t.length;s<e;s++)a(t[s],this,r,i);return r.sort(o),r}}function o(t,i){return t.distance-i.distance}function a(t,i,r,s){if(t.layers.test(i.layers)&&t.raycast(i,r),!0===s){const s=t.children;for(let t=0,e=s.length;t<e;t++)a(s[t],i,r,!0)}}},2081:(t,i,r)=>{r.d(i,{z:()=>d});var s=r(4532);const e=new s.Vector3,n=new s.Vector3,o=new s.Vector3,a=new s.Vector3,c=new s.Vector3,h=new s.Vector3,l=new s.Vector3;class d{constructor(t=new s.Vector3,i=new s.Vector3(0,0,-1)){this.origin=t,this.direction=i}set(t,i){return this.origin.copy(t),this.direction.copy(i),this}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this}at(t,i){return i.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(t){return this.direction.copy(t).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,e)),this}closestPointToPoint(t,i){i.subVectors(t,this.origin);const r=i.dot(this.direction);return r<0?i.copy(this.origin):i.copy(this.direction).multiplyScalar(r).add(this.origin)}distanceToPoint(t){return Math.sqrt(this.distanceSqToPoint(t))}distanceSqToPoint(t){const i=e.subVectors(t,this.origin).dot(this.direction);return i<0?this.origin.distanceToSquared(t):(e.copy(this.direction).multiplyScalar(i).add(this.origin),e.distanceToSquared(t))}distanceSqToSegment(t,i,r,s){n.copy(t).add(i).multiplyScalar(.5),o.copy(i).sub(t).normalize(),a.copy(this.origin).sub(n);const e=.5*t.distanceTo(i),c=-this.direction.dot(o),h=a.dot(this.direction),l=-a.dot(o),d=a.lengthSq(),u=Math.abs(1-c*c);let m,y,p,g;if(u>0)if(m=c*l-h,y=c*h-l,g=e*u,m>=0)if(y>=-g)if(y<=g){const t=1/u;m*=t,y*=t,p=m*(m+c*y+2*h)+y*(c*m+y+2*l)+d}else y=e,m=Math.max(0,-(c*y+h)),p=-m*m+y*(y+2*l)+d;else y=-e,m=Math.max(0,-(c*y+h)),p=-m*m+y*(y+2*l)+d;else y<=-g?(m=Math.max(0,-(-c*e+h)),y=m>0?-e:Math.min(Math.max(-e,-l),e),p=-m*m+y*(y+2*l)+d):y<=g?(m=0,y=Math.min(Math.max(-e,-l),e),p=y*(y+2*l)+d):(m=Math.max(0,-(c*e+h)),y=m>0?e:Math.min(Math.max(-e,-l),e),p=-m*m+y*(y+2*l)+d);else y=c>0?-e:e,m=Math.max(0,-(c*y+h)),p=-m*m+y*(y+2*l)+d;return r&&r.copy(this.direction).multiplyScalar(m).add(this.origin),s&&s.copy(o).multiplyScalar(y).add(n),p}intersectSphere(t,i){e.subVectors(t.center,this.origin);const r=e.dot(this.direction),s=e.dot(e)-r*r,n=t.radius*t.radius;if(s>n)return null;const o=Math.sqrt(n-s),a=r-o,c=r+o;return a<0&&c<0?null:a<0?this.at(c,i):this.at(a,i)}intersectsSphere(t){return this.distanceSqToPoint(t.center)<=t.radius*t.radius}distanceToPlane(t){const i=t.normal.dot(this.direction);if(0===i)return 0===t.distanceToPoint(this.origin)?0:null;const r=-(this.origin.dot(t.normal)+t.constant)/i;return r>=0?r:null}intersectPlane(t,i){const r=this.distanceToPlane(t);return null===r?null:this.at(r,i)}intersectsPlane(t){const i=t.distanceToPoint(this.origin);return 0===i||t.normal.dot(this.direction)*i<0}intersectBox(t,i){let r,s,e,n,o,a;const c=1/this.direction.x,h=1/this.direction.y,l=1/this.direction.z,d=this.origin;return c>=0?(r=(t.min.x-d.x)*c,s=(t.max.x-d.x)*c):(r=(t.max.x-d.x)*c,s=(t.min.x-d.x)*c),h>=0?(e=(t.min.y-d.y)*h,n=(t.max.y-d.y)*h):(e=(t.max.y-d.y)*h,n=(t.min.y-d.y)*h),r>n||e>s?null:((e>r||r!=r)&&(r=e),(n<s||s!=s)&&(s=n),l>=0?(o=(t.min.z-d.z)*l,a=(t.max.z-d.z)*l):(o=(t.max.z-d.z)*l,a=(t.min.z-d.z)*l),r>a||o>s?null:((o>r||r!=r)&&(r=o),(a<s||s!=s)&&(s=a),s<0?null:this.at(r>=0?r:s,i)))}intersectsBox(t){return null!==this.intersectBox(t,e)}intersectTriangle(t,i,r,s,e){c.subVectors(i,t),h.subVectors(r,t),l.crossVectors(c,h);let n,o=this.direction.dot(l);if(o>0){if(s)return null;n=1}else{if(!(o<0))return null;n=-1,o=-o}a.subVectors(this.origin,t);const d=n*this.direction.dot(h.crossVectors(a,h));if(d<0)return null;const u=n*this.direction.dot(c.cross(a));if(u<0)return null;if(d+u>o)return null;const m=-n*a.dot(l);return m<0?null:this.at(m/o,e)}applyMatrix4(t){return this.origin.applyMatrix4(t),this.direction.transformDirection(t),this}equals(t){return t.origin.equals(this.origin)&&t.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}}}]);