{"version":3,"file":"5579.bundle.js","mappings":"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","sources":["webpack://joyride/./node_modules/three/src/core/Layers.js","webpack://joyride/./node_modules/three/src/core/Raycaster.js","webpack://joyride/./node_modules/three/src/math/Ray.js"],"sourcesContent":["class Layers {\n\n\tconstructor() {\n\n\t\tthis.mask = 1 | 0;\n\n\t}\n\n\tset( channel ) {\n\n\t\tthis.mask = ( 1 << channel | 0 ) >>> 0;\n\n\t}\n\n\tenable( channel ) {\n\n\t\tthis.mask |= 1 << channel | 0;\n\n\t}\n\n\tenableAll() {\n\n\t\tthis.mask = 0xffffffff | 0;\n\n\t}\n\n\ttoggle( channel ) {\n\n\t\tthis.mask ^= 1 << channel | 0;\n\n\t}\n\n\tdisable( channel ) {\n\n\t\tthis.mask &= ~ ( 1 << channel | 0 );\n\n\t}\n\n\tdisableAll() {\n\n\t\tthis.mask = 0;\n\n\t}\n\n\ttest( layers ) {\n\n\t\treturn ( this.mask & layers.mask ) !== 0;\n\n\t}\n\n\tisEnabled( channel ) {\n\n\t\treturn ( this.mask & ( 1 << channel | 0 ) ) !== 0;\n\n\t}\n\n}\n\n\nexport { Layers };\n","import { Ray } from '../math/Ray.js';\nimport { Layers } from './Layers.js';\n\nclass Raycaster {\n\n\tconstructor( origin, direction, near = 0, far = Infinity ) {\n\n\t\tthis.ray = new Ray( origin, direction );\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\t\tthis.camera = null;\n\t\tthis.layers = new Layers();\n\n\t\tthis.params = {\n\t\t\tMesh: {},\n\t\t\tLine: { threshold: 1 },\n\t\t\tLOD: {},\n\t\t\tPoints: { threshold: 1 },\n\t\t\tSprite: {}\n\t\t};\n\n\t}\n\n\tset( origin, direction ) {\n\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\n\n\t\tthis.ray.set( origin, direction );\n\n\t}\n\n\tsetFromCamera( coords, camera ) {\n\n\t\tif ( camera.isPerspectiveCamera ) {\n\n\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\n\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\n\t\t\tthis.camera = camera;\n\n\t\t} else if ( camera.isOrthographicCamera ) {\n\n\t\t\tthis.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera\n\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\n\t\t\tthis.camera = camera;\n\n\t\t} else {\n\n\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );\n\n\t\t}\n\n\t}\n\n\tintersectObject( object, recursive = true, intersects = [] ) {\n\n\t\tintersectObject( object, this, intersects, recursive );\n\n\t\tintersects.sort( ascSort );\n\n\t\treturn intersects;\n\n\t}\n\n\tintersectObjects( objects, recursive = true, intersects = [] ) {\n\n\t\tfor ( let i = 0, l = objects.length; i < l; i ++ ) {\n\n\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\n\n\t\t}\n\n\t\tintersects.sort( ascSort );\n\n\t\treturn intersects;\n\n\t}\n\n}\n\nfunction ascSort( a, b ) {\n\n\treturn a.distance - b.distance;\n\n}\n\nfunction intersectObject( object, raycaster, intersects, recursive ) {\n\n\tif ( object.layers.test( raycaster.layers ) ) {\n\n\t\tobject.raycast( raycaster, intersects );\n\n\t}\n\n\tif ( recursive === true ) {\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\n\n\t\t}\n\n\t}\n\n}\n\nexport { Raycaster };\n","import { Vector3 } from './Vector3.js';\n\nconst _vector = /*@__PURE__*/ new Vector3();\nconst _segCenter = /*@__PURE__*/ new Vector3();\nconst _segDir = /*@__PURE__*/ new Vector3();\nconst _diff = /*@__PURE__*/ new Vector3();\n\nconst _edge1 = /*@__PURE__*/ new Vector3();\nconst _edge2 = /*@__PURE__*/ new Vector3();\nconst _normal = /*@__PURE__*/ new Vector3();\n\nclass Ray {\n\n\tconstructor( origin = new Vector3(), direction = new Vector3( 0, 0, - 1 ) ) {\n\n\t\tthis.origin = origin;\n\t\tthis.direction = direction;\n\n\t}\n\n\tset( origin, direction ) {\n\n\t\tthis.origin.copy( origin );\n\t\tthis.direction.copy( direction );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( ray ) {\n\n\t\tthis.origin.copy( ray.origin );\n\t\tthis.direction.copy( ray.direction );\n\n\t\treturn this;\n\n\t}\n\n\tat( t, target ) {\n\n\t\treturn target.copy( this.direction ).multiplyScalar( t ).add( this.origin );\n\n\t}\n\n\tlookAt( v ) {\n\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\n\n\t\treturn this;\n\n\t}\n\n\trecast( t ) {\n\n\t\tthis.origin.copy( this.at( t, _vector ) );\n\n\t\treturn this;\n\n\t}\n\n\tclosestPointToPoint( point, target ) {\n\n\t\ttarget.subVectors( point, this.origin );\n\n\t\tconst directionDistance = target.dot( this.direction );\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn target.copy( this.origin );\n\n\t\t}\n\n\t\treturn target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\n\n\t}\n\n\tdistanceSqToPoint( point ) {\n\n\t\tconst directionDistance = _vector.subVectors( point, this.origin ).dot( this.direction );\n\n\t\t// point behind the ray\n\n\t\tif ( directionDistance < 0 ) {\n\n\t\t\treturn this.origin.distanceToSquared( point );\n\n\t\t}\n\n\t\t_vector.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\n\n\t\treturn _vector.distanceToSquared( point );\n\n\t}\n\n\tdistanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\n\n\t\t// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h\n\t\t// It returns the min distance between the ray and the segment\n\t\t// defined by v0 and v1\n\t\t// It can also set two optional targets :\n\t\t// - The closest point on the ray\n\t\t// - The closest point on the segment\n\n\t\t_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\n\t\t_segDir.copy( v1 ).sub( v0 ).normalize();\n\t\t_diff.copy( this.origin ).sub( _segCenter );\n\n\t\tconst segExtent = v0.distanceTo( v1 ) * 0.5;\n\t\tconst a01 = - this.direction.dot( _segDir );\n\t\tconst b0 = _diff.dot( this.direction );\n\t\tconst b1 = - _diff.dot( _segDir );\n\t\tconst c = _diff.lengthSq();\n\t\tconst det = Math.abs( 1 - a01 * a01 );\n\t\tlet s0, s1, sqrDist, extDet;\n\n\t\tif ( det > 0 ) {\n\n\t\t\t// The ray and segment are not parallel.\n\n\t\t\ts0 = a01 * b1 - b0;\n\t\t\ts1 = a01 * b0 - b1;\n\t\t\textDet = segExtent * det;\n\n\t\t\tif ( s0 >= 0 ) {\n\n\t\t\t\tif ( s1 >= - extDet ) {\n\n\t\t\t\t\tif ( s1 <= extDet ) {\n\n\t\t\t\t\t\t// region 0\n\t\t\t\t\t\t// Minimum at interior points of ray and segment.\n\n\t\t\t\t\t\tconst invDet = 1 / det;\n\t\t\t\t\t\ts0 *= invDet;\n\t\t\t\t\t\ts1 *= invDet;\n\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// region 1\n\n\t\t\t\t\t\ts1 = segExtent;\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 5\n\n\t\t\t\t\ts1 = - segExtent;\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( s1 <= - extDet ) {\n\n\t\t\t\t\t// region 4\n\n\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else if ( s1 <= extDet ) {\n\n\t\t\t\t\t// region 3\n\n\t\t\t\t\ts0 = 0;\n\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// region 2\n\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\n\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\t// Ray and segment are parallel.\n\n\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\n\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\n\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\n\n\t\t}\n\n\t\tif ( optionalPointOnRay ) {\n\n\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\n\n\t\t}\n\n\t\tif ( optionalPointOnSegment ) {\n\n\t\t\toptionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );\n\n\t\t}\n\n\t\treturn sqrDist;\n\n\t}\n\n\tintersectSphere( sphere, target ) {\n\n\t\t_vector.subVectors( sphere.center, this.origin );\n\t\tconst tca = _vector.dot( this.direction );\n\t\tconst d2 = _vector.dot( _vector ) - tca * tca;\n\t\tconst radius2 = sphere.radius * sphere.radius;\n\n\t\tif ( d2 > radius2 ) return null;\n\n\t\tconst thc = Math.sqrt( radius2 - d2 );\n\n\t\t// t0 = first intersect point - entrance on front of sphere\n\t\tconst t0 = tca - thc;\n\n\t\t// t1 = second intersect point - exit point on back of sphere\n\t\tconst t1 = tca + thc;\n\n\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\n\t\tif ( t0 < 0 && t1 < 0 ) return null;\n\n\t\t// test to see if t0 is behind the ray:\n\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\n\t\t// in order to always return an intersect point that is in front of the ray.\n\t\tif ( t0 < 0 ) return this.at( t1, target );\n\n\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\n\t\treturn this.at( t0, target );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\treturn this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\tdistanceToPlane( plane ) {\n\n\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator === 0 ) {\n\n\t\t\t// line is coplanar, return origin\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\n\n\t\t\t\treturn 0;\n\n\t\t\t}\n\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\n\n\t\t// Return if the ray never intersects the plane\n\n\t\treturn t >= 0 ? t : null;\n\n\t}\n\n\tintersectPlane( plane, target ) {\n\n\t\tconst t = this.distanceToPlane( plane );\n\n\t\tif ( t === null ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\treturn this.at( t, target );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\t// check if the ray lies on the plane first\n\n\t\tconst distToPoint = plane.distanceToPoint( this.origin );\n\n\t\tif ( distToPoint === 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tconst denominator = plane.normal.dot( this.direction );\n\n\t\tif ( denominator * distToPoint < 0 ) {\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\t// ray origin is behind the plane (and is pointing behind it)\n\n\t\treturn false;\n\n\t}\n\n\tintersectBox( box, target ) {\n\n\t\tlet tmin, tmax, tymin, tymax, tzmin, tzmax;\n\n\t\tconst invdirx = 1 / this.direction.x,\n\t\t\tinvdiry = 1 / this.direction.y,\n\t\t\tinvdirz = 1 / this.direction.z;\n\n\t\tconst origin = this.origin;\n\n\t\tif ( invdirx >= 0 ) {\n\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\n\n\t\t} else {\n\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\n\n\t\t}\n\n\t\tif ( invdiry >= 0 ) {\n\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\n\n\t\t} else {\n\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\n\n\t\t}\n\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\n\n\t\t// These lines also handle the case where tmin or tmax is NaN\n\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\n\n\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\n\n\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\n\n\t\tif ( invdirz >= 0 ) {\n\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\n\n\t\t} else {\n\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\n\n\t\t}\n\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\n\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\n\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\n\n\t\t//return point closest to the ray (positive side)\n\n\t\tif ( tmax < 0 ) return null;\n\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, target );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn this.intersectBox( box, _vector ) !== null;\n\n\t}\n\n\tintersectTriangle( a, b, c, backfaceCulling, target ) {\n\n\t\t// Compute the offset origin, edges, and normal.\n\n\t\t// from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n\n\t\t_edge1.subVectors( b, a );\n\t\t_edge2.subVectors( c, a );\n\t\t_normal.crossVectors( _edge1, _edge2 );\n\n\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\n\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\n\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\n\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\n\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\n\t\tlet DdN = this.direction.dot( _normal );\n\t\tlet sign;\n\n\t\tif ( DdN > 0 ) {\n\n\t\t\tif ( backfaceCulling ) return null;\n\t\t\tsign = 1;\n\n\t\t} else if ( DdN < 0 ) {\n\n\t\t\tsign = - 1;\n\t\t\tDdN = - DdN;\n\n\t\t} else {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t_diff.subVectors( this.origin, a );\n\t\tconst DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );\n\n\t\t// b1 < 0, no intersection\n\t\tif ( DdQxE2 < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );\n\n\t\t// b2 < 0, no intersection\n\t\tif ( DdE1xQ < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// b1+b2 > 1, no intersection\n\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Line intersects triangle, check if ray does.\n\t\tconst QdN = - sign * _diff.dot( _normal );\n\n\t\t// t < 0, no intersection\n\t\tif ( QdN < 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\t// Ray intersects triangle.\n\t\treturn this.at( QdN / DdN, target );\n\n\t}\n\n\tapplyMatrix4( matrix4 ) {\n\n\t\tthis.origin.applyMatrix4( matrix4 );\n\t\tthis.direction.transformDirection( matrix4 );\n\n\t\treturn this;\n\n\t}\n\n\tequals( ray ) {\n\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nexport { Ray };\n"],"names":["Layers","constructor","this","mask","set","channel","enable","enableAll","toggle","disable","disableAll","test","layers","isEnabled","Raycaster","origin","direction","near","far","Infinity","ray","camera","params","Mesh","Line","threshold","LOD","Points","Sprite","setFromCamera","coords","isPerspectiveCamera","setFromMatrixPosition","matrixWorld","x","y","unproject","sub","normalize","isOrthographicCamera","transformDirection","console","error","type","intersectObject","object","recursive","intersects","sort","ascSort","intersectObjects","objects","i","l","length","a","b","distance","raycaster","raycast","children","_vector","Vector3","_segCenter","_segDir","_diff","_edge1","_edge2","_normal","Ray","copy","at","t","target","multiplyScalar","add","lookAt","v","recast","closestPointToPoint","point","subVectors","directionDistance","dot","distanceToPoint","Math","sqrt","distanceSqToPoint","distanceToSquared","distanceSqToSegment","v0","v1","optionalPointOnRay","optionalPointOnSegment","segExtent","distanceTo","a01","b0","b1","c","lengthSq","det","abs","s0","s1","sqrDist","extDet","invDet","max","min","intersectSphere","sphere","center","tca","d2","radius2","radius","thc","t0","t1","intersectsSphere","distanceToPlane","plane","denominator","normal","constant","intersectPlane","intersectsPlane","distToPoint","intersectBox","box","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","invdiry","invdirz","z","intersectsBox","intersectTriangle","backfaceCulling","crossVectors","sign","DdN","DdQxE2","DdE1xQ","cross","QdN","applyMatrix4","matrix4","equals","clone"],"sourceRoot":""}