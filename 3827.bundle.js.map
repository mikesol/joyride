{"version":3,"file":"3827.bundle.js","mappings":"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","sources":["webpack://joyride/./node_modules/three/src/geometries/BoxGeometry.js"],"sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nclass BoxGeometry extends BufferGeometry {\n\n\tconstructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'BoxGeometry';\n\n\t\tthis.parameters = {\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdepth: depth,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tdepthSegments: depthSegments\n\t\t};\n\n\t\tconst scope = this;\n\n\t\t// segments\n\n\t\twidthSegments = Math.floor( widthSegments );\n\t\theightSegments = Math.floor( heightSegments );\n\t\tdepthSegments = Math.floor( depthSegments );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// helper variables\n\n\t\tlet numberOfVertices = 0;\n\t\tlet groupStart = 0;\n\n\t\t// build each side of the box geometry\n\n\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px\n\t\tbuildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx\n\t\tbuildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py\n\t\tbuildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny\n\t\tbuildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz\n\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\tfunction buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\n\n\t\t\tconst segmentWidth = width / gridX;\n\t\t\tconst segmentHeight = height / gridY;\n\n\t\t\tconst widthHalf = width / 2;\n\t\t\tconst heightHalf = height / 2;\n\t\t\tconst depthHalf = depth / 2;\n\n\t\t\tconst gridX1 = gridX + 1;\n\t\t\tconst gridY1 = gridY + 1;\n\n\t\t\tlet vertexCounter = 0;\n\t\t\tlet groupCount = 0;\n\n\t\t\tconst vector = new Vector3();\n\n\t\t\t// generate vertices, normals and uvs\n\n\t\t\tfor ( let iy = 0; iy < gridY1; iy ++ ) {\n\n\t\t\t\tconst y = iy * segmentHeight - heightHalf;\n\n\t\t\t\tfor ( let ix = 0; ix < gridX1; ix ++ ) {\n\n\t\t\t\t\tconst x = ix * segmentWidth - widthHalf;\n\n\t\t\t\t\t// set values to correct vector component\n\n\t\t\t\t\tvector[ u ] = x * udir;\n\t\t\t\t\tvector[ v ] = y * vdir;\n\t\t\t\t\tvector[ w ] = depthHalf;\n\n\t\t\t\t\t// now apply vector to vertex buffer\n\n\t\t\t\t\tvertices.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t\t// set values to correct vector component\n\n\t\t\t\t\tvector[ u ] = 0;\n\t\t\t\t\tvector[ v ] = 0;\n\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\n\n\t\t\t\t\t// now apply vector to normal buffer\n\n\t\t\t\t\tnormals.push( vector.x, vector.y, vector.z );\n\n\t\t\t\t\t// uvs\n\n\t\t\t\t\tuvs.push( ix / gridX );\n\t\t\t\t\tuvs.push( 1 - ( iy / gridY ) );\n\n\t\t\t\t\t// counters\n\n\t\t\t\t\tvertexCounter += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// indices\n\n\t\t\t// 1. you need three indices to draw a single face\n\t\t\t// 2. a single segment consists of two faces\n\t\t\t// 3. so we need to generate six (2*3) indices per segment\n\n\t\t\tfor ( let iy = 0; iy < gridY; iy ++ ) {\n\n\t\t\t\tfor ( let ix = 0; ix < gridX; ix ++ ) {\n\n\t\t\t\t\tconst a = numberOfVertices + ix + gridX1 * iy;\n\t\t\t\t\tconst b = numberOfVertices + ix + gridX1 * ( iy + 1 );\n\t\t\t\t\tconst c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\n\t\t\t\t\tconst d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\n\n\t\t\t\t\t// faces\n\n\t\t\t\t\tindices.push( a, b, d );\n\t\t\t\t\tindices.push( b, c, d );\n\n\t\t\t\t\t// increase counter\n\n\t\t\t\t\tgroupCount += 6;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add a group to the geometry. this will ensure multi material support\n\n\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\n\n\t\t\t// calculate new start value for groups\n\n\t\t\tgroupStart += groupCount;\n\n\t\t\t// update total number of vertices\n\n\t\t\tnumberOfVertices += vertexCounter;\n\n\t\t}\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new BoxGeometry( data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments );\n\n\t}\n\n}\n\nexport { BoxGeometry, BoxGeometry as BoxBufferGeometry };\n"],"names":["BoxGeometry","BufferGeometry","constructor","width","height","depth","widthSegments","heightSegments","depthSegments","super","this","type","parameters","scope","Math","floor","indices","vertices","normals","uvs","numberOfVertices","groupStart","buildPlane","u","v","w","udir","vdir","gridX","gridY","materialIndex","segmentWidth","segmentHeight","widthHalf","heightHalf","depthHalf","gridX1","gridY1","vertexCounter","groupCount","vector","Vector3","iy","y","ix","x","push","z","a","b","c","d","addGroup","setIndex","setAttribute","Float32BufferAttribute","static","data"],"sourceRoot":""}