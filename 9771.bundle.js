"use strict";(self.webpackChunkjoyride=self.webpackChunkjoyride||[]).push([[9771,7232],{7232:(t,i,s)=>{s.r(i),s.d(i,{Box3:()=>r});var e=s(4532);class r{constructor(t=new e.Vector3(1/0,1/0,1/0),i=new e.Vector3(-1/0,-1/0,-1/0)){this.min=t,this.max=i}set(t,i){return this.min.copy(t),this.max.copy(i),this}setFromArray(t){let i=1/0,s=1/0,e=1/0,r=-1/0,n=-1/0,a=-1/0;for(let h=0,m=t.length;h<m;h+=3){const m=t[h],o=t[h+1],c=t[h+2];m<i&&(i=m),o<s&&(s=o),c<e&&(e=c),m>r&&(r=m),o>n&&(n=o),c>a&&(a=c)}return this.min.set(i,s,e),this.max.set(r,n,a),this}setFromBufferAttribute(t){let i=1/0,s=1/0,e=1/0,r=-1/0,n=-1/0,a=-1/0;for(let h=0,m=t.count;h<m;h++){const m=t.getX(h),o=t.getY(h),c=t.getZ(h);m<i&&(i=m),o<s&&(s=o),c<e&&(e=c),m>r&&(r=m),o>n&&(n=o),c>a&&(a=c)}return this.min.set(i,s,e),this.max.set(r,n,a),this}setFromPoints(t){this.makeEmpty();for(let i=0,s=t.length;i<s;i++)this.expandByPoint(t[i]);return this}setFromCenterAndSize(t,i){const s=a.copy(i).multiplyScalar(.5);return this.min.copy(t).sub(s),this.max.copy(t).add(s),this}setFromObject(t,i=!1){return this.makeEmpty(),this.expandByObject(t,i)}clone(){return(new this.constructor).copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,i=!1){t.updateWorldMatrix(!1,!1);const s=t.geometry;if(void 0!==s)if(i&&null!=s.attributes&&void 0!==s.attributes.position){const i=s.attributes.position;for(let s=0,e=i.count;s<e;s++)a.fromBufferAttribute(i,s).applyMatrix4(t.matrixWorld),this.expandByPoint(a)}else null===s.boundingBox&&s.computeBoundingBox(),h.copy(s.boundingBox),h.applyMatrix4(t.matrixWorld),this.union(h);const e=t.children;for(let t=0,s=e.length;t<s;t++)this.expandByObject(e[t],i);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,i){return i.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,a),a.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let i,s;return t.normal.x>0?(i=t.normal.x*this.min.x,s=t.normal.x*this.max.x):(i=t.normal.x*this.max.x,s=t.normal.x*this.min.x),t.normal.y>0?(i+=t.normal.y*this.min.y,s+=t.normal.y*this.max.y):(i+=t.normal.y*this.max.y,s+=t.normal.y*this.min.y),t.normal.z>0?(i+=t.normal.z*this.min.z,s+=t.normal.z*this.max.z):(i+=t.normal.z*this.max.z,s+=t.normal.z*this.min.z),i<=-t.constant&&s>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(l),d.subVectors(this.max,l),m.subVectors(t.a,l),o.subVectors(t.b,l),c.subVectors(t.c,l),x.subVectors(o,m),u.subVectors(c,o),y.subVectors(m,c);let i=[0,-x.z,x.y,0,-u.z,u.y,0,-y.z,y.y,x.z,0,-x.x,u.z,0,-u.x,y.z,0,-y.x,-x.y,x.x,0,-u.y,u.x,0,-y.y,y.x,0];return!!V(i,m,o,c,d)&&(i=[1,0,0,0,1,0,0,0,1],!!V(i,m,o,c,d)&&(p.crossVectors(x,u),i=[p.x,p.y,p.z],V(i,m,o,c,d)))}clampPoint(t,i){return i.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return a.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return this.getCenter(t.center),t.radius=.5*this.getSize(a).length(),t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()||(n[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),n[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),n[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),n[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),n[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),n[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),n[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),n[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(n)),this}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}r.prototype.isBox3=!0;const n=[new e.Vector3,new e.Vector3,new e.Vector3,new e.Vector3,new e.Vector3,new e.Vector3,new e.Vector3,new e.Vector3],a=new e.Vector3,h=new r,m=new e.Vector3,o=new e.Vector3,c=new e.Vector3,x=new e.Vector3,u=new e.Vector3,y=new e.Vector3,l=new e.Vector3,d=new e.Vector3,p=new e.Vector3,z=new e.Vector3;function V(t,i,s,e,r){for(let n=0,a=t.length-3;n<=a;n+=3){z.fromArray(t,n);const a=r.x*Math.abs(z.x)+r.y*Math.abs(z.y)+r.z*Math.abs(z.z),h=i.dot(z),m=s.dot(z),o=e.dot(z);if(Math.max(-Math.max(h,m,o),Math.min(h,m,o))>a)return!1}return!0}},9771:(t,i,s)=>{s.r(i),s.d(i,{Sphere:()=>o});var e=s(7232),r=s(4532);const n=new e.Box3,a=new r.Vector3,h=new r.Vector3,m=new r.Vector3;class o{constructor(t=new r.Vector3,i=-1){this.center=t,this.radius=i}set(t,i){return this.center.copy(t),this.radius=i,this}setFromPoints(t,i){const s=this.center;void 0!==i?s.copy(i):n.setFromPoints(t).getCenter(s);let e=0;for(let i=0,r=t.length;i<r;i++)e=Math.max(e,s.distanceToSquared(t[i]));return this.radius=Math.sqrt(e),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const i=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=i*i}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,i){const s=this.center.distanceToSquared(t);return i.copy(t),s>this.radius*this.radius&&(i.sub(this.center).normalize(),i.multiplyScalar(this.radius).add(this.center)),i}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){m.subVectors(t,this.center);const i=m.lengthSq();if(i>this.radius*this.radius){const t=Math.sqrt(i),s=.5*(t-this.radius);this.center.add(m.multiplyScalar(s/t)),this.radius+=s}return this}union(t){return!0===this.center.equals(t.center)?h.set(0,0,1).multiplyScalar(t.radius):h.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint(a.copy(t.center).add(h)),this.expandByPoint(a.copy(t.center).sub(h)),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return(new this.constructor).copy(this)}}}}]);