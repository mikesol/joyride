{"version":3,"file":"5484.bundle.js","mappings":"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","sources":["webpack://joyride/./node_modules/three/examples/jsm/postprocessing/Pass.js","webpack://joyride/./node_modules/three/examples/jsm/shaders/LuminosityHighPassShader.js","webpack://joyride/./node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js","webpack://joyride/./node_modules/three/examples/jsm/shaders/CopyShader.js"],"sourcesContent":["import {\n\tBufferGeometry,\n\tFloat32BufferAttribute,\n\tOrthographicCamera,\n\tMesh\n} from 'three';\n\nclass Pass {\n\n\tconstructor() {\n\n\t\t// if set to true, the pass is processed by the composer\n\t\tthis.enabled = true;\n\n\t\t// if set to true, the pass indicates to swap read and write buffer after rendering\n\t\tthis.needsSwap = true;\n\n\t\t// if set to true, the pass clears its buffer before rendering\n\t\tthis.clear = false;\n\n\t\t// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.\n\t\tthis.renderToScreen = false;\n\n\t}\n\n\tsetSize( /* width, height */ ) {}\n\n\trender( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {\n\n\t\tconsole.error( 'THREE.Pass: .render() must be implemented in derived pass.' );\n\n\t}\n\n}\n\n// Helper for passes that need to fill the viewport with a single quad.\n\nconst _camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );\n\n// https://github.com/mrdoob/three.js/pull/21358\n\nconst _geometry = new BufferGeometry();\n_geometry.setAttribute( 'position', new Float32BufferAttribute( [ - 1, 3, 0, - 1, - 1, 0, 3, - 1, 0 ], 3 ) );\n_geometry.setAttribute( 'uv', new Float32BufferAttribute( [ 0, 2, 0, 0, 2, 0 ], 2 ) );\n\nclass FullScreenQuad {\n\n\tconstructor( material ) {\n\n\t\tthis._mesh = new Mesh( _geometry, material );\n\n\t}\n\n\tdispose() {\n\n\t\tthis._mesh.geometry.dispose();\n\n\t}\n\n\trender( renderer ) {\n\n\t\trenderer.render( this._mesh, _camera );\n\n\t}\n\n\tget material() {\n\n\t\treturn this._mesh.material;\n\n\t}\n\n\tset material( value ) {\n\n\t\tthis._mesh.material = value;\n\n\t}\n\n}\n\nexport { Pass, FullScreenQuad };\n","import {\n\tColor\n} from 'three';\n\n/**\n * Luminosity\n * http://en.wikipedia.org/wiki/Luminosity\n */\n\nconst LuminosityHighPassShader = {\n\n\tshaderID: 'luminosityHighPass',\n\n\tuniforms: {\n\n\t\t'tDiffuse': { value: null },\n\t\t'luminosityThreshold': { value: 1.0 },\n\t\t'smoothWidth': { value: 1.0 },\n\t\t'defaultColor': { value: new Color( 0x000000 ) },\n\t\t'defaultOpacity': { value: 0.0 }\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec3 defaultColor;\n\t\tuniform float defaultOpacity;\n\t\tuniform float luminosityThreshold;\n\t\tuniform float smoothWidth;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\tvec3 luma = vec3( 0.299, 0.587, 0.114 );\n\n\t\t\tfloat v = dot( texel.xyz, luma );\n\n\t\t\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\n\t\t\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\n\t\t\tgl_FragColor = mix( outputColor, texel, alpha );\n\n\t\t}`\n\n};\n\nexport { LuminosityHighPassShader };\n","import {\n\tAdditiveBlending,\n\tColor,\n\tMeshBasicMaterial,\n\tShaderMaterial,\n\tUniformsUtils,\n\tVector2,\n\tVector3,\n\tWebGLRenderTarget\n} from 'three';\nimport { Pass, FullScreenQuad } from './Pass.js';\nimport { CopyShader } from '../shaders/CopyShader.js';\nimport { LuminosityHighPassShader } from '../shaders/LuminosityHighPassShader.js';\n\n/**\n * UnrealBloomPass is inspired by the bloom pass of Unreal Engine. It creates a\n * mip map chain of bloom textures and blurs them with different radii. Because\n * of the weighted combination of mips, and because larger blurs are done on\n * higher mips, this effect provides good quality and performance.\n *\n * Reference:\n * - https://docs.unrealengine.com/latest/INT/Engine/Rendering/PostProcessEffects/Bloom/\n */\nclass UnrealBloomPass extends Pass {\n\n\tconstructor( resolution, strength, radius, threshold ) {\n\n\t\tsuper();\n\n\t\tthis.strength = ( strength !== undefined ) ? strength : 1;\n\t\tthis.radius = radius;\n\t\tthis.threshold = threshold;\n\t\tthis.resolution = ( resolution !== undefined ) ? new Vector2( resolution.x, resolution.y ) : new Vector2( 256, 256 );\n\n\t\t// create color only once here, reuse it later inside the render function\n\t\tthis.clearColor = new Color( 0, 0, 0 );\n\n\t\t// render targets\n\t\tthis.renderTargetsHorizontal = [];\n\t\tthis.renderTargetsVertical = [];\n\t\tthis.nMips = 5;\n\t\tlet resx = Math.round( this.resolution.x / 2 );\n\t\tlet resy = Math.round( this.resolution.y / 2 );\n\n\t\tthis.renderTargetBright = new WebGLRenderTarget( resx, resy );\n\t\tthis.renderTargetBright.texture.name = 'UnrealBloomPass.bright';\n\t\tthis.renderTargetBright.texture.generateMipmaps = false;\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tconst renderTargetHorizonal = new WebGLRenderTarget( resx, resy );\n\n\t\t\trenderTargetHorizonal.texture.name = 'UnrealBloomPass.h' + i;\n\t\t\trenderTargetHorizonal.texture.generateMipmaps = false;\n\n\t\t\tthis.renderTargetsHorizontal.push( renderTargetHorizonal );\n\n\t\t\tconst renderTargetVertical = new WebGLRenderTarget( resx, resy );\n\n\t\t\trenderTargetVertical.texture.name = 'UnrealBloomPass.v' + i;\n\t\t\trenderTargetVertical.texture.generateMipmaps = false;\n\n\t\t\tthis.renderTargetsVertical.push( renderTargetVertical );\n\n\t\t\tresx = Math.round( resx / 2 );\n\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t\t// luminosity high pass material\n\n\t\tif ( LuminosityHighPassShader === undefined )\n\t\t\tconsole.error( 'THREE.UnrealBloomPass relies on LuminosityHighPassShader' );\n\n\t\tconst highPassShader = LuminosityHighPassShader;\n\t\tthis.highPassUniforms = UniformsUtils.clone( highPassShader.uniforms );\n\n\t\tthis.highPassUniforms[ 'luminosityThreshold' ].value = threshold;\n\t\tthis.highPassUniforms[ 'smoothWidth' ].value = 0.01;\n\n\t\tthis.materialHighPassFilter = new ShaderMaterial( {\n\t\t\tuniforms: this.highPassUniforms,\n\t\t\tvertexShader: highPassShader.vertexShader,\n\t\t\tfragmentShader: highPassShader.fragmentShader,\n\t\t\tdefines: {}\n\t\t} );\n\n\t\t// Gaussian Blur Materials\n\t\tthis.separableBlurMaterials = [];\n\t\tconst kernelSizeArray = [ 3, 5, 7, 9, 11 ];\n\t\tresx = Math.round( this.resolution.x / 2 );\n\t\tresy = Math.round( this.resolution.y / 2 );\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.separableBlurMaterials.push( this.getSeperableBlurMaterial( kernelSizeArray[ i ] ) );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'texSize' ].value = new Vector2( resx, resy );\n\n\t\t\tresx = Math.round( resx / 2 );\n\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t\t// Composite material\n\t\tthis.compositeMaterial = this.getCompositeMaterial( this.nMips );\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture1' ].value = this.renderTargetsVertical[ 0 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture2' ].value = this.renderTargetsVertical[ 1 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture3' ].value = this.renderTargetsVertical[ 2 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture4' ].value = this.renderTargetsVertical[ 3 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'blurTexture5' ].value = this.renderTargetsVertical[ 4 ].texture;\n\t\tthis.compositeMaterial.uniforms[ 'bloomStrength' ].value = strength;\n\t\tthis.compositeMaterial.uniforms[ 'bloomRadius' ].value = 0.1;\n\t\tthis.compositeMaterial.needsUpdate = true;\n\n\t\tconst bloomFactors = [ 1.0, 0.8, 0.6, 0.4, 0.2 ];\n\t\tthis.compositeMaterial.uniforms[ 'bloomFactors' ].value = bloomFactors;\n\t\tthis.bloomTintColors = [ new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ), new Vector3( 1, 1, 1 ) ];\n\t\tthis.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;\n\n\t\t// copy material\n\t\tif ( CopyShader === undefined ) {\n\n\t\t\tconsole.error( 'THREE.UnrealBloomPass relies on CopyShader' );\n\n\t\t}\n\n\t\tconst copyShader = CopyShader;\n\n\t\tthis.copyUniforms = UniformsUtils.clone( copyShader.uniforms );\n\t\tthis.copyUniforms[ 'opacity' ].value = 1.0;\n\n\t\tthis.materialCopy = new ShaderMaterial( {\n\t\t\tuniforms: this.copyUniforms,\n\t\t\tvertexShader: copyShader.vertexShader,\n\t\t\tfragmentShader: copyShader.fragmentShader,\n\t\t\tblending: AdditiveBlending,\n\t\t\tdepthTest: false,\n\t\t\tdepthWrite: false,\n\t\t\ttransparent: true\n\t\t} );\n\n\t\tthis.enabled = true;\n\t\tthis.needsSwap = false;\n\n\t\tthis._oldClearColor = new Color();\n\t\tthis.oldClearAlpha = 1;\n\n\t\tthis.basic = new MeshBasicMaterial();\n\n\t\tthis.fsQuad = new FullScreenQuad( null );\n\n\t}\n\n\tdispose() {\n\n\t\tfor ( let i = 0; i < this.renderTargetsHorizontal.length; i ++ ) {\n\n\t\t\tthis.renderTargetsHorizontal[ i ].dispose();\n\n\t\t}\n\n\t\tfor ( let i = 0; i < this.renderTargetsVertical.length; i ++ ) {\n\n\t\t\tthis.renderTargetsVertical[ i ].dispose();\n\n\t\t}\n\n\t\tthis.renderTargetBright.dispose();\n\n\t}\n\n\tsetSize( width, height ) {\n\n\t\tlet resx = Math.round( width / 2 );\n\t\tlet resy = Math.round( height / 2 );\n\n\t\tthis.renderTargetBright.setSize( resx, resy );\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.renderTargetsHorizontal[ i ].setSize( resx, resy );\n\t\t\tthis.renderTargetsVertical[ i ].setSize( resx, resy );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'texSize' ].value = new Vector2( resx, resy );\n\n\t\t\tresx = Math.round( resx / 2 );\n\t\t\tresy = Math.round( resy / 2 );\n\n\t\t}\n\n\t}\n\n\trender( renderer, writeBuffer, readBuffer, deltaTime, maskActive ) {\n\n\t\trenderer.getClearColor( this._oldClearColor );\n\t\tthis.oldClearAlpha = renderer.getClearAlpha();\n\t\tconst oldAutoClear = renderer.autoClear;\n\t\trenderer.autoClear = false;\n\n\t\trenderer.setClearColor( this.clearColor, 0 );\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( false );\n\n\t\t// Render input to screen\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\tthis.fsQuad.material = this.basic;\n\t\t\tthis.basic.map = readBuffer.texture;\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t\t// 1. Extract Bright Areas\n\n\t\tthis.highPassUniforms[ 'tDiffuse' ].value = readBuffer.texture;\n\t\tthis.highPassUniforms[ 'luminosityThreshold' ].value = this.threshold;\n\t\tthis.fsQuad.material = this.materialHighPassFilter;\n\n\t\trenderer.setRenderTarget( this.renderTargetBright );\n\t\trenderer.clear();\n\t\tthis.fsQuad.render( renderer );\n\n\t\t// 2. Blur All the mips progressively\n\n\t\tlet inputRenderTarget = this.renderTargetBright;\n\n\t\tfor ( let i = 0; i < this.nMips; i ++ ) {\n\n\t\t\tthis.fsQuad.material = this.separableBlurMaterials[ i ];\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = inputRenderTarget.texture;\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionX;\n\t\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ i ] );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'colorTexture' ].value = this.renderTargetsHorizontal[ i ].texture;\n\t\t\tthis.separableBlurMaterials[ i ].uniforms[ 'direction' ].value = UnrealBloomPass.BlurDirectionY;\n\t\t\trenderer.setRenderTarget( this.renderTargetsVertical[ i ] );\n\t\t\trenderer.clear();\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t\tinputRenderTarget = this.renderTargetsVertical[ i ];\n\n\t\t}\n\n\t\t// Composite All the mips\n\n\t\tthis.fsQuad.material = this.compositeMaterial;\n\t\tthis.compositeMaterial.uniforms[ 'bloomStrength' ].value = this.strength;\n\t\tthis.compositeMaterial.uniforms[ 'bloomRadius' ].value = this.radius;\n\t\tthis.compositeMaterial.uniforms[ 'bloomTintColors' ].value = this.bloomTintColors;\n\n\t\trenderer.setRenderTarget( this.renderTargetsHorizontal[ 0 ] );\n\t\trenderer.clear();\n\t\tthis.fsQuad.render( renderer );\n\n\t\t// Blend it additively over the input texture\n\n\t\tthis.fsQuad.material = this.materialCopy;\n\t\tthis.copyUniforms[ 'tDiffuse' ].value = this.renderTargetsHorizontal[ 0 ].texture;\n\n\t\tif ( maskActive ) renderer.state.buffers.stencil.setTest( true );\n\n\t\tif ( this.renderToScreen ) {\n\n\t\t\trenderer.setRenderTarget( null );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t} else {\n\n\t\t\trenderer.setRenderTarget( readBuffer );\n\t\t\tthis.fsQuad.render( renderer );\n\n\t\t}\n\n\t\t// Restore renderer settings\n\n\t\trenderer.setClearColor( this._oldClearColor, this.oldClearAlpha );\n\t\trenderer.autoClear = oldAutoClear;\n\n\t}\n\n\tgetSeperableBlurMaterial( kernelRadius ) {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t'KERNEL_RADIUS': kernelRadius,\n\t\t\t\t'SIGMA': kernelRadius\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t'colorTexture': { value: null },\n\t\t\t\t'texSize': { value: new Vector2( 0.5, 0.5 ) },\n\t\t\t\t'direction': { value: new Vector2( 0.5, 0.5 ) }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat fSigma = float(SIGMA);\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n\tgetCompositeMaterial( nMips ) {\n\n\t\treturn new ShaderMaterial( {\n\n\t\t\tdefines: {\n\t\t\t\t'NUM_MIPS': nMips\n\t\t\t},\n\n\t\t\tuniforms: {\n\t\t\t\t'blurTexture1': { value: null },\n\t\t\t\t'blurTexture2': { value: null },\n\t\t\t\t'blurTexture3': { value: null },\n\t\t\t\t'blurTexture4': { value: null },\n\t\t\t\t'blurTexture5': { value: null },\n\t\t\t\t'bloomStrength': { value: 1.0 },\n\t\t\t\t'bloomFactors': { value: null },\n\t\t\t\t'bloomTintColors': { value: null },\n\t\t\t\t'bloomRadius': { value: 0.0 }\n\t\t\t},\n\n\t\t\tvertexShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}`,\n\n\t\t\tfragmentShader:\n\t\t\t\t`varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}`\n\t\t} );\n\n\t}\n\n}\n\nUnrealBloomPass.BlurDirectionX = new Vector2( 1.0, 0.0 );\nUnrealBloomPass.BlurDirectionY = new Vector2( 0.0, 1.0 );\n\nexport { UnrealBloomPass };\n","/**\n * Full-screen textured quad shader\n */\n\nconst CopyShader = {\n\n\tuniforms: {\n\n\t\t'tDiffuse': { value: null },\n\t\t'opacity': { value: 1.0 }\n\n\t},\n\n\tvertexShader: /* glsl */`\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}`,\n\n\tfragmentShader: /* glsl */`\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor.a *= opacity;\n\n\n\t\t}`\n\n};\n\nexport { CopyShader };\n"],"names":["Pass","constructor","this","enabled","needsSwap","clear","renderToScreen","setSize","render","console","error","_camera","_geometry","setAttribute","FullScreenQuad","material","_mesh","dispose","geometry","renderer","value","LuminosityHighPassShader","shaderID","uniforms","vertexShader","fragmentShader","UnrealBloomPass","resolution","strength","radius","threshold","super","undefined","x","y","clearColor","renderTargetsHorizontal","renderTargetsVertical","nMips","resx","Math","round","resy","renderTargetBright","texture","name","generateMipmaps","i","renderTargetHorizonal","push","renderTargetVertical","highPassShader","highPassUniforms","materialHighPassFilter","defines","separableBlurMaterials","kernelSizeArray","getSeperableBlurMaterial","compositeMaterial","getCompositeMaterial","needsUpdate","bloomTintColors","CopyShader","C","copyShader","copyUniforms","materialCopy","blending","depthTest","depthWrite","transparent","_oldClearColor","oldClearAlpha","basic","fsQuad","length","width","height","writeBuffer","readBuffer","deltaTime","maskActive","getClearColor","getClearAlpha","oldAutoClear","autoClear","setClearColor","state","buffers","stencil","setTest","map","setRenderTarget","inputRenderTarget","BlurDirectionX","BlurDirectionY","kernelRadius"],"sourceRoot":""}