import{L as f}from"./Light.876ff18c.js";import{Matrix4 as h}from"./Matrix4.0c7a2215.js";import{Vector2 as p}from"./Vector2.3964b2c2.js";import{V as s}from"./Vector3.5db2ef2e.js";import{V as e}from"./Vector4.27798d04.js";import{F as y}from"./Frustum.21d548b8.js";import{P as _}from"./PerspectiveCamera.3def8065.js";import"./Object3D.d81adcf4.js";import"./EventDispatcher.62ae53dd.js";import"./Euler.d28ed76f.js";import"./MathUtils.9169ae61.js";import"./Layers.61b05682.js";import"./Matrix3.254ef6d6.js";import"./Color.5efc95ab.js";import"./constants.cc13e4fd.js";import"./Sphere.bf80223e.js";const u=new h,w=new s,d=new s;class M{constructor(t){this.camera=t,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new p(512,512),this.map=null,this.mapPass=null,this.matrix=new h,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new y,this._frameExtents=new p(1,1),this._viewportCount=1,this._viewports=[new e(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(t){const r=this.camera,i=this.matrix;w.setFromMatrixPosition(t.matrixWorld),r.position.copy(w),d.setFromMatrixPosition(t.target.matrixWorld),r.lookAt(d),r.updateMatrixWorld(),u.multiplyMatrices(r.projectionMatrix,r.matrixWorldInverse),this._frustum.setFromProjectionMatrix(u),i.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),i.multiply(r.projectionMatrix),i.multiply(r.matrixWorldInverse)}getViewport(t){return this._viewports[t]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(t){return this.camera=t.camera.clone(),this.bias=t.bias,this.radius=t.radius,this.mapSize.copy(t.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const t={};return this.bias!==0&&(t.bias=this.bias),this.normalBias!==0&&(t.normalBias=this.normalBias),this.radius!==1&&(t.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(t.mapSize=this.mapSize.toArray()),t.camera=this.camera.toJSON(!1).object,delete t.camera.matrix,t}}const l=new h,o=new s,n=new s;class x extends M{constructor(){super(new _(90,1,.5,500)),this._frameExtents=new p(4,2),this._viewportCount=6,this._viewports=[new e(2,1,1,1),new e(0,1,1,1),new e(3,1,1,1),new e(1,1,1,1),new e(3,0,1,1),new e(1,0,1,1)],this._cubeDirections=[new s(1,0,0),new s(-1,0,0),new s(0,0,1),new s(0,0,-1),new s(0,1,0),new s(0,-1,0)],this._cubeUps=[new s(0,1,0),new s(0,1,0),new s(0,1,0),new s(0,1,0),new s(0,0,1),new s(0,0,-1)]}updateMatrices(t,r=0){const i=this.camera,a=this.matrix,c=t.distance||i.far;c!==i.far&&(i.far=c,i.updateProjectionMatrix()),o.setFromMatrixPosition(t.matrixWorld),i.position.copy(o),n.copy(i.position),n.add(this._cubeDirections[r]),i.up.copy(this._cubeUps[r]),i.lookAt(n),i.updateMatrixWorld(),a.makeTranslation(-o.x,-o.y,-o.z),l.multiplyMatrices(i.projectionMatrix,i.matrixWorldInverse),this._frustum.setFromProjectionMatrix(l)}}x.prototype.isPointLightShadow=!0;class P extends f{constructor(t,r,i=0,a=1){super(t,r),this.type="PointLight",this.distance=i,this.decay=a,this.shadow=new x}get power(){return this.intensity*4*Math.PI}set power(t){this.intensity=t/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(t){return super.copy(t),this.distance=t.distance,this.decay=t.decay,this.shadow=t.shadow.clone(),this}}P.prototype.isPointLight=!0;export{P as PointLight};
