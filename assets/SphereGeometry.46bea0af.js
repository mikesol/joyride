import{BufferGeometry as G}from"./BufferGeometry.d5615ad3.js";import{Float32BufferAttribute as a}from"./BufferAttribute.ad6349b3.js";import{V as z}from"./Vector3.5db2ef2e.js";import"./Vector2.3964b2c2.js";import"./Sphere.bf80223e.js";import"./EventDispatcher.62ae53dd.js";import"./Object3D.d81adcf4.js";import"./Matrix4.0c7a2215.js";import"./MathUtils.9169ae61.js";import"./Euler.d28ed76f.js";import"./Layers.61b05682.js";import"./Matrix3.254ef6d6.js";import"./utils.4cfc5b76.js";import"./Vector4.27798d04.js";import"./Color.5efc95ab.js";import"./constants.cc13e4fd.js";class A extends G{constructor(r=1,s=32,i=16,x=0,y=Math.PI*2,p=0,m=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:r,widthSegments:s,heightSegments:i,phiStart:x,phiLength:y,thetaStart:p,thetaLength:m},s=Math.max(3,Math.floor(s)),i=Math.max(2,Math.floor(i));const v=Math.min(p+m,Math.PI);let B=0;const u=[],c=new z,M=new z,h=[],I=[],b=[],P=[];for(let o=0;o<=i;o++){const t=[],n=o/i;let e=0;o==0&&p==0?e=.5/s:o==i&&v==Math.PI&&(e=-.5/s);for(let l=0;l<=s;l++){const f=l/s;c.x=-r*Math.cos(x+f*y)*Math.sin(p+n*m),c.y=r*Math.cos(p+n*m),c.z=r*Math.sin(x+f*y)*Math.sin(p+n*m),I.push(c.x,c.y,c.z),M.copy(c).normalize(),b.push(M.x,M.y,M.z),P.push(f+e,1-n),t.push(B++)}u.push(t)}for(let o=0;o<i;o++)for(let t=0;t<s;t++){const n=u[o][t+1],e=u[o][t],l=u[o+1][t],f=u[o+1][t+1];(o!==0||p>0)&&h.push(n,e,f),(o!==i-1||v<Math.PI)&&h.push(e,l,f)}this.setIndex(h),this.setAttribute("position",new a(I,3)),this.setAttribute("normal",new a(b,3)),this.setAttribute("uv",new a(P,2))}static fromJSON(r){return new A(r.radius,r.widthSegments,r.heightSegments,r.phiStart,r.phiLength,r.thetaStart,r.thetaLength)}}export{A as SphereBufferGeometry,A as SphereGeometry};
