import{V as u}from"./Vector3.5db2ef2e.js";import{S as T}from"./Sphere.bf80223e.js";import{M as F}from"./Matrix3.254ef6d6.js";const d=new u,_=new u,v=new F;class a{constructor(t=new u(1,0,0),e=0){this.normal=t,this.constant=e}set(t,e){return this.normal.copy(t),this.constant=e,this}setComponents(t,e,n,s){return this.normal.set(t,e,n),this.constant=s,this}setFromNormalAndCoplanarPoint(t,e){return this.normal.copy(t),this.constant=-e.dot(this.normal),this}setFromCoplanarPoints(t,e,n){const s=d.subVectors(n,e).cross(_.subVectors(t,e)).normalize();return this.setFromNormalAndCoplanarPoint(s,t),this}copy(t){return this.normal.copy(t.normal),this.constant=t.constant,this}normalize(){const t=1/this.normal.length();return this.normal.multiplyScalar(t),this.constant*=t,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(t){return this.normal.dot(t)+this.constant}distanceToSphere(t){return this.distanceToPoint(t.center)-t.radius}projectPoint(t,e){return e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)}intersectLine(t,e){const n=t.delta(d),s=this.normal.dot(n);if(s===0)return this.distanceToPoint(t.start)===0?e.copy(t.start):null;const r=-(t.start.dot(this.normal)+this.constant)/s;return r<0||r>1?null:e.copy(n).multiplyScalar(r).add(t.start)}intersectsLine(t){const e=this.distanceToPoint(t.start),n=this.distanceToPoint(t.end);return e<0&&n>0||n<0&&e>0}intersectsBox(t){return t.intersectsPlane(this)}intersectsSphere(t){return t.intersectsPlane(this)}coplanarPoint(t){return t.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(t,e){const n=e||v.getNormalMatrix(t),s=this.coplanarPoint(d).applyMatrix4(t),r=this.normal.applyMatrix3(n).normalize();return this.constant=-s.dot(r),this}translate(t){return this.constant-=t.dot(this.normal),this}equals(t){return t.normal.equals(this.normal)&&t.constant===this.constant}clone(){return new this.constructor().copy(this)}}a.prototype.isPlane=!0;const h=new T,p=new u;class L{constructor(t=new a,e=new a,n=new a,s=new a,r=new a,i=new a){this.planes=[t,e,n,s,r,i]}set(t,e,n,s,r,i){const o=this.planes;return o[0].copy(t),o[1].copy(e),o[2].copy(n),o[3].copy(s),o[4].copy(r),o[5].copy(i),this}copy(t){const e=this.planes;for(let n=0;n<6;n++)e[n].copy(t.planes[n]);return this}setFromProjectionMatrix(t){const e=this.planes,n=t.elements,s=n[0],r=n[1],i=n[2],o=n[3],y=n[4],P=n[5],f=n[6],c=n[7],S=n[8],x=n[9],w=n[10],l=n[11],z=n[12],g=n[13],M=n[14],m=n[15];return e[0].setComponents(o-s,c-y,l-S,m-z).normalize(),e[1].setComponents(o+s,c+y,l+S,m+z).normalize(),e[2].setComponents(o+r,c+P,l+x,m+g).normalize(),e[3].setComponents(o-r,c-P,l-x,m-g).normalize(),e[4].setComponents(o-i,c-f,l-w,m-M).normalize(),e[5].setComponents(o+i,c+f,l+w,m+M).normalize(),this}intersectsObject(t){const e=t.geometry;return e.boundingSphere===null&&e.computeBoundingSphere(),h.copy(e.boundingSphere).applyMatrix4(t.matrixWorld),this.intersectsSphere(h)}intersectsSprite(t){return h.center.set(0,0,0),h.radius=.7071067811865476,h.applyMatrix4(t.matrixWorld),this.intersectsSphere(h)}intersectsSphere(t){const e=this.planes,n=t.center,s=-t.radius;for(let r=0;r<6;r++)if(e[r].distanceToPoint(n)<s)return!1;return!0}intersectsBox(t){const e=this.planes;for(let n=0;n<6;n++){const s=e[n];if(p.x=s.normal.x>0?t.max.x:t.min.x,p.y=s.normal.y>0?t.max.y:t.min.y,p.z=s.normal.z>0?t.max.z:t.min.z,s.distanceToPoint(p)<0)return!1}return!0}containsPoint(t){const e=this.planes;for(let n=0;n<6;n++)if(e[n].distanceToPoint(t)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}export{L as F,a as P};
