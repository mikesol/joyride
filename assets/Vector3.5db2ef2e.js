import{c as S}from"./MathUtils.9169ae61.js";class k{constructor(t=0,s=0,i=0,r=1){this._x=t,this._y=s,this._z=i,this._w=r}static slerp(t,s,i,r){return console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead."),i.slerpQuaternions(t,s,r)}static slerpFlat(t,s,i,r,h,c,l){let _=i[r+0],e=i[r+1],a=i[r+2],o=i[r+3];const y=h[c+0],n=h[c+1],u=h[c+2],m=h[c+3];if(l===0){t[s+0]=_,t[s+1]=e,t[s+2]=a,t[s+3]=o;return}if(l===1){t[s+0]=y,t[s+1]=n,t[s+2]=u,t[s+3]=m;return}if(o!==m||_!==y||e!==n||a!==u){let z=1-l;const M=_*y+e*n+a*u+o*m,g=M>=0?1:-1,C=1-M*M;if(C>Number.EPSILON){const x=Math.sqrt(C),b=Math.atan2(x,M*g);z=Math.sin(z*b)/x,l=Math.sin(l*b)/x}const p=l*g;if(_=_*z+y*p,e=e*z+n*p,a=a*z+u*p,o=o*z+m*p,z===1-l){const x=1/Math.sqrt(_*_+e*e+a*a+o*o);_*=x,e*=x,a*=x,o*=x}}t[s]=_,t[s+1]=e,t[s+2]=a,t[s+3]=o}static multiplyQuaternionsFlat(t,s,i,r,h,c){const l=i[r],_=i[r+1],e=i[r+2],a=i[r+3],o=h[c],y=h[c+1],n=h[c+2],u=h[c+3];return t[s]=l*u+a*o+_*n-e*y,t[s+1]=_*u+a*y+e*o-l*n,t[s+2]=e*u+a*n+l*y-_*o,t[s+3]=a*u-l*o-_*y-e*n,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,s,i,r){return this._x=t,this._y=s,this._z=i,this._w=r,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,s){if(!(t&&t.isEuler))throw new Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");const i=t._x,r=t._y,h=t._z,c=t._order,l=Math.cos,_=Math.sin,e=l(i/2),a=l(r/2),o=l(h/2),y=_(i/2),n=_(r/2),u=_(h/2);switch(c){case"XYZ":this._x=y*a*o+e*n*u,this._y=e*n*o-y*a*u,this._z=e*a*u+y*n*o,this._w=e*a*o-y*n*u;break;case"YXZ":this._x=y*a*o+e*n*u,this._y=e*n*o-y*a*u,this._z=e*a*u-y*n*o,this._w=e*a*o+y*n*u;break;case"ZXY":this._x=y*a*o-e*n*u,this._y=e*n*o+y*a*u,this._z=e*a*u+y*n*o,this._w=e*a*o-y*n*u;break;case"ZYX":this._x=y*a*o-e*n*u,this._y=e*n*o+y*a*u,this._z=e*a*u-y*n*o,this._w=e*a*o+y*n*u;break;case"YZX":this._x=y*a*o+e*n*u,this._y=e*n*o+y*a*u,this._z=e*a*u-y*n*o,this._w=e*a*o-y*n*u;break;case"XZY":this._x=y*a*o-e*n*u,this._y=e*n*o-y*a*u,this._z=e*a*u+y*n*o,this._w=e*a*o+y*n*u;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+c)}return s!==!1&&this._onChangeCallback(),this}setFromAxisAngle(t,s){const i=s/2,r=Math.sin(i);return this._x=t.x*r,this._y=t.y*r,this._z=t.z*r,this._w=Math.cos(i),this._onChangeCallback(),this}setFromRotationMatrix(t){const s=t.elements,i=s[0],r=s[4],h=s[8],c=s[1],l=s[5],_=s[9],e=s[2],a=s[6],o=s[10],y=i+l+o;if(y>0){const n=.5/Math.sqrt(y+1);this._w=.25/n,this._x=(a-_)*n,this._y=(h-e)*n,this._z=(c-r)*n}else if(i>l&&i>o){const n=2*Math.sqrt(1+i-l-o);this._w=(a-_)/n,this._x=.25*n,this._y=(r+c)/n,this._z=(h+e)/n}else if(l>o){const n=2*Math.sqrt(1+l-i-o);this._w=(h-e)/n,this._x=(r+c)/n,this._y=.25*n,this._z=(_+a)/n}else{const n=2*Math.sqrt(1+o-i-l);this._w=(c-r)/n,this._x=(h+e)/n,this._y=(_+a)/n,this._z=.25*n}return this._onChangeCallback(),this}setFromUnitVectors(t,s){let i=t.dot(s)+1;return i<Number.EPSILON?(i=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=i):(this._x=0,this._y=-t.z,this._z=t.y,this._w=i)):(this._x=t.y*s.z-t.z*s.y,this._y=t.z*s.x-t.x*s.z,this._z=t.x*s.y-t.y*s.x,this._w=i),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(S(this.dot(t),-1,1)))}rotateTowards(t,s){const i=this.angleTo(t);if(i===0)return this;const r=Math.min(1,s/i);return this.slerp(t,r),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t,s){return s!==void 0?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),this.multiplyQuaternions(t,s)):this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,s){const i=t._x,r=t._y,h=t._z,c=t._w,l=s._x,_=s._y,e=s._z,a=s._w;return this._x=i*a+c*l+r*e-h*_,this._y=r*a+c*_+h*l-i*e,this._z=h*a+c*e+i*_-r*l,this._w=c*a-i*l-r*_-h*e,this._onChangeCallback(),this}slerp(t,s){if(s===0)return this;if(s===1)return this.copy(t);const i=this._x,r=this._y,h=this._z,c=this._w;let l=c*t._w+i*t._x+r*t._y+h*t._z;if(l<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,l=-l):this.copy(t),l>=1)return this._w=c,this._x=i,this._y=r,this._z=h,this;const _=1-l*l;if(_<=Number.EPSILON){const n=1-s;return this._w=n*c+s*this._w,this._x=n*i+s*this._x,this._y=n*r+s*this._y,this._z=n*h+s*this._z,this.normalize(),this._onChangeCallback(),this}const e=Math.sqrt(_),a=Math.atan2(e,l),o=Math.sin((1-s)*a)/e,y=Math.sin(s*a)/e;return this._w=c*o+this._w*y,this._x=i*o+this._x*y,this._y=r*o+this._y*y,this._z=h*o+this._z*y,this._onChangeCallback(),this}slerpQuaternions(t,s,i){return this.copy(t).slerp(s,i)}random(){const t=Math.random(),s=Math.sqrt(1-t),i=Math.sqrt(t),r=2*Math.PI*Math.random(),h=2*Math.PI*Math.random();return this.set(s*Math.cos(r),i*Math.sin(h),i*Math.cos(h),s*Math.sin(r))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,s=0){return this._x=t[s],this._y=t[s+1],this._z=t[s+2],this._w=t[s+3],this._onChangeCallback(),this}toArray(t=[],s=0){return t[s]=this._x,t[s+1]=this._y,t[s+2]=this._z,t[s+3]=this._w,t}fromBufferAttribute(t,s){return this._x=t.getX(s),this._y=t.getY(s),this._z=t.getZ(s),this._w=t.getW(s),this}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}k.prototype.isQuaternion=!0;class d{constructor(t=0,s=0,i=0){this.x=t,this.y=s,this.z=i}set(t,s,i){return i===void 0&&(i=this.z),this.x=t,this.y=s,this.z=i,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,s){switch(t){case 0:this.x=s;break;case 1:this.y=s;break;case 2:this.z=s;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t,s){return s!==void 0?(console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."),this.addVectors(t,s)):(this.x+=t.x,this.y+=t.y,this.z+=t.z,this)}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,s){return this.x=t.x+s.x,this.y=t.y+s.y,this.z=t.z+s.z,this}addScaledVector(t,s){return this.x+=t.x*s,this.y+=t.y*s,this.z+=t.z*s,this}sub(t,s){return s!==void 0?(console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."),this.subVectors(t,s)):(this.x-=t.x,this.y-=t.y,this.z-=t.z,this)}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,s){return this.x=t.x-s.x,this.y=t.y-s.y,this.z=t.z-s.z,this}multiply(t,s){return s!==void 0?(console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."),this.multiplyVectors(t,s)):(this.x*=t.x,this.y*=t.y,this.z*=t.z,this)}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,s){return this.x=t.x*s.x,this.y=t.y*s.y,this.z=t.z*s.z,this}applyEuler(t){return t&&t.isEuler||console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."),this.applyQuaternion(E.setFromEuler(t))}applyAxisAngle(t,s){return this.applyQuaternion(E.setFromAxisAngle(t,s))}applyMatrix3(t){const s=this.x,i=this.y,r=this.z,h=t.elements;return this.x=h[0]*s+h[3]*i+h[6]*r,this.y=h[1]*s+h[4]*i+h[7]*r,this.z=h[2]*s+h[5]*i+h[8]*r,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const s=this.x,i=this.y,r=this.z,h=t.elements,c=1/(h[3]*s+h[7]*i+h[11]*r+h[15]);return this.x=(h[0]*s+h[4]*i+h[8]*r+h[12])*c,this.y=(h[1]*s+h[5]*i+h[9]*r+h[13])*c,this.z=(h[2]*s+h[6]*i+h[10]*r+h[14])*c,this}applyQuaternion(t){const s=this.x,i=this.y,r=this.z,h=t.x,c=t.y,l=t.z,_=t.w,e=_*s+c*r-l*i,a=_*i+l*s-h*r,o=_*r+h*i-c*s,y=-h*s-c*i-l*r;return this.x=e*_+y*-h+a*-l-o*-c,this.y=a*_+y*-c+o*-h-e*-l,this.z=o*_+y*-l+e*-c-a*-h,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const s=this.x,i=this.y,r=this.z,h=t.elements;return this.x=h[0]*s+h[4]*i+h[8]*r,this.y=h[1]*s+h[5]*i+h[9]*r,this.z=h[2]*s+h[6]*i+h[10]*r,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,s){return this.x=Math.max(t.x,Math.min(s.x,this.x)),this.y=Math.max(t.y,Math.min(s.y,this.y)),this.z=Math.max(t.z,Math.min(s.z,this.z)),this}clampScalar(t,s){return this.x=Math.max(t,Math.min(s,this.x)),this.y=Math.max(t,Math.min(s,this.y)),this.z=Math.max(t,Math.min(s,this.z)),this}clampLength(t,s){const i=this.length();return this.divideScalar(i||1).multiplyScalar(Math.max(t,Math.min(s,i)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=this.x<0?Math.ceil(this.x):Math.floor(this.x),this.y=this.y<0?Math.ceil(this.y):Math.floor(this.y),this.z=this.z<0?Math.ceil(this.z):Math.floor(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,s){return this.x+=(t.x-this.x)*s,this.y+=(t.y-this.y)*s,this.z+=(t.z-this.z)*s,this}lerpVectors(t,s,i){return this.x=t.x+(s.x-t.x)*i,this.y=t.y+(s.y-t.y)*i,this.z=t.z+(s.z-t.z)*i,this}cross(t,s){return s!==void 0?(console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."),this.crossVectors(t,s)):this.crossVectors(this,t)}crossVectors(t,s){const i=t.x,r=t.y,h=t.z,c=s.x,l=s.y,_=s.z;return this.x=r*_-h*l,this.y=h*c-i*_,this.z=i*l-r*c,this}projectOnVector(t){const s=t.lengthSq();if(s===0)return this.set(0,0,0);const i=t.dot(this)/s;return this.copy(t).multiplyScalar(i)}projectOnPlane(t){return w.copy(this).projectOnVector(t),this.sub(w)}reflect(t){return this.sub(w.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const s=Math.sqrt(this.lengthSq()*t.lengthSq());if(s===0)return Math.PI/2;const i=this.dot(t)/s;return Math.acos(S(i,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const s=this.x-t.x,i=this.y-t.y,r=this.z-t.z;return s*s+i*i+r*r}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,s,i){const r=Math.sin(s)*t;return this.x=r*Math.sin(i),this.y=Math.cos(s)*t,this.z=r*Math.cos(i),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,s,i){return this.x=t*Math.sin(s),this.y=i,this.z=t*Math.cos(s),this}setFromMatrixPosition(t){const s=t.elements;return this.x=s[12],this.y=s[13],this.z=s[14],this}setFromMatrixScale(t){const s=this.setFromMatrixColumn(t,0).length(),i=this.setFromMatrixColumn(t,1).length(),r=this.setFromMatrixColumn(t,2).length();return this.x=s,this.y=i,this.z=r,this}setFromMatrixColumn(t,s){return this.fromArray(t.elements,s*4)}setFromMatrix3Column(t,s){return this.fromArray(t.elements,s*3)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,s=0){return this.x=t[s],this.y=t[s+1],this.z=t[s+2],this}toArray(t=[],s=0){return t[s]=this.x,t[s+1]=this.y,t[s+2]=this.z,t}fromBufferAttribute(t,s,i){return i!==void 0&&console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."),this.x=t.getX(s),this.y=t.getY(s),this.z=t.getZ(s),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=(Math.random()-.5)*2,s=Math.random()*Math.PI*2,i=Math.sqrt(1-t**2);return this.x=i*Math.cos(s),this.y=i*Math.sin(s),this.z=t,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}d.prototype.isVector3=!0;const w=new d,E=new k,Q=Object.freeze(Object.defineProperty({__proto__:null,Vector3:d},Symbol.toStringTag,{value:"Module"}));export{k as Q,d as V,Q as a};
