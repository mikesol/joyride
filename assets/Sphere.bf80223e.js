import{V as n}from"./Vector3.5db2ef2e.js";class b{constructor(t=new n(1/0,1/0,1/0),i=new n(-1/0,-1/0,-1/0)){this.min=t,this.max=i}set(t,i){return this.min.copy(t),this.max.copy(i),this}setFromArray(t){let i=1/0,s=1/0,r=1/0,e=-1/0,a=-1/0,o=-1/0;for(let h=0,z=t.length;h<z;h+=3){const m=t[h],c=t[h+1],u=t[h+2];m<i&&(i=m),c<s&&(s=c),u<r&&(r=u),m>e&&(e=m),c>a&&(a=c),u>o&&(o=u)}return this.min.set(i,s,r),this.max.set(e,a,o),this}setFromBufferAttribute(t){let i=1/0,s=1/0,r=1/0,e=-1/0,a=-1/0,o=-1/0;for(let h=0,z=t.count;h<z;h++){const m=t.getX(h),c=t.getY(h),u=t.getZ(h);m<i&&(i=m),c<s&&(s=c),u<r&&(r=u),m>e&&(e=m),c>a&&(a=c),u>o&&(o=u)}return this.min.set(i,s,r),this.max.set(e,a,o),this}setFromPoints(t){this.makeEmpty();for(let i=0,s=t.length;i<s;i++)this.expandByPoint(t[i]);return this}setFromCenterAndSize(t,i){const s=d.copy(i).multiplyScalar(.5);return this.min.copy(t).sub(s),this.max.copy(t).add(s),this}setFromObject(t,i=!1){return this.makeEmpty(),this.expandByObject(t,i)}clone(){return new this.constructor().copy(this)}copy(t){return this.min.copy(t.min),this.max.copy(t.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(t){return this.isEmpty()?t.set(0,0,0):t.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(t){return this.isEmpty()?t.set(0,0,0):t.subVectors(this.max,this.min)}expandByPoint(t){return this.min.min(t),this.max.max(t),this}expandByVector(t){return this.min.sub(t),this.max.add(t),this}expandByScalar(t){return this.min.addScalar(-t),this.max.addScalar(t),this}expandByObject(t,i=!1){t.updateWorldMatrix(!1,!1);const s=t.geometry;if(s!==void 0)if(i&&s.attributes!=null&&s.attributes.position!==void 0){const e=s.attributes.position;for(let a=0,o=e.count;a<o;a++)d.fromBufferAttribute(e,a).applyMatrix4(t.matrixWorld),this.expandByPoint(d)}else s.boundingBox===null&&s.computeBoundingBox(),_.copy(s.boundingBox),_.applyMatrix4(t.matrixWorld),this.union(_);const r=t.children;for(let e=0,a=r.length;e<a;e++)this.expandByObject(r[e],i);return this}containsPoint(t){return!(t.x<this.min.x||t.x>this.max.x||t.y<this.min.y||t.y>this.max.y||t.z<this.min.z||t.z>this.max.z)}containsBox(t){return this.min.x<=t.min.x&&t.max.x<=this.max.x&&this.min.y<=t.min.y&&t.max.y<=this.max.y&&this.min.z<=t.min.z&&t.max.z<=this.max.z}getParameter(t,i){return i.set((t.x-this.min.x)/(this.max.x-this.min.x),(t.y-this.min.y)/(this.max.y-this.min.y),(t.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(t){return!(t.max.x<this.min.x||t.min.x>this.max.x||t.max.y<this.min.y||t.min.y>this.max.y||t.max.z<this.min.z||t.min.z>this.max.z)}intersectsSphere(t){return this.clampPoint(t.center,d),d.distanceToSquared(t.center)<=t.radius*t.radius}intersectsPlane(t){let i,s;return t.normal.x>0?(i=t.normal.x*this.min.x,s=t.normal.x*this.max.x):(i=t.normal.x*this.max.x,s=t.normal.x*this.min.x),t.normal.y>0?(i+=t.normal.y*this.min.y,s+=t.normal.y*this.max.y):(i+=t.normal.y*this.max.y,s+=t.normal.y*this.min.y),t.normal.z>0?(i+=t.normal.z*this.min.z,s+=t.normal.z*this.max.z):(i+=t.normal.z*this.max.z,s+=t.normal.z*this.min.z),i<=-t.constant&&s>=-t.constant}intersectsTriangle(t){if(this.isEmpty())return!1;this.getCenter(M),g.subVectors(this.max,M),S.subVectors(t.a,M),w.subVectors(t.b,M),B.subVectors(t.c,M),y.subVectors(w,S),l.subVectors(B,w),f.subVectors(S,B);let i=[0,-y.z,y.y,0,-l.z,l.y,0,-f.z,f.y,y.z,0,-y.x,l.z,0,-l.x,f.z,0,-f.x,-y.y,y.x,0,-l.y,l.x,0,-f.y,f.x,0];return!V(i,S,w,B,g)||(i=[1,0,0,0,1,0,0,0,1],!V(i,S,w,B,g))?!1:(I.crossVectors(y,l),i=[I.x,I.y,I.z],V(i,S,w,B,g))}clampPoint(t,i){return i.copy(t).clamp(this.min,this.max)}distanceToPoint(t){return d.copy(t).clamp(this.min,this.max).sub(t).length()}getBoundingSphere(t){return this.getCenter(t.center),t.radius=this.getSize(d).length()*.5,t}intersect(t){return this.min.max(t.min),this.max.min(t.max),this.isEmpty()&&this.makeEmpty(),this}union(t){return this.min.min(t.min),this.max.max(t.max),this}applyMatrix4(t){return this.isEmpty()?this:(x[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(t),x[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(t),x[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(t),x[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(t),x[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(t),x[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(t),x[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(t),x[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(t),this.setFromPoints(x),this)}translate(t){return this.min.add(t),this.max.add(t),this}equals(t){return t.min.equals(this.min)&&t.max.equals(this.max)}}b.prototype.isBox3=!0;const x=[new n,new n,new n,new n,new n,new n,new n,new n],d=new n,_=new b,S=new n,w=new n,B=new n,y=new n,l=new n,f=new n,M=new n,g=new n,I=new n,p=new n;function V(P,t,i,s,r){for(let e=0,a=P.length-3;e<=a;e+=3){p.fromArray(P,e);const o=r.x*Math.abs(p.x)+r.y*Math.abs(p.y)+r.z*Math.abs(p.z),h=t.dot(p),z=i.dot(p),m=s.dot(p);if(Math.max(-Math.max(h,z,m),Math.min(h,z,m))>o)return!1}return!0}const T=new b,F=new n,q=new n,E=new n;class k{constructor(t=new n,i=-1){this.center=t,this.radius=i}set(t,i){return this.center.copy(t),this.radius=i,this}setFromPoints(t,i){const s=this.center;i!==void 0?s.copy(i):T.setFromPoints(t).getCenter(s);let r=0;for(let e=0,a=t.length;e<a;e++)r=Math.max(r,s.distanceToSquared(t[e]));return this.radius=Math.sqrt(r),this}copy(t){return this.center.copy(t.center),this.radius=t.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(t){return t.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(t){return t.distanceTo(this.center)-this.radius}intersectsSphere(t){const i=this.radius+t.radius;return t.center.distanceToSquared(this.center)<=i*i}intersectsBox(t){return t.intersectsSphere(this)}intersectsPlane(t){return Math.abs(t.distanceToPoint(this.center))<=this.radius}clampPoint(t,i){const s=this.center.distanceToSquared(t);return i.copy(t),s>this.radius*this.radius&&(i.sub(this.center).normalize(),i.multiplyScalar(this.radius).add(this.center)),i}getBoundingBox(t){return this.isEmpty()?(t.makeEmpty(),t):(t.set(this.center,this.center),t.expandByScalar(this.radius),t)}applyMatrix4(t){return this.center.applyMatrix4(t),this.radius=this.radius*t.getMaxScaleOnAxis(),this}translate(t){return this.center.add(t),this}expandByPoint(t){E.subVectors(t,this.center);const i=E.lengthSq();if(i>this.radius*this.radius){const s=Math.sqrt(i),r=(s-this.radius)*.5;this.center.add(E.multiplyScalar(r/s)),this.radius+=r}return this}union(t){return this.center.equals(t.center)===!0?q.set(0,0,1).multiplyScalar(t.radius):q.subVectors(t.center,this.center).normalize().multiplyScalar(t.radius),this.expandByPoint(F.copy(t.center).add(q)),this.expandByPoint(F.copy(t.center).sub(q)),this}equals(t){return t.center.equals(this.center)&&t.radius===this.radius}clone(){return new this.constructor().copy(this)}}export{b as B,k as S};
