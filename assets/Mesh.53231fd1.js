import{V as u}from"./Vector3.5db2ef2e.js";import{Vector2 as P}from"./Vector2.3964b2c2.js";import{S as nt}from"./Sphere.bf80223e.js";import{R as it}from"./Ray.14000e07.js";import{Matrix4 as at}from"./Matrix4.0c7a2215.js";import{O as ct}from"./Object3D.d81adcf4.js";import{u as ht,B as ft,D as ut}from"./constants.cc13e4fd.js";import{M as lt}from"./Material.3b90100d.js";import{Color as dt}from"./Color.5efc95ab.js";import{BufferGeometry as pt}from"./BufferGeometry.d5615ad3.js";const w=new u,B=new u,W=new u,V=new u,R=new u,E=new u,et=new u,z=new u,$=new u,J=new u;class x{constructor(t=new u,e=new u,r=new u){this.a=t,this.b=e,this.c=r}static getNormal(t,e,r,s){s.subVectors(r,e),w.subVectors(t,e),s.cross(w);const h=s.lengthSq();return h>0?s.multiplyScalar(1/Math.sqrt(h)):s.set(0,0,0)}static getBarycoord(t,e,r,s,h){w.subVectors(s,e),B.subVectors(r,e),W.subVectors(t,e);const o=w.dot(w),n=w.dot(B),i=w.dot(W),f=B.dot(B),l=B.dot(W),d=o*f-n*n;if(d===0)return h.set(-2,-1,-1);const g=1/d,p=(f*i-n*l)*g,a=(o*l-n*i)*g;return h.set(1-p-a,a,p)}static containsPoint(t,e,r,s){return this.getBarycoord(t,e,r,s,V),V.x>=0&&V.y>=0&&V.x+V.y<=1}static getUV(t,e,r,s,h,o,n,i){return this.getBarycoord(t,e,r,s,V),i.set(0,0),i.addScaledVector(h,V.x),i.addScaledVector(o,V.y),i.addScaledVector(n,V.z),i}static isFrontFacing(t,e,r,s){return w.subVectors(r,e),B.subVectors(t,e),w.cross(B).dot(s)<0}set(t,e,r){return this.a.copy(t),this.b.copy(e),this.c.copy(r),this}setFromPointsAndIndices(t,e,r,s){return this.a.copy(t[e]),this.b.copy(t[r]),this.c.copy(t[s]),this}setFromAttributeAndIndices(t,e,r,s){return this.a.fromBufferAttribute(t,e),this.b.fromBufferAttribute(t,r),this.c.fromBufferAttribute(t,s),this}clone(){return new this.constructor().copy(this)}copy(t){return this.a.copy(t.a),this.b.copy(t.b),this.c.copy(t.c),this}getArea(){return w.subVectors(this.c,this.b),B.subVectors(this.a,this.b),w.cross(B).length()*.5}getMidpoint(t){return t.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(t){return x.getNormal(this.a,this.b,this.c,t)}getPlane(t){return t.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(t,e){return x.getBarycoord(t,this.a,this.b,this.c,e)}getUV(t,e,r,s,h){return x.getUV(t,this.a,this.b,this.c,e,r,s,h)}containsPoint(t){return x.containsPoint(t,this.a,this.b,this.c)}isFrontFacing(t){return x.isFrontFacing(this.a,this.b,this.c,t)}intersectsBox(t){return t.intersectsTriangle(this)}closestPointToPoint(t,e){const r=this.a,s=this.b,h=this.c;let o,n;R.subVectors(s,r),E.subVectors(h,r),z.subVectors(t,r);const i=R.dot(z),f=E.dot(z);if(i<=0&&f<=0)return e.copy(r);$.subVectors(t,s);const l=R.dot($),d=E.dot($);if(l>=0&&d<=l)return e.copy(s);const g=i*d-l*f;if(g<=0&&i>=0&&l<=0)return o=i/(i-l),e.copy(r).addScaledVector(R,o);J.subVectors(t,h);const p=R.dot(J),a=E.dot(J);if(a>=0&&p<=a)return e.copy(h);const y=p*f-i*a;if(y<=0&&f>=0&&a<=0)return n=f/(f-a),e.copy(r).addScaledVector(E,n);const m=l*a-p*d;if(m<=0&&d-l>=0&&p-a>=0)return et.subVectors(h,s),n=(d-l)/(d-l+(p-a)),e.copy(s).addScaledVector(et,n);const c=1/(m+y+g);return o=y*c,n=g*c,e.copy(r).addScaledVector(R,o).addScaledVector(E,n)}equals(t){return t.a.equals(this.a)&&t.b.equals(this.b)&&t.c.equals(this.c)}}class st extends lt{constructor(t){super(),this.type="MeshBasicMaterial",this.color=new dt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=ht,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.lightMap=t.lightMap,this.lightMapIntensity=t.lightMapIntensity,this.aoMap=t.aoMap,this.aoMapIntensity=t.aoMapIntensity,this.specularMap=t.specularMap,this.alphaMap=t.alphaMap,this.envMap=t.envMap,this.combine=t.combine,this.reflectivity=t.reflectivity,this.refractionRatio=t.refractionRatio,this.wireframe=t.wireframe,this.wireframeLinewidth=t.wireframeLinewidth,this.wireframeLinecap=t.wireframeLinecap,this.wireframeLinejoin=t.wireframeLinejoin,this.fog=t.fog,this}}st.prototype.isMeshBasicMaterial=!0;const rt=new at,L=new it,K=new nt,v=new u,A=new u,S=new u,Q=new u,Y=new u,Z=new u,D=new u,F=new u,G=new u,j=new P,q=new P,O=new P,tt=new u,U=new u;class ot extends ct{constructor(t=new pt,e=new st){super(),this.type="Mesh",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),t.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=t.morphTargetInfluences.slice()),t.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},t.morphTargetDictionary)),this.material=t.material,this.geometry=t.geometry,this}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,r=Object.keys(e);if(r.length>0){const s=e[r[0]];if(s!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let h=0,o=s.length;h<o;h++){const n=s[h].name||String(h);this.morphTargetInfluences.push(0),this.morphTargetDictionary[n]=h}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}raycast(t,e){const r=this.geometry,s=this.material,h=this.matrixWorld;if(s===void 0||(r.boundingSphere===null&&r.computeBoundingSphere(),K.copy(r.boundingSphere),K.applyMatrix4(h),t.ray.intersectsSphere(K)===!1)||(rt.copy(h).invert(),L.copy(t.ray).applyMatrix4(rt),r.boundingBox!==null&&L.intersectsBox(r.boundingBox)===!1))return;let o;if(r.isBufferGeometry){const n=r.index,i=r.attributes.position,f=r.morphAttributes.position,l=r.morphTargetsRelative,d=r.attributes.uv,g=r.attributes.uv2,p=r.groups,a=r.drawRange;if(n!==null)if(Array.isArray(s))for(let y=0,m=p.length;y<m;y++){const c=p[y],T=s[c.materialIndex],I=Math.max(c.start,a.start),_=Math.min(n.count,Math.min(c.start+c.count,a.start+a.count));for(let b=I,H=_;b<H;b+=3){const X=n.getX(b),C=n.getX(b+1),N=n.getX(b+2);o=k(this,T,t,L,i,f,l,d,g,X,C,N),o&&(o.faceIndex=Math.floor(b/3),o.face.materialIndex=c.materialIndex,e.push(o))}}else{const y=Math.max(0,a.start),m=Math.min(n.count,a.start+a.count);for(let c=y,T=m;c<T;c+=3){const I=n.getX(c),_=n.getX(c+1),b=n.getX(c+2);o=k(this,s,t,L,i,f,l,d,g,I,_,b),o&&(o.faceIndex=Math.floor(c/3),e.push(o))}}else if(i!==void 0)if(Array.isArray(s))for(let y=0,m=p.length;y<m;y++){const c=p[y],T=s[c.materialIndex],I=Math.max(c.start,a.start),_=Math.min(i.count,Math.min(c.start+c.count,a.start+a.count));for(let b=I,H=_;b<H;b+=3){const X=b,C=b+1,N=b+2;o=k(this,T,t,L,i,f,l,d,g,X,C,N),o&&(o.faceIndex=Math.floor(b/3),o.face.materialIndex=c.materialIndex,e.push(o))}}else{const y=Math.max(0,a.start),m=Math.min(i.count,a.start+a.count);for(let c=y,T=m;c<T;c+=3){const I=c,_=c+1,b=c+2;o=k(this,s,t,L,i,f,l,d,g,I,_,b),o&&(o.faceIndex=Math.floor(c/3),e.push(o))}}}else r.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}ot.prototype.isMesh=!0;function mt(M,t,e,r,s,h,o,n){let i;if(t.side===ft?i=r.intersectTriangle(o,h,s,!0,n):i=r.intersectTriangle(s,h,o,t.side!==ut,n),i===null)return null;U.copy(n),U.applyMatrix4(M.matrixWorld);const f=e.ray.origin.distanceTo(U);return f<e.near||f>e.far?null:{distance:f,point:U.clone(),object:M}}function k(M,t,e,r,s,h,o,n,i,f,l,d){v.fromBufferAttribute(s,f),A.fromBufferAttribute(s,l),S.fromBufferAttribute(s,d);const g=M.morphTargetInfluences;if(h&&g){D.set(0,0,0),F.set(0,0,0),G.set(0,0,0);for(let a=0,y=h.length;a<y;a++){const m=g[a],c=h[a];m!==0&&(Q.fromBufferAttribute(c,f),Y.fromBufferAttribute(c,l),Z.fromBufferAttribute(c,d),o?(D.addScaledVector(Q,m),F.addScaledVector(Y,m),G.addScaledVector(Z,m)):(D.addScaledVector(Q.sub(v),m),F.addScaledVector(Y.sub(A),m),G.addScaledVector(Z.sub(S),m)))}v.add(D),A.add(F),S.add(G)}M.isSkinnedMesh&&(M.boneTransform(f,v),M.boneTransform(l,A),M.boneTransform(d,S));const p=mt(M,t,e,r,v,A,S,tt);if(p){n&&(j.fromBufferAttribute(n,f),q.fromBufferAttribute(n,l),O.fromBufferAttribute(n,d),p.uv=x.getUV(tt,v,A,S,j,q,O,new P)),i&&(j.fromBufferAttribute(i,f),q.fromBufferAttribute(i,l),O.fromBufferAttribute(i,d),p.uv2=x.getUV(tt,v,A,S,j,q,O,new P));const a={a:f,b:l,c:d,normal:new u,materialIndex:0};x.getNormal(v,A,S,a.normal),p.face=a}return p}const St=Object.freeze(Object.defineProperty({__proto__:null,Mesh:ot},Symbol.toStringTag,{value:"Module"}));export{ot as M,st as a,St as b};
