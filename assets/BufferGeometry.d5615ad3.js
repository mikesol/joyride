import{V as m}from"./Vector3.5db2ef2e.js";import{Vector2 as j}from"./Vector2.3964b2c2.js";import{B as P,S as Y}from"./Sphere.bf80223e.js";import{E as Z}from"./EventDispatcher.62ae53dd.js";import{Uint32BufferAttribute as H,Uint16BufferAttribute as q,Float32BufferAttribute as J,BufferAttribute as O}from"./BufferAttribute.ad6349b3.js";import{O as _}from"./Object3D.d81adcf4.js";import{Matrix4 as L}from"./Matrix4.0c7a2215.js";import{M as Q}from"./Matrix3.254ef6d6.js";import{g as K}from"./MathUtils.9169ae61.js";import{a as W}from"./utils.4cfc5b76.js";import"./Vector4.27798d04.js";import"./Color.5efc95ab.js";import"./constants.cc13e4fd.js";import"./Euler.d28ed76f.js";import"./Layers.61b05682.js";let $=0;const B=new L,X=new _,T=new m,g=new P,M=new P,c=new m;class C extends Z{constructor(){super(),Object.defineProperty(this,"id",{value:$++}),this.uuid=K(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new(W(t)?H:q)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return this.attributes[t]!==void 0}addGroup(t,e,r=0){this.groups.push({start:t,count:e,materialIndex:r})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;e!==void 0&&(e.applyMatrix4(t),e.needsUpdate=!0);const r=this.attributes.normal;if(r!==void 0){const a=new Q().getNormalMatrix(t);r.applyNormalMatrix(a),r.needsUpdate=!0}const h=this.attributes.tangent;return h!==void 0&&(h.transformDirection(t),h.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(t){return B.makeRotationFromQuaternion(t),this.applyMatrix4(B),this}rotateX(t){return B.makeRotationX(t),this.applyMatrix4(B),this}rotateY(t){return B.makeRotationY(t),this.applyMatrix4(B),this}rotateZ(t){return B.makeRotationZ(t),this.applyMatrix4(B),this}translate(t,e,r){return B.makeTranslation(t,e,r),this.applyMatrix4(B),this}scale(t,e,r){return B.makeScale(t,e,r),this.applyMatrix4(B),this}lookAt(t){return X.lookAt(t),X.updateMatrix(),this.applyMatrix4(X.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(T).negate(),this.translate(T.x,T.y,T.z),this}setFromPoints(t){const e=[];for(let r=0,h=t.length;r<h;r++){const a=t[r];e.push(a.x,a.y,a.z||0)}return this.setAttribute("position",new J(e,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new P);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new m(-1/0,-1/0,-1/0),new m(1/0,1/0,1/0));return}if(t!==void 0){if(this.boundingBox.setFromBufferAttribute(t),e)for(let r=0,h=e.length;r<h;r++){const a=e[r];g.setFromBufferAttribute(a),this.morphTargetsRelative?(c.addVectors(this.boundingBox.min,g.min),this.boundingBox.expandByPoint(c),c.addVectors(this.boundingBox.max,g.max),this.boundingBox.expandByPoint(c)):(this.boundingBox.expandByPoint(g.min),this.boundingBox.expandByPoint(g.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Y);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new m,1/0);return}if(t){const r=this.boundingSphere.center;if(g.setFromBufferAttribute(t),e)for(let a=0,f=e.length;a<f;a++){const o=e[a];M.setFromBufferAttribute(o),this.morphTargetsRelative?(c.addVectors(g.min,M.min),g.expandByPoint(c),c.addVectors(g.max,M.max),g.expandByPoint(c)):(g.expandByPoint(M.min),g.expandByPoint(M.max))}g.getCenter(r);let h=0;for(let a=0,f=t.count;a<f;a++)c.fromBufferAttribute(t,a),h=Math.max(h,r.distanceToSquared(c));if(e)for(let a=0,f=e.length;a<f;a++){const o=e[a],s=this.morphTargetsRelative;for(let i=0,n=o.count;i<n;i++)c.fromBufferAttribute(o,i),s&&(T.fromBufferAttribute(t,i),c.add(T)),h=Math.max(h,r.distanceToSquared(c))}this.boundingSphere.radius=Math.sqrt(h),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(t===null||e.position===void 0||e.normal===void 0||e.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const r=t.array,h=e.position.array,a=e.normal.array,f=e.uv.array,o=h.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new O(new Float32Array(4*o),4));const s=this.getAttribute("tangent").array,i=[],n=[];for(let d=0;d<o;d++)i[d]=new m,n[d]=new m;const l=new m,u=new m,p=new m,v=new j,b=new j,y=new j,R=new m,E=new m;function F(d,x,A){l.fromArray(h,d*3),u.fromArray(h,x*3),p.fromArray(h,A*3),v.fromArray(f,d*2),b.fromArray(f,x*2),y.fromArray(f,A*2),u.sub(l),p.sub(l),b.sub(v),y.sub(v);const w=1/(b.x*y.y-y.x*b.y);!isFinite(w)||(R.copy(u).multiplyScalar(y.y).addScaledVector(p,-b.y).multiplyScalar(w),E.copy(p).multiplyScalar(b.x).addScaledVector(u,-y.x).multiplyScalar(w),i[d].add(R),i[x].add(R),i[A].add(R),n[d].add(E),n[x].add(E),n[A].add(E))}let N=this.groups;N.length===0&&(N=[{start:0,count:r.length}]);for(let d=0,x=N.length;d<x;++d){const A=N[d],w=A.start,V=A.count;for(let S=w,k=w+V;S<k;S+=3)F(r[S+0],r[S+1],r[S+2])}const G=new m,D=new m,z=new m,U=new m;function I(d){z.fromArray(a,d*3),U.copy(z);const x=i[d];G.copy(x),G.sub(z.multiplyScalar(z.dot(x))).normalize(),D.crossVectors(U,x);const w=D.dot(n[d])<0?-1:1;s[d*4]=G.x,s[d*4+1]=G.y,s[d*4+2]=G.z,s[d*4+3]=w}for(let d=0,x=N.length;d<x;++d){const A=N[d],w=A.start,V=A.count;for(let S=w,k=w+V;S<k;S+=3)I(r[S+0]),I(r[S+1]),I(r[S+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(e!==void 0){let r=this.getAttribute("normal");if(r===void 0)r=new O(new Float32Array(e.count*3),3),this.setAttribute("normal",r);else for(let u=0,p=r.count;u<p;u++)r.setXYZ(u,0,0,0);const h=new m,a=new m,f=new m,o=new m,s=new m,i=new m,n=new m,l=new m;if(t)for(let u=0,p=t.count;u<p;u+=3){const v=t.getX(u+0),b=t.getX(u+1),y=t.getX(u+2);h.fromBufferAttribute(e,v),a.fromBufferAttribute(e,b),f.fromBufferAttribute(e,y),n.subVectors(f,a),l.subVectors(h,a),n.cross(l),o.fromBufferAttribute(r,v),s.fromBufferAttribute(r,b),i.fromBufferAttribute(r,y),o.add(n),s.add(n),i.add(n),r.setXYZ(v,o.x,o.y,o.z),r.setXYZ(b,s.x,s.y,s.z),r.setXYZ(y,i.x,i.y,i.z)}else for(let u=0,p=e.count;u<p;u+=3)h.fromBufferAttribute(e,u+0),a.fromBufferAttribute(e,u+1),f.fromBufferAttribute(e,u+2),n.subVectors(f,a),l.subVectors(h,a),n.cross(l),r.setXYZ(u+0,n.x,n.y,n.z),r.setXYZ(u+1,n.x,n.y,n.z),r.setXYZ(u+2,n.x,n.y,n.z);this.normalizeNormals(),r.needsUpdate=!0}}merge(t,e){if(!(t&&t.isBufferGeometry)){console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);return}e===void 0&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const r=this.attributes;for(const h in r){if(t.attributes[h]===void 0)continue;const f=r[h].array,o=t.attributes[h],s=o.array,i=o.itemSize*e,n=Math.min(s.length,f.length-i);for(let l=0,u=i;l<n;l++,u++)f[u]=s[l]}return this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,r=t.count;e<r;e++)c.fromBufferAttribute(t,e),c.normalize(),t.setXYZ(e,c.x,c.y,c.z)}toNonIndexed(){function t(o,s){const i=o.array,n=o.itemSize,l=o.normalized,u=new i.constructor(s.length*n);let p=0,v=0;for(let b=0,y=s.length;b<y;b++){o.isInterleavedBufferAttribute?p=s[b]*o.data.stride+o.offset:p=s[b]*n;for(let R=0;R<n;R++)u[v++]=i[p++]}return new O(u,n,l)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new C,r=this.index.array,h=this.attributes;for(const o in h){const s=h[o],i=t(s,r);e.setAttribute(o,i)}const a=this.morphAttributes;for(const o in a){const s=[],i=a[o];for(let n=0,l=i.length;n<l;n++){const u=i[n],p=t(u,r);s.push(p)}e.morphAttributes[o]=s}e.morphTargetsRelative=this.morphTargetsRelative;const f=this.groups;for(let o=0,s=f.length;o<s;o++){const i=f[o];e.addGroup(i.start,i.count,i.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,this.name!==""&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),this.parameters!==void 0){const s=this.parameters;for(const i in s)s[i]!==void 0&&(t[i]=s[i]);return t}t.data={attributes:{}};const e=this.index;e!==null&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const r=this.attributes;for(const s in r){const i=r[s];t.data.attributes[s]=i.toJSON(t.data)}const h={};let a=!1;for(const s in this.morphAttributes){const i=this.morphAttributes[s],n=[];for(let l=0,u=i.length;l<u;l++){const p=i[l];n.push(p.toJSON(t.data))}n.length>0&&(h[s]=n,a=!0)}a&&(t.data.morphAttributes=h,t.data.morphTargetsRelative=this.morphTargetsRelative);const f=this.groups;f.length>0&&(t.data.groups=JSON.parse(JSON.stringify(f)));const o=this.boundingSphere;return o!==null&&(t.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),t}clone(){return new this.constructor().copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const r=t.index;r!==null&&this.setIndex(r.clone(e));const h=t.attributes;for(const i in h){const n=h[i];this.setAttribute(i,n.clone(e))}const a=t.morphAttributes;for(const i in a){const n=[],l=a[i];for(let u=0,p=l.length;u<p;u++)n.push(l[u].clone(e));this.morphAttributes[i]=n}this.morphTargetsRelative=t.morphTargetsRelative;const f=t.groups;for(let i=0,n=f.length;i<n;i++){const l=f[i];this.addGroup(l.start,l.count,l.materialIndex)}const o=t.boundingBox;o!==null&&(this.boundingBox=o.clone());const s=t.boundingSphere;return s!==null&&(this.boundingSphere=s.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,t.parameters!==void 0&&(this.parameters=Object.assign({},t.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}C.prototype.isBufferGeometry=!0;export{C as BufferGeometry};
