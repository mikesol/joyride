import{S as E}from"./Sphere.bf80223e.js";import{R}from"./Ray.14000e07.js";import{Matrix4 as w}from"./Matrix4.0c7a2215.js";import{O as S}from"./Object3D.d81adcf4.js";import{V as P}from"./Vector3.5db2ef2e.js";import{M as A}from"./Material.3b90100d.js";import{Color as B}from"./Color.5efc95ab.js";import{BufferGeometry as z}from"./BufferGeometry.d5615ad3.js";import"./MathUtils.9169ae61.js";import"./EventDispatcher.62ae53dd.js";import"./Euler.d28ed76f.js";import"./Layers.61b05682.js";import"./Matrix3.254ef6d6.js";import"./constants.cc13e4fd.js";import"./Vector2.3964b2c2.js";import"./BufferAttribute.ad6349b3.js";import"./Vector4.27798d04.js";import"./utils.4cfc5b76.js";class b extends A{constructor(t){super(),this.type="PointsMaterial",this.color=new B(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(t)}copy(t){return super.copy(t),this.color.copy(t.color),this.map=t.map,this.alphaMap=t.alphaMap,this.size=t.size,this.sizeAttenuation=t.sizeAttenuation,this.fog=t.fog,this}}b.prototype.isPointsMaterial=!0;const T=new w,g=new R,c=new E,l=new P;class G extends S{constructor(t=new z,e=new b){super(),this.type="Points",this.geometry=t,this.material=e,this.updateMorphTargets()}copy(t){return super.copy(t),this.material=t.material,this.geometry=t.geometry,this}raycast(t,e){const o=this.geometry,i=this.matrixWorld,r=t.params.Points.threshold,s=o.drawRange;if(o.boundingSphere===null&&o.computeBoundingSphere(),c.copy(o.boundingSphere),c.applyMatrix4(i),c.radius+=r,t.ray.intersectsSphere(c)===!1)return;T.copy(i).invert(),g.copy(t.ray).applyMatrix4(T);const a=r/((this.scale.x+this.scale.y+this.scale.z)/3),p=a*a;if(o.isBufferGeometry){const h=o.index,f=o.attributes.position;if(h!==null){const u=Math.max(0,s.start),y=Math.min(h.count,s.start+s.count);for(let n=u,d=y;n<d;n++){const M=h.getX(n);l.fromBufferAttribute(f,M),x(l,M,p,i,t,e,this)}}else{const u=Math.max(0,s.start),y=Math.min(f.count,s.start+s.count);for(let n=u,d=y;n<d;n++)l.fromBufferAttribute(f,n),x(l,n,p,i,t,e,this)}}else console.error("THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}updateMorphTargets(){const t=this.geometry;if(t.isBufferGeometry){const e=t.morphAttributes,o=Object.keys(e);if(o.length>0){const i=e[o[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,s=i.length;r<s;r++){const a=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=r}}}}else{const e=t.morphTargets;e!==void 0&&e.length>0&&console.error("THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.")}}}G.prototype.isPoints=!0;function x(m,t,e,o,i,r,s){const a=g.distanceSqToPoint(m);if(a<e){const p=new P;g.closestPointToPoint(m,p),p.applyMatrix4(o);const h=i.ray.origin.distanceTo(p);if(h<i.near||h>i.far)return;r.push({distance:h,distanceToRay:Math.sqrt(a),point:p,index:t,face:null,object:s})}}export{G as Points};
