import{V as X}from"./Vector3.5db2ef2e.js";import"./MathUtils.9169ae61.js";class j{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(e,t,s,n,c,i,o,h,r,m,l,a,u,x,d,z){const M=this.elements;return M[0]=e,M[4]=t,M[8]=s,M[12]=n,M[1]=c,M[5]=i,M[9]=o,M[13]=h,M[2]=r,M[6]=m,M[10]=l,M[14]=a,M[3]=u,M[7]=x,M[11]=d,M[15]=z,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new j().fromArray(this.elements)}copy(e){const t=this.elements,s=e.elements;return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],t[9]=s[9],t[10]=s[10],t[11]=s[11],t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15],this}copyPosition(e){const t=this.elements,s=e.elements;return t[12]=s[12],t[13]=s[13],t[14]=s[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,s){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),s.setFromMatrixColumn(this,2),this}makeBasis(e,t,s){return this.set(e.x,t.x,s.x,0,e.y,t.y,s.y,0,e.z,t.z,s.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,s=e.elements,n=1/F.setFromMatrixColumn(e,0).length(),c=1/F.setFromMatrixColumn(e,1).length(),i=1/F.setFromMatrixColumn(e,2).length();return t[0]=s[0]*n,t[1]=s[1]*n,t[2]=s[2]*n,t[3]=0,t[4]=s[4]*c,t[5]=s[5]*c,t[6]=s[6]*c,t[7]=0,t[8]=s[8]*i,t[9]=s[9]*i,t[10]=s[10]*i,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){e&&e.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const t=this.elements,s=e.x,n=e.y,c=e.z,i=Math.cos(s),o=Math.sin(s),h=Math.cos(n),r=Math.sin(n),m=Math.cos(c),l=Math.sin(c);if(e.order==="XYZ"){const a=i*m,u=i*l,x=o*m,d=o*l;t[0]=h*m,t[4]=-h*l,t[8]=r,t[1]=u+x*r,t[5]=a-d*r,t[9]=-o*h,t[2]=d-a*r,t[6]=x+u*r,t[10]=i*h}else if(e.order==="YXZ"){const a=h*m,u=h*l,x=r*m,d=r*l;t[0]=a+d*o,t[4]=x*o-u,t[8]=i*r,t[1]=i*l,t[5]=i*m,t[9]=-o,t[2]=u*o-x,t[6]=d+a*o,t[10]=i*h}else if(e.order==="ZXY"){const a=h*m,u=h*l,x=r*m,d=r*l;t[0]=a-d*o,t[4]=-i*l,t[8]=x+u*o,t[1]=u+x*o,t[5]=i*m,t[9]=d-a*o,t[2]=-i*r,t[6]=o,t[10]=i*h}else if(e.order==="ZYX"){const a=i*m,u=i*l,x=o*m,d=o*l;t[0]=h*m,t[4]=x*r-u,t[8]=a*r+d,t[1]=h*l,t[5]=d*r+a,t[9]=u*r-x,t[2]=-r,t[6]=o*h,t[10]=i*h}else if(e.order==="YZX"){const a=i*h,u=i*r,x=o*h,d=o*r;t[0]=h*m,t[4]=d-a*l,t[8]=x*l+u,t[1]=l,t[5]=i*m,t[9]=-o*m,t[2]=-r*m,t[6]=u*l+x,t[10]=a-d*l}else if(e.order==="XZY"){const a=i*h,u=i*r,x=o*h,d=o*r;t[0]=h*m,t[4]=-l,t[8]=r*m,t[1]=a*l+d,t[5]=i*m,t[9]=u*l-x,t[2]=x*l-u,t[6]=o*m,t[10]=d*l+a}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(A,e,D)}lookAt(e,t,s){const n=this.elements;return b.subVectors(e,t),b.lengthSq()===0&&(b.z=1),b.normalize(),S.crossVectors(s,b),S.lengthSq()===0&&(Math.abs(s.z)===1?b.x+=1e-4:b.z+=1e-4,b.normalize(),S.crossVectors(s,b)),S.normalize(),U.crossVectors(b,S),n[0]=S.x,n[4]=U.x,n[8]=b.x,n[1]=S.y,n[5]=U.y,n[9]=b.y,n[2]=S.z,n[6]=U.z,n[10]=b.z,this}multiply(e,t){return t!==void 0?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(e,t)):this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const s=e.elements,n=t.elements,c=this.elements,i=s[0],o=s[4],h=s[8],r=s[12],m=s[1],l=s[5],a=s[9],u=s[13],x=s[2],d=s[6],z=s[10],M=s[14],R=s[3],g=s[7],E=s[11],p=s[15],w=n[0],y=n[4],Y=n[8],Z=n[12],_=n[1],V=n[5],v=n[9],C=n[13],P=n[2],T=n[6],q=n[10],H=n[14],B=n[3],O=n[7],I=n[11],Q=n[15];return c[0]=i*w+o*_+h*P+r*B,c[4]=i*y+o*V+h*T+r*O,c[8]=i*Y+o*v+h*q+r*I,c[12]=i*Z+o*C+h*H+r*Q,c[1]=m*w+l*_+a*P+u*B,c[5]=m*y+l*V+a*T+u*O,c[9]=m*Y+l*v+a*q+u*I,c[13]=m*Z+l*C+a*H+u*Q,c[2]=x*w+d*_+z*P+M*B,c[6]=x*y+d*V+z*T+M*O,c[10]=x*Y+d*v+z*q+M*I,c[14]=x*Z+d*C+z*H+M*Q,c[3]=R*w+g*_+E*P+p*B,c[7]=R*y+g*V+E*T+p*O,c[11]=R*Y+g*v+E*q+p*I,c[15]=R*Z+g*C+E*H+p*Q,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],s=e[4],n=e[8],c=e[12],i=e[1],o=e[5],h=e[9],r=e[13],m=e[2],l=e[6],a=e[10],u=e[14],x=e[3],d=e[7],z=e[11],M=e[15];return x*(+c*h*l-n*r*l-c*o*a+s*r*a+n*o*u-s*h*u)+d*(+t*h*u-t*r*a+c*i*a-n*i*u+n*r*m-c*h*m)+z*(+t*r*l-t*o*u-c*i*l+s*i*u+c*o*m-s*r*m)+M*(-n*o*m-t*h*l+t*o*a+n*i*l-s*i*a+s*h*m)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,s){const n=this.elements;return e.isVector3?(n[12]=e.x,n[13]=e.y,n[14]=e.z):(n[12]=e,n[13]=t,n[14]=s),this}invert(){const e=this.elements,t=e[0],s=e[1],n=e[2],c=e[3],i=e[4],o=e[5],h=e[6],r=e[7],m=e[8],l=e[9],a=e[10],u=e[11],x=e[12],d=e[13],z=e[14],M=e[15],R=l*z*r-d*a*r+d*h*u-o*z*u-l*h*M+o*a*M,g=x*a*r-m*z*r-x*h*u+i*z*u+m*h*M-i*a*M,E=m*d*r-x*l*r+x*o*u-i*d*u-m*o*M+i*l*M,p=x*l*h-m*d*h-x*o*a+i*d*a+m*o*z-i*l*z,w=t*R+s*g+n*E+c*p;if(w===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const y=1/w;return e[0]=R*y,e[1]=(d*a*c-l*z*c-d*n*u+s*z*u+l*n*M-s*a*M)*y,e[2]=(o*z*c-d*h*c+d*n*r-s*z*r-o*n*M+s*h*M)*y,e[3]=(l*h*c-o*a*c-l*n*r+s*a*r+o*n*u-s*h*u)*y,e[4]=g*y,e[5]=(m*z*c-x*a*c+x*n*u-t*z*u-m*n*M+t*a*M)*y,e[6]=(x*h*c-i*z*c-x*n*r+t*z*r+i*n*M-t*h*M)*y,e[7]=(i*a*c-m*h*c+m*n*r-t*a*r-i*n*u+t*h*u)*y,e[8]=E*y,e[9]=(x*l*c-m*d*c-x*s*u+t*d*u+m*s*M-t*l*M)*y,e[10]=(i*d*c-x*o*c+x*s*r-t*d*r-i*s*M+t*o*M)*y,e[11]=(m*o*c-i*l*c-m*s*r+t*l*r+i*s*u-t*o*u)*y,e[12]=p*y,e[13]=(m*d*n-x*l*n+x*s*a-t*d*a-m*s*z+t*l*z)*y,e[14]=(x*o*n-i*d*n-x*s*h+t*d*h+i*s*z-t*o*z)*y,e[15]=(i*l*n-m*o*n+m*s*h-t*l*h-i*s*a+t*o*a)*y,this}scale(e){const t=this.elements,s=e.x,n=e.y,c=e.z;return t[0]*=s,t[4]*=n,t[8]*=c,t[1]*=s,t[5]*=n,t[9]*=c,t[2]*=s,t[6]*=n,t[10]*=c,t[3]*=s,t[7]*=n,t[11]*=c,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],s=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],n=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,s,n))}makeTranslation(e,t,s){return this.set(1,0,0,e,0,1,0,t,0,0,1,s,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),s=Math.sin(e);return this.set(1,0,0,0,0,t,-s,0,0,s,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),s=Math.sin(e);return this.set(t,0,s,0,0,1,0,0,-s,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),s=Math.sin(e);return this.set(t,-s,0,0,s,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const s=Math.cos(t),n=Math.sin(t),c=1-s,i=e.x,o=e.y,h=e.z,r=c*i,m=c*o;return this.set(r*i+s,r*o-n*h,r*h+n*o,0,r*o+n*h,m*o+s,m*h-n*i,0,r*h-n*o,m*h+n*i,c*h*h+s,0,0,0,0,1),this}makeScale(e,t,s){return this.set(e,0,0,0,0,t,0,0,0,0,s,0,0,0,0,1),this}makeShear(e,t,s,n,c,i){return this.set(1,s,c,0,e,1,i,0,t,n,1,0,0,0,0,1),this}compose(e,t,s){const n=this.elements,c=t._x,i=t._y,o=t._z,h=t._w,r=c+c,m=i+i,l=o+o,a=c*r,u=c*m,x=c*l,d=i*m,z=i*l,M=o*l,R=h*r,g=h*m,E=h*l,p=s.x,w=s.y,y=s.z;return n[0]=(1-(d+M))*p,n[1]=(u+E)*p,n[2]=(x-g)*p,n[3]=0,n[4]=(u-E)*w,n[5]=(1-(a+M))*w,n[6]=(z+R)*w,n[7]=0,n[8]=(x+g)*y,n[9]=(z-R)*y,n[10]=(1-(a+d))*y,n[11]=0,n[12]=e.x,n[13]=e.y,n[14]=e.z,n[15]=1,this}decompose(e,t,s){const n=this.elements;let c=F.set(n[0],n[1],n[2]).length();const i=F.set(n[4],n[5],n[6]).length(),o=F.set(n[8],n[9],n[10]).length();this.determinant()<0&&(c=-c),e.x=n[12],e.y=n[13],e.z=n[14],k.copy(this);const r=1/c,m=1/i,l=1/o;return k.elements[0]*=r,k.elements[1]*=r,k.elements[2]*=r,k.elements[4]*=m,k.elements[5]*=m,k.elements[6]*=m,k.elements[8]*=l,k.elements[9]*=l,k.elements[10]*=l,t.setFromRotationMatrix(k),s.x=c,s.y=i,s.z=o,this}makePerspective(e,t,s,n,c,i){i===void 0&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const o=this.elements,h=2*c/(t-e),r=2*c/(s-n),m=(t+e)/(t-e),l=(s+n)/(s-n),a=-(i+c)/(i-c),u=-2*i*c/(i-c);return o[0]=h,o[4]=0,o[8]=m,o[12]=0,o[1]=0,o[5]=r,o[9]=l,o[13]=0,o[2]=0,o[6]=0,o[10]=a,o[14]=u,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(e,t,s,n,c,i){const o=this.elements,h=1/(t-e),r=1/(s-n),m=1/(i-c),l=(t+e)*h,a=(s+n)*r,u=(i+c)*m;return o[0]=2*h,o[4]=0,o[8]=0,o[12]=-l,o[1]=0,o[5]=2*r,o[9]=0,o[13]=-a,o[2]=0,o[6]=0,o[10]=-2*m,o[14]=-u,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(e){const t=this.elements,s=e.elements;for(let n=0;n<16;n++)if(t[n]!==s[n])return!1;return!0}fromArray(e,t=0){for(let s=0;s<16;s++)this.elements[s]=e[s+t];return this}toArray(e=[],t=0){const s=this.elements;return e[t]=s[0],e[t+1]=s[1],e[t+2]=s[2],e[t+3]=s[3],e[t+4]=s[4],e[t+5]=s[5],e[t+6]=s[6],e[t+7]=s[7],e[t+8]=s[8],e[t+9]=s[9],e[t+10]=s[10],e[t+11]=s[11],e[t+12]=s[12],e[t+13]=s[13],e[t+14]=s[14],e[t+15]=s[15],e}}j.prototype.isMatrix4=!0;const F=new X,k=new j,A=new X(0,0,0),D=new X(1,1,1),S=new X,U=new X,b=new X;export{j as Matrix4};
