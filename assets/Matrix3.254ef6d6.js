class E{constructor(){this.elements=[1,0,0,0,1,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")}set(t,e,s,n,r,l,c,o,h){const i=this.elements;return i[0]=t,i[1]=n,i[2]=c,i[3]=e,i[4]=r,i[5]=o,i[6]=s,i[7]=l,i[8]=h,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3],e[4]=s[4],e[5]=s[5],e[6]=s[6],e[7]=s[7],e[8]=s[8],this}extractBasis(t,e,s){return t.setFromMatrix3Column(this,0),e.setFromMatrix3Column(this,1),s.setFromMatrix3Column(this,2),this}setFromMatrix4(t){const e=t.elements;return this.set(e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]),this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const s=t.elements,n=e.elements,r=this.elements,l=s[0],c=s[3],o=s[6],h=s[1],i=s[4],u=s[7],a=s[2],M=s[5],p=s[8],m=n[0],b=n[3],d=n[6],g=n[1],F=n[4],v=n[7],A=n[2],x=n[5],C=n[8];return r[0]=l*m+c*g+o*A,r[3]=l*b+c*F+o*x,r[6]=l*d+c*v+o*C,r[1]=h*m+i*g+u*A,r[4]=h*b+i*F+u*x,r[7]=h*d+i*v+u*C,r[2]=a*m+M*g+p*A,r[5]=a*b+M*F+p*x,r[8]=a*d+M*v+p*C,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[3]*=t,e[6]*=t,e[1]*=t,e[4]*=t,e[7]*=t,e[2]*=t,e[5]*=t,e[8]*=t,this}determinant(){const t=this.elements,e=t[0],s=t[1],n=t[2],r=t[3],l=t[4],c=t[5],o=t[6],h=t[7],i=t[8];return e*l*i-e*c*h-s*r*i+s*c*o+n*r*h-n*l*o}invert(){const t=this.elements,e=t[0],s=t[1],n=t[2],r=t[3],l=t[4],c=t[5],o=t[6],h=t[7],i=t[8],u=i*l-c*h,a=c*o-i*r,M=h*r-l*o,p=e*u+s*a+n*M;if(p===0)return this.set(0,0,0,0,0,0,0,0,0);const m=1/p;return t[0]=u*m,t[1]=(n*h-i*s)*m,t[2]=(c*s-n*l)*m,t[3]=a*m,t[4]=(i*e-n*o)*m,t[5]=(n*r-c*e)*m,t[6]=M*m,t[7]=(s*o-h*e)*m,t[8]=(l*e-s*r)*m,this}transpose(){let t;const e=this.elements;return t=e[1],e[1]=e[3],e[3]=t,t=e[2],e[2]=e[6],e[6]=t,t=e[5],e[5]=e[7],e[7]=t,this}getNormalMatrix(t){return this.setFromMatrix4(t).invert().transpose()}transposeIntoArray(t){const e=this.elements;return t[0]=e[0],t[1]=e[3],t[2]=e[6],t[3]=e[1],t[4]=e[4],t[5]=e[7],t[6]=e[2],t[7]=e[5],t[8]=e[8],this}setUvTransform(t,e,s,n,r,l,c){const o=Math.cos(r),h=Math.sin(r);return this.set(s*o,s*h,-s*(o*l+h*c)+l+t,-n*h,n*o,-n*(-h*l+o*c)+c+e,0,0,1),this}scale(t,e){const s=this.elements;return s[0]*=t,s[3]*=t,s[6]*=t,s[1]*=e,s[4]*=e,s[7]*=e,this}rotate(t){const e=Math.cos(t),s=Math.sin(t),n=this.elements,r=n[0],l=n[3],c=n[6],o=n[1],h=n[4],i=n[7];return n[0]=e*r+s*o,n[3]=e*l+s*h,n[6]=e*c+s*i,n[1]=-s*r+e*o,n[4]=-s*l+e*h,n[7]=-s*c+e*i,this}translate(t,e){const s=this.elements;return s[0]+=t*s[2],s[3]+=t*s[5],s[6]+=t*s[8],s[1]+=e*s[2],s[4]+=e*s[5],s[7]+=e*s[8],this}equals(t){const e=this.elements,s=t.elements;for(let n=0;n<9;n++)if(e[n]!==s[n])return!1;return!0}fromArray(t,e=0){for(let s=0;s<9;s++)this.elements[s]=t[s+e];return this}toArray(t=[],e=0){const s=this.elements;return t[e]=s[0],t[e+1]=s[1],t[e+2]=s[2],t[e+3]=s[3],t[e+4]=s[4],t[e+5]=s[5],t[e+6]=s[6],t[e+7]=s[7],t[e+8]=s[8],t}clone(){return new this.constructor().fromArray(this.elements)}}E.prototype.isMatrix3=!0;export{E as M};
