{"version":3,"file":"5699.bundle.js","mappings":"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","sources":["webpack://joyride/./node_modules/three/src/core/BufferGeometry.js","webpack://joyride/./node_modules/three/src/math/Box3.js","webpack://joyride/./node_modules/three/src/math/Sphere.js","webpack://joyride/./node_modules/three/src/utils.js"],"sourcesContent":["import { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Box3 } from '../math/Box3.js';\nimport { EventDispatcher } from './EventDispatcher.js';\nimport { BufferAttribute, Float32BufferAttribute, Uint16BufferAttribute, Uint32BufferAttribute } from './BufferAttribute.js';\nimport { Sphere } from '../math/Sphere.js';\nimport { Object3D } from './Object3D.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Matrix3 } from '../math/Matrix3.js';\nimport * as MathUtils from '../math/MathUtils.js';\nimport { arrayNeedsUint32 } from '../utils.js';\n\nlet _id = 0;\n\nconst _m1 = /*@__PURE__*/ new Matrix4();\nconst _obj = /*@__PURE__*/ new Object3D();\nconst _offset = /*@__PURE__*/ new Vector3();\nconst _box = /*@__PURE__*/ new Box3();\nconst _boxMorphTargets = /*@__PURE__*/ new Box3();\nconst _vector = /*@__PURE__*/ new Vector3();\n\nclass BufferGeometry extends EventDispatcher {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tObject.defineProperty( this, 'id', { value: _id ++ } );\n\n\t\tthis.uuid = MathUtils.generateUUID();\n\n\t\tthis.name = '';\n\t\tthis.type = 'BufferGeometry';\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\n\t\tthis.morphAttributes = {};\n\t\tthis.morphTargetsRelative = false;\n\n\t\tthis.groups = [];\n\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\tthis.drawRange = { start: 0, count: Infinity };\n\n\t\tthis.userData = {};\n\n\t}\n\n\tgetIndex() {\n\n\t\treturn this.index;\n\n\t}\n\n\tsetIndex( index ) {\n\n\t\tif ( Array.isArray( index ) ) {\n\n\t\t\tthis.index = new ( arrayNeedsUint32( index ) ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );\n\n\t\t} else {\n\n\t\t\tthis.index = index;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tgetAttribute( name ) {\n\n\t\treturn this.attributes[ name ];\n\n\t}\n\n\tsetAttribute( name, attribute ) {\n\n\t\tthis.attributes[ name ] = attribute;\n\n\t\treturn this;\n\n\t}\n\n\tdeleteAttribute( name ) {\n\n\t\tdelete this.attributes[ name ];\n\n\t\treturn this;\n\n\t}\n\n\thasAttribute( name ) {\n\n\t\treturn this.attributes[ name ] !== undefined;\n\n\t}\n\n\taddGroup( start, count, materialIndex = 0 ) {\n\n\t\tthis.groups.push( {\n\n\t\t\tstart: start,\n\t\t\tcount: count,\n\t\t\tmaterialIndex: materialIndex\n\n\t\t} );\n\n\t}\n\n\tclearGroups() {\n\n\t\tthis.groups = [];\n\n\t}\n\n\tsetDrawRange( start, count ) {\n\n\t\tthis.drawRange.start = start;\n\t\tthis.drawRange.count = count;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tconst position = this.attributes.position;\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tposition.applyMatrix4( matrix );\n\n\t\t\tposition.needsUpdate = true;\n\n\t\t}\n\n\t\tconst normal = this.attributes.normal;\n\n\t\tif ( normal !== undefined ) {\n\n\t\t\tconst normalMatrix = new Matrix3().getNormalMatrix( matrix );\n\n\t\t\tnormal.applyNormalMatrix( normalMatrix );\n\n\t\t\tnormal.needsUpdate = true;\n\n\t\t}\n\n\t\tconst tangent = this.attributes.tangent;\n\n\t\tif ( tangent !== undefined ) {\n\n\t\t\ttangent.transformDirection( matrix );\n\n\t\t\ttangent.needsUpdate = true;\n\n\t\t}\n\n\t\tif ( this.boundingBox !== null ) {\n\n\t\t\tthis.computeBoundingBox();\n\n\t\t}\n\n\t\tif ( this.boundingSphere !== null ) {\n\n\t\t\tthis.computeBoundingSphere();\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tapplyQuaternion( q ) {\n\n\t\t_m1.makeRotationFromQuaternion( q );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateX( angle ) {\n\n\t\t// rotate geometry around world x-axis\n\n\t\t_m1.makeRotationX( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateY( angle ) {\n\n\t\t// rotate geometry around world y-axis\n\n\t\t_m1.makeRotationY( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\trotateZ( angle ) {\n\n\t\t// rotate geometry around world z-axis\n\n\t\t_m1.makeRotationZ( angle );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( x, y, z ) {\n\n\t\t// translate geometry\n\n\t\t_m1.makeTranslation( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\tscale( x, y, z ) {\n\n\t\t// scale geometry\n\n\t\t_m1.makeScale( x, y, z );\n\n\t\tthis.applyMatrix4( _m1 );\n\n\t\treturn this;\n\n\t}\n\n\tlookAt( vector ) {\n\n\t\t_obj.lookAt( vector );\n\n\t\t_obj.updateMatrix();\n\n\t\tthis.applyMatrix4( _obj.matrix );\n\n\t\treturn this;\n\n\t}\n\n\tcenter() {\n\n\t\tthis.computeBoundingBox();\n\n\t\tthis.boundingBox.getCenter( _offset ).negate();\n\n\t\tthis.translate( _offset.x, _offset.y, _offset.z );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tconst position = [];\n\n\t\tfor ( let i = 0, l = points.length; i < l; i ++ ) {\n\n\t\t\tconst point = points[ i ];\n\t\t\tposition.push( point.x, point.y, point.z || 0 );\n\n\t\t}\n\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );\n\n\t\treturn this;\n\n\t}\n\n\tcomputeBoundingBox() {\n\n\t\tif ( this.boundingBox === null ) {\n\n\t\t\tthis.boundingBox = new Box3();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set \"mesh.frustumCulled\" to \"false\".', this );\n\n\t\t\tthis.boundingBox.set(\n\t\t\t\tnew Vector3( - Infinity, - Infinity, - Infinity ),\n\t\t\t\tnew Vector3( + Infinity, + Infinity, + Infinity )\n\t\t\t);\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position !== undefined ) {\n\n\t\t\tthis.boundingBox.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_box.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.min, _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( this.boundingBox.max, _box.max );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.min );\n\t\t\t\t\t\tthis.boundingBox.expandByPoint( _box.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthis.boundingBox.makeEmpty();\n\n\t\t}\n\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t}\n\n\t}\n\n\tcomputeBoundingSphere() {\n\n\t\tif ( this.boundingSphere === null ) {\n\n\t\t\tthis.boundingSphere = new Sphere();\n\n\t\t}\n\n\t\tconst position = this.attributes.position;\n\t\tconst morphAttributesPosition = this.morphAttributes.position;\n\n\t\tif ( position && position.isGLBufferAttribute ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set \"mesh.frustumCulled\" to \"false\".', this );\n\n\t\t\tthis.boundingSphere.set( new Vector3(), Infinity );\n\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( position ) {\n\n\t\t\t// first, find the center of the bounding sphere\n\n\t\t\tconst center = this.boundingSphere.center;\n\n\t\t\t_box.setFromBufferAttribute( position );\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\t_boxMorphTargets.setFromBufferAttribute( morphAttribute );\n\n\t\t\t\t\tif ( this.morphTargetsRelative ) {\n\n\t\t\t\t\t\t_vector.addVectors( _box.min, _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t\t_vector.addVectors( _box.max, _boxMorphTargets.max );\n\t\t\t\t\t\t_box.expandByPoint( _vector );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.min );\n\t\t\t\t\t\t_box.expandByPoint( _boxMorphTargets.max );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t_box.getCenter( center );\n\n\t\t\t// second, try to find a boundingSphere with a radius smaller than the\n\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\n\n\t\t\tlet maxRadiusSq = 0;\n\n\t\t\tfor ( let i = 0, il = position.count; i < il; i ++ ) {\n\n\t\t\t\t_vector.fromBufferAttribute( position, i );\n\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t}\n\n\t\t\t// process morph attributes if present\n\n\t\t\tif ( morphAttributesPosition ) {\n\n\t\t\t\tfor ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {\n\n\t\t\t\t\tconst morphAttribute = morphAttributesPosition[ i ];\n\t\t\t\t\tconst morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t\t\t\tfor ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {\n\n\t\t\t\t\t\t_vector.fromBufferAttribute( morphAttribute, j );\n\n\t\t\t\t\t\tif ( morphTargetsRelative ) {\n\n\t\t\t\t\t\t\t_offset.fromBufferAttribute( position, j );\n\t\t\t\t\t\t\t_vector.add( _offset );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\n\n\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\n\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcomputeTangents() {\n\n\t\tconst index = this.index;\n\t\tconst attributes = this.attributes;\n\n\t\t// based on http://www.terathon.com/code/tangent.html\n\t\t// (per vertex tangents)\n\n\t\tif ( index === null ||\n\t\t\t attributes.position === undefined ||\n\t\t\t attributes.normal === undefined ||\n\t\t\t attributes.uv === undefined ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );\n\t\t\treturn;\n\n\t\t}\n\n\t\tconst indices = index.array;\n\t\tconst positions = attributes.position.array;\n\t\tconst normals = attributes.normal.array;\n\t\tconst uvs = attributes.uv.array;\n\n\t\tconst nVertices = positions.length / 3;\n\n\t\tif ( this.hasAttribute( 'tangent' ) === false ) {\n\n\t\t\tthis.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );\n\n\t\t}\n\n\t\tconst tangents = this.getAttribute( 'tangent' ).array;\n\n\t\tconst tan1 = [], tan2 = [];\n\n\t\tfor ( let i = 0; i < nVertices; i ++ ) {\n\n\t\t\ttan1[ i ] = new Vector3();\n\t\t\ttan2[ i ] = new Vector3();\n\n\t\t}\n\n\t\tconst vA = new Vector3(),\n\t\t\tvB = new Vector3(),\n\t\t\tvC = new Vector3(),\n\n\t\t\tuvA = new Vector2(),\n\t\t\tuvB = new Vector2(),\n\t\t\tuvC = new Vector2(),\n\n\t\t\tsdir = new Vector3(),\n\t\t\ttdir = new Vector3();\n\n\t\tfunction handleTriangle( a, b, c ) {\n\n\t\t\tvA.fromArray( positions, a * 3 );\n\t\t\tvB.fromArray( positions, b * 3 );\n\t\t\tvC.fromArray( positions, c * 3 );\n\n\t\t\tuvA.fromArray( uvs, a * 2 );\n\t\t\tuvB.fromArray( uvs, b * 2 );\n\t\t\tuvC.fromArray( uvs, c * 2 );\n\n\t\t\tvB.sub( vA );\n\t\t\tvC.sub( vA );\n\n\t\t\tuvB.sub( uvA );\n\t\t\tuvC.sub( uvA );\n\n\t\t\tconst r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );\n\n\t\t\t// silently ignore degenerate uv triangles having coincident or colinear vertices\n\n\t\t\tif ( ! isFinite( r ) ) return;\n\n\t\t\tsdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );\n\t\t\ttdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );\n\n\t\t\ttan1[ a ].add( sdir );\n\t\t\ttan1[ b ].add( sdir );\n\t\t\ttan1[ c ].add( sdir );\n\n\t\t\ttan2[ a ].add( tdir );\n\t\t\ttan2[ b ].add( tdir );\n\t\t\ttan2[ c ].add( tdir );\n\n\t\t}\n\n\t\tlet groups = this.groups;\n\n\t\tif ( groups.length === 0 ) {\n\n\t\t\tgroups = [ {\n\t\t\t\tstart: 0,\n\t\t\t\tcount: indices.length\n\t\t\t} ];\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleTriangle(\n\t\t\t\t\tindices[ j + 0 ],\n\t\t\t\t\tindices[ j + 1 ],\n\t\t\t\t\tindices[ j + 2 ]\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst tmp = new Vector3(), tmp2 = new Vector3();\n\t\tconst n = new Vector3(), n2 = new Vector3();\n\n\t\tfunction handleVertex( v ) {\n\n\t\t\tn.fromArray( normals, v * 3 );\n\t\t\tn2.copy( n );\n\n\t\t\tconst t = tan1[ v ];\n\n\t\t\t// Gram-Schmidt orthogonalize\n\n\t\t\ttmp.copy( t );\n\t\t\ttmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();\n\n\t\t\t// Calculate handedness\n\n\t\t\ttmp2.crossVectors( n2, t );\n\t\t\tconst test = tmp2.dot( tan2[ v ] );\n\t\t\tconst w = ( test < 0.0 ) ? - 1.0 : 1.0;\n\n\t\t\ttangents[ v * 4 ] = tmp.x;\n\t\t\ttangents[ v * 4 + 1 ] = tmp.y;\n\t\t\ttangents[ v * 4 + 2 ] = tmp.z;\n\t\t\ttangents[ v * 4 + 3 ] = w;\n\n\t\t}\n\n\t\tfor ( let i = 0, il = groups.length; i < il; ++ i ) {\n\n\t\t\tconst group = groups[ i ];\n\n\t\t\tconst start = group.start;\n\t\t\tconst count = group.count;\n\n\t\t\tfor ( let j = start, jl = start + count; j < jl; j += 3 ) {\n\n\t\t\t\thandleVertex( indices[ j + 0 ] );\n\t\t\t\thandleVertex( indices[ j + 1 ] );\n\t\t\t\thandleVertex( indices[ j + 2 ] );\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tcomputeVertexNormals() {\n\n\t\tconst index = this.index;\n\t\tconst positionAttribute = this.getAttribute( 'position' );\n\n\t\tif ( positionAttribute !== undefined ) {\n\n\t\t\tlet normalAttribute = this.getAttribute( 'normal' );\n\n\t\t\tif ( normalAttribute === undefined ) {\n\n\t\t\t\tnormalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );\n\t\t\t\tthis.setAttribute( 'normal', normalAttribute );\n\n\t\t\t} else {\n\n\t\t\t\t// reset existing normals to zero\n\n\t\t\t\tfor ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {\n\n\t\t\t\t\tnormalAttribute.setXYZ( i, 0, 0, 0 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n\t\t\tconst nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n\t\t\tconst cb = new Vector3(), ab = new Vector3();\n\n\t\t\t// indexed elements\n\n\t\t\tif ( index ) {\n\n\t\t\t\tfor ( let i = 0, il = index.count; i < il; i += 3 ) {\n\n\t\t\t\t\tconst vA = index.getX( i + 0 );\n\t\t\t\t\tconst vB = index.getX( i + 1 );\n\t\t\t\t\tconst vC = index.getX( i + 2 );\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, vA );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, vB );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, vC );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnA.fromBufferAttribute( normalAttribute, vA );\n\t\t\t\t\tnB.fromBufferAttribute( normalAttribute, vB );\n\t\t\t\t\tnC.fromBufferAttribute( normalAttribute, vC );\n\n\t\t\t\t\tnA.add( cb );\n\t\t\t\t\tnB.add( cb );\n\t\t\t\t\tnC.add( cb );\n\n\t\t\t\t\tnormalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );\n\t\t\t\t\tnormalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\n\n\t\t\t\tfor ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {\n\n\t\t\t\t\tpA.fromBufferAttribute( positionAttribute, i + 0 );\n\t\t\t\t\tpB.fromBufferAttribute( positionAttribute, i + 1 );\n\t\t\t\t\tpC.fromBufferAttribute( positionAttribute, i + 2 );\n\n\t\t\t\t\tcb.subVectors( pC, pB );\n\t\t\t\t\tab.subVectors( pA, pB );\n\t\t\t\t\tcb.cross( ab );\n\n\t\t\t\t\tnormalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );\n\t\t\t\t\tnormalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tthis.normalizeNormals();\n\n\t\t\tnormalAttribute.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n\tmerge( geometry, offset ) {\n\n\t\tif ( ! ( geometry && geometry.isBufferGeometry ) ) {\n\n\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\n\t\t\treturn;\n\n\t\t}\n\n\t\tif ( offset === undefined ) {\n\n\t\t\toffset = 0;\n\n\t\t\tconsole.warn(\n\t\t\t\t'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '\n\t\t\t\t+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'\n\t\t\t);\n\n\t\t}\n\n\t\tconst attributes = this.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\n\n\t\t\tconst attribute1 = attributes[ key ];\n\t\t\tconst attributeArray1 = attribute1.array;\n\n\t\t\tconst attribute2 = geometry.attributes[ key ];\n\t\t\tconst attributeArray2 = attribute2.array;\n\n\t\t\tconst attributeOffset = attribute2.itemSize * offset;\n\t\t\tconst length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );\n\n\t\t\tfor ( let i = 0, j = attributeOffset; i < length; i ++, j ++ ) {\n\n\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tnormalizeNormals() {\n\n\t\tconst normals = this.attributes.normal;\n\n\t\tfor ( let i = 0, il = normals.count; i < il; i ++ ) {\n\n\t\t\t_vector.fromBufferAttribute( normals, i );\n\n\t\t\t_vector.normalize();\n\n\t\t\tnormals.setXYZ( i, _vector.x, _vector.y, _vector.z );\n\n\t\t}\n\n\t}\n\n\ttoNonIndexed() {\n\n\t\tfunction convertBufferAttribute( attribute, indices ) {\n\n\t\t\tconst array = attribute.array;\n\t\t\tconst itemSize = attribute.itemSize;\n\t\t\tconst normalized = attribute.normalized;\n\n\t\t\tconst array2 = new array.constructor( indices.length * itemSize );\n\n\t\t\tlet index = 0, index2 = 0;\n\n\t\t\tfor ( let i = 0, l = indices.length; i < l; i ++ ) {\n\n\t\t\t\tif ( attribute.isInterleavedBufferAttribute ) {\n\n\t\t\t\t\tindex = indices[ i ] * attribute.data.stride + attribute.offset;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tindex = indices[ i ] * itemSize;\n\n\t\t\t\t}\n\n\t\t\t\tfor ( let j = 0; j < itemSize; j ++ ) {\n\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new BufferAttribute( array2, itemSize, normalized );\n\n\t\t}\n\n\t\t//\n\n\t\tif ( this.index === null ) {\n\n\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );\n\t\t\treturn this;\n\n\t\t}\n\n\t\tconst geometry2 = new BufferGeometry();\n\n\t\tconst indices = this.index.array;\n\t\tconst attributes = this.attributes;\n\n\t\t// attributes\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\n\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\tgeometry2.setAttribute( name, newAttribute );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = this.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst morphArray = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = morphAttribute[ i ];\n\n\t\t\t\tconst newAttribute = convertBufferAttribute( attribute, indices );\n\n\t\t\t\tmorphArray.push( newAttribute );\n\n\t\t\t}\n\n\t\t\tgeometry2.morphAttributes[ name ] = morphArray;\n\n\t\t}\n\n\t\tgeometry2.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = this.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tgeometry2.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\treturn geometry2;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'BufferGeometry',\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\n\t\t\t}\n\t\t};\n\n\t\t// standard BufferGeometry serialization\n\n\t\tdata.uuid = this.uuid;\n\t\tdata.type = this.type;\n\t\tif ( this.name !== '' ) data.name = this.name;\n\t\tif ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;\n\n\t\tif ( this.parameters !== undefined ) {\n\n\t\t\tconst parameters = this.parameters;\n\n\t\t\tfor ( const key in parameters ) {\n\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\n\n\t\t\t}\n\n\t\t\treturn data;\n\n\t\t}\n\n\t\t// for simplicity the code assumes attributes are not shared across geometries, see #15811\n\n\t\tdata.data = { attributes: {} };\n\n\t\tconst index = this.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tdata.data.index = {\n\t\t\t\ttype: index.array.constructor.name,\n\t\t\t\tarray: Array.prototype.slice.call( index.array )\n\t\t\t};\n\n\t\t}\n\n\t\tconst attributes = this.attributes;\n\n\t\tfor ( const key in attributes ) {\n\n\t\t\tconst attribute = attributes[ key ];\n\n\t\t\tdata.data.attributes[ key ] = attribute.toJSON( data.data );\n\n\t\t}\n\n\t\tconst morphAttributes = {};\n\t\tlet hasMorphAttributes = false;\n\n\t\tfor ( const key in this.morphAttributes ) {\n\n\t\t\tconst attributeArray = this.morphAttributes[ key ];\n\n\t\t\tconst array = [];\n\n\t\t\tfor ( let i = 0, il = attributeArray.length; i < il; i ++ ) {\n\n\t\t\t\tconst attribute = attributeArray[ i ];\n\n\t\t\t\tarray.push( attribute.toJSON( data.data ) );\n\n\t\t\t}\n\n\t\t\tif ( array.length > 0 ) {\n\n\t\t\t\tmorphAttributes[ key ] = array;\n\n\t\t\t\thasMorphAttributes = true;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( hasMorphAttributes ) {\n\n\t\t\tdata.data.morphAttributes = morphAttributes;\n\t\t\tdata.data.morphTargetsRelative = this.morphTargetsRelative;\n\n\t\t}\n\n\t\tconst groups = this.groups;\n\n\t\tif ( groups.length > 0 ) {\n\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\n\n\t\t}\n\n\t\tconst boundingSphere = this.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tdata.data.boundingSphere = {\n\t\t\t\tcenter: boundingSphere.center.toArray(),\n\t\t\t\tradius: boundingSphere.radius\n\t\t\t};\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tclone() {\n\n\t\t return new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\t// reset\n\n\t\tthis.index = null;\n\t\tthis.attributes = {};\n\t\tthis.morphAttributes = {};\n\t\tthis.groups = [];\n\t\tthis.boundingBox = null;\n\t\tthis.boundingSphere = null;\n\n\t\t// used for storing cloned, shared data\n\n\t\tconst data = {};\n\n\t\t// name\n\n\t\tthis.name = source.name;\n\n\t\t// index\n\n\t\tconst index = source.index;\n\n\t\tif ( index !== null ) {\n\n\t\t\tthis.setIndex( index.clone( data ) );\n\n\t\t}\n\n\t\t// attributes\n\n\t\tconst attributes = source.attributes;\n\n\t\tfor ( const name in attributes ) {\n\n\t\t\tconst attribute = attributes[ name ];\n\t\t\tthis.setAttribute( name, attribute.clone( data ) );\n\n\t\t}\n\n\t\t// morph attributes\n\n\t\tconst morphAttributes = source.morphAttributes;\n\n\t\tfor ( const name in morphAttributes ) {\n\n\t\t\tconst array = [];\n\t\t\tconst morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes\n\n\t\t\tfor ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {\n\n\t\t\t\tarray.push( morphAttribute[ i ].clone( data ) );\n\n\t\t\t}\n\n\t\t\tthis.morphAttributes[ name ] = array;\n\n\t\t}\n\n\t\tthis.morphTargetsRelative = source.morphTargetsRelative;\n\n\t\t// groups\n\n\t\tconst groups = source.groups;\n\n\t\tfor ( let i = 0, l = groups.length; i < l; i ++ ) {\n\n\t\t\tconst group = groups[ i ];\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\n\n\t\t}\n\n\t\t// bounding box\n\n\t\tconst boundingBox = source.boundingBox;\n\n\t\tif ( boundingBox !== null ) {\n\n\t\t\tthis.boundingBox = boundingBox.clone();\n\n\t\t}\n\n\t\t// bounding sphere\n\n\t\tconst boundingSphere = source.boundingSphere;\n\n\t\tif ( boundingSphere !== null ) {\n\n\t\t\tthis.boundingSphere = boundingSphere.clone();\n\n\t\t}\n\n\t\t// draw range\n\n\t\tthis.drawRange.start = source.drawRange.start;\n\t\tthis.drawRange.count = source.drawRange.count;\n\n\t\t// user data\n\n\t\tthis.userData = source.userData;\n\n\t\t// geometry generator parameters\n\n\t\tif ( source.parameters !== undefined ) this.parameters = Object.assign( {}, source.parameters );\n\n\t\treturn this;\n\n\t}\n\n\tdispose() {\n\n\t\tthis.dispatchEvent( { type: 'dispose' } );\n\n\t}\n\n}\n\nBufferGeometry.prototype.isBufferGeometry = true;\n\nexport { BufferGeometry };\n","import { Vector3 } from './Vector3.js';\n\nclass Box3 {\n\n\tconstructor( min = new Vector3( + Infinity, + Infinity, + Infinity ), max = new Vector3( - Infinity, - Infinity, - Infinity ) ) {\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t}\n\n\tset( min, max ) {\n\n\t\tthis.min.copy( min );\n\t\tthis.max.copy( max );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromArray( array ) {\n\n\t\tlet minX = + Infinity;\n\t\tlet minY = + Infinity;\n\t\tlet minZ = + Infinity;\n\n\t\tlet maxX = - Infinity;\n\t\tlet maxY = - Infinity;\n\t\tlet maxZ = - Infinity;\n\n\t\tfor ( let i = 0, l = array.length; i < l; i += 3 ) {\n\n\t\t\tconst x = array[ i ];\n\t\t\tconst y = array[ i + 1 ];\n\t\t\tconst z = array[ i + 2 ];\n\n\t\t\tif ( x < minX ) minX = x;\n\t\t\tif ( y < minY ) minY = y;\n\t\t\tif ( z < minZ ) minZ = z;\n\n\t\t\tif ( x > maxX ) maxX = x;\n\t\t\tif ( y > maxY ) maxY = y;\n\t\t\tif ( z > maxZ ) maxZ = z;\n\n\t\t}\n\n\t\tthis.min.set( minX, minY, minZ );\n\t\tthis.max.set( maxX, maxY, maxZ );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromBufferAttribute( attribute ) {\n\n\t\tlet minX = + Infinity;\n\t\tlet minY = + Infinity;\n\t\tlet minZ = + Infinity;\n\n\t\tlet maxX = - Infinity;\n\t\tlet maxY = - Infinity;\n\t\tlet maxZ = - Infinity;\n\n\t\tfor ( let i = 0, l = attribute.count; i < l; i ++ ) {\n\n\t\t\tconst x = attribute.getX( i );\n\t\t\tconst y = attribute.getY( i );\n\t\t\tconst z = attribute.getZ( i );\n\n\t\t\tif ( x < minX ) minX = x;\n\t\t\tif ( y < minY ) minY = y;\n\t\t\tif ( z < minZ ) minZ = z;\n\n\t\t\tif ( x > maxX ) maxX = x;\n\t\t\tif ( y > maxY ) maxY = y;\n\t\t\tif ( z > maxZ ) maxZ = z;\n\n\t\t}\n\n\t\tthis.min.set( minX, minY, minZ );\n\t\tthis.max.set( maxX, maxY, maxZ );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tthis.makeEmpty();\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tthis.expandByPoint( points[ i ] );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetFromCenterAndSize( center, size ) {\n\n\t\tconst halfSize = _vector.copy( size ).multiplyScalar( 0.5 );\n\n\t\tthis.min.copy( center ).sub( halfSize );\n\t\tthis.max.copy( center ).add( halfSize );\n\n\t\treturn this;\n\n\t}\n\n\tsetFromObject( object, precise = false ) {\n\n\t\tthis.makeEmpty();\n\n\t\treturn this.expandByObject( object, precise );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( box ) {\n\n\t\tthis.min.copy( box.min );\n\t\tthis.max.copy( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\n\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\n\n\t}\n\n\tgetCenter( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\n\n\t}\n\n\tgetSize( target ) {\n\n\t\treturn this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );\n\n\t}\n\n\texpandByPoint( point ) {\n\n\t\tthis.min.min( point );\n\t\tthis.max.max( point );\n\n\t\treturn this;\n\n\t}\n\n\texpandByVector( vector ) {\n\n\t\tthis.min.sub( vector );\n\t\tthis.max.add( vector );\n\n\t\treturn this;\n\n\t}\n\n\texpandByScalar( scalar ) {\n\n\t\tthis.min.addScalar( - scalar );\n\t\tthis.max.addScalar( scalar );\n\n\t\treturn this;\n\n\t}\n\n\texpandByObject( object, precise = false ) {\n\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\n\t\t// accounting for both the object's, and children's, world transforms\n\n\t\tobject.updateWorldMatrix( false, false );\n\n\t\tconst geometry = object.geometry;\n\n\t\tif ( geometry !== undefined ) {\n\n\t\t\tif ( precise && geometry.attributes != undefined && geometry.attributes.position !== undefined ) {\n\n\t\t\t\tconst position = geometry.attributes.position;\n\t\t\t\tfor ( let i = 0, l = position.count; i < l; i ++ ) {\n\n\t\t\t\t\t_vector.fromBufferAttribute( position, i ).applyMatrix4( object.matrixWorld );\n\t\t\t\t\tthis.expandByPoint( _vector );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( geometry.boundingBox === null ) {\n\n\t\t\t\t\tgeometry.computeBoundingBox();\n\n\t\t\t\t}\n\n\t\t\t\t_box.copy( geometry.boundingBox );\n\t\t\t\t_box.applyMatrix4( object.matrixWorld );\n\n\t\t\t\tthis.union( _box );\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst children = object.children;\n\n\t\tfor ( let i = 0, l = children.length; i < l; i ++ ) {\n\n\t\t\tthis.expandByObject( children[ i ], precise );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn point.x < this.min.x || point.x > this.max.x ||\n\t\t\tpoint.y < this.min.y || point.y > this.max.y ||\n\t\t\tpoint.z < this.min.z || point.z > this.max.z ? false : true;\n\n\t}\n\n\tcontainsBox( box ) {\n\n\t\treturn this.min.x <= box.min.x && box.max.x <= this.max.x &&\n\t\t\tthis.min.y <= box.min.y && box.max.y <= this.max.y &&\n\t\t\tthis.min.z <= box.min.z && box.max.z <= this.max.z;\n\n\t}\n\n\tgetParameter( point, target ) {\n\n\t\t// This can potentially have a divide by zero if the box\n\t\t// has a size dimension of 0.\n\n\t\treturn target.set(\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\n\t\t);\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\t// using 6 splitting planes to rule out intersections.\n\t\treturn box.max.x < this.min.x || box.min.x > this.max.x ||\n\t\t\tbox.max.y < this.min.y || box.min.y > this.max.y ||\n\t\t\tbox.max.z < this.min.z || box.min.z > this.max.z ? false : true;\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\t// Find the point on the AABB closest to the sphere center.\n\t\tthis.clampPoint( sphere.center, _vector );\n\n\t\t// If that point is inside the sphere, the AABB and sphere intersect.\n\t\treturn _vector.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\t// We compute the minimum and maximum dot product values. If those values\n\t\t// are on the same side (back or front) of the plane, then there is no intersection.\n\n\t\tlet min, max;\n\n\t\tif ( plane.normal.x > 0 ) {\n\n\t\t\tmin = plane.normal.x * this.min.x;\n\t\t\tmax = plane.normal.x * this.max.x;\n\n\t\t} else {\n\n\t\t\tmin = plane.normal.x * this.max.x;\n\t\t\tmax = plane.normal.x * this.min.x;\n\n\t\t}\n\n\t\tif ( plane.normal.y > 0 ) {\n\n\t\t\tmin += plane.normal.y * this.min.y;\n\t\t\tmax += plane.normal.y * this.max.y;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.y * this.max.y;\n\t\t\tmax += plane.normal.y * this.min.y;\n\n\t\t}\n\n\t\tif ( plane.normal.z > 0 ) {\n\n\t\t\tmin += plane.normal.z * this.min.z;\n\t\t\tmax += plane.normal.z * this.max.z;\n\n\t\t} else {\n\n\t\t\tmin += plane.normal.z * this.max.z;\n\t\t\tmax += plane.normal.z * this.min.z;\n\n\t\t}\n\n\t\treturn ( min <= - plane.constant && max >= - plane.constant );\n\n\t}\n\n\tintersectsTriangle( triangle ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// compute box center and extents\n\t\tthis.getCenter( _center );\n\t\t_extents.subVectors( this.max, _center );\n\n\t\t// translate triangle to aabb origin\n\t\t_v0.subVectors( triangle.a, _center );\n\t\t_v1.subVectors( triangle.b, _center );\n\t\t_v2.subVectors( triangle.c, _center );\n\n\t\t// compute edge vectors for triangle\n\t\t_f0.subVectors( _v1, _v0 );\n\t\t_f1.subVectors( _v2, _v1 );\n\t\t_f2.subVectors( _v0, _v2 );\n\n\t\t// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb\n\t\t// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation\n\t\t// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)\n\t\tlet axes = [\n\t\t\t0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,\n\t\t\t_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,\n\t\t\t- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0\n\t\t];\n\t\tif ( ! satForAxes( axes, _v0, _v1, _v2, _extents ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// test 3 face normals from the aabb\n\t\taxes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];\n\t\tif ( ! satForAxes( axes, _v0, _v1, _v2, _extents ) ) {\n\n\t\t\treturn false;\n\n\t\t}\n\n\t\t// finally testing the face normal of the triangle\n\t\t// use already existing triangle edge vectors here\n\t\t_triangleNormal.crossVectors( _f0, _f1 );\n\t\taxes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];\n\n\t\treturn satForAxes( axes, _v0, _v1, _v2, _extents );\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\treturn target.copy( point ).clamp( this.min, this.max );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\tconst clampedPoint = _vector.copy( point ).clamp( this.min, this.max );\n\n\t\treturn clampedPoint.sub( point ).length();\n\n\t}\n\n\tgetBoundingSphere( target ) {\n\n\t\tthis.getCenter( target.center );\n\n\t\ttarget.radius = this.getSize( _vector ).length() * 0.5;\n\n\t\treturn target;\n\n\t}\n\n\tintersect( box ) {\n\n\t\tthis.min.max( box.min );\n\t\tthis.max.min( box.max );\n\n\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\n\t\tif ( this.isEmpty() ) this.makeEmpty();\n\n\t\treturn this;\n\n\t}\n\n\tunion( box ) {\n\n\t\tthis.min.min( box.min );\n\t\tthis.max.max( box.max );\n\n\t\treturn this;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\t// transform of empty box is an empty box.\n\t\tif ( this.isEmpty() ) return this;\n\n\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\n\t\t_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\n\t\t_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\n\t\t_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\n\t\t_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\n\t\t_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\n\t\t_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\n\t\t_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\n\t\t_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111\n\n\t\tthis.setFromPoints( _points );\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.min.add( offset );\n\t\tthis.max.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\tequals( box ) {\n\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\n\n\t}\n\n}\n\nBox3.prototype.isBox3 = true;\n\nconst _points = [\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3(),\n\t/*@__PURE__*/ new Vector3()\n];\n\nconst _vector = /*@__PURE__*/ new Vector3();\n\nconst _box = /*@__PURE__*/ new Box3();\n\n// triangle centered vertices\n\nconst _v0 = /*@__PURE__*/ new Vector3();\nconst _v1 = /*@__PURE__*/ new Vector3();\nconst _v2 = /*@__PURE__*/ new Vector3();\n\n// triangle edge vectors\n\nconst _f0 = /*@__PURE__*/ new Vector3();\nconst _f1 = /*@__PURE__*/ new Vector3();\nconst _f2 = /*@__PURE__*/ new Vector3();\n\nconst _center = /*@__PURE__*/ new Vector3();\nconst _extents = /*@__PURE__*/ new Vector3();\nconst _triangleNormal = /*@__PURE__*/ new Vector3();\nconst _testAxis = /*@__PURE__*/ new Vector3();\n\nfunction satForAxes( axes, v0, v1, v2, extents ) {\n\n\tfor ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {\n\n\t\t_testAxis.fromArray( axes, i );\n\t\t// project the aabb onto the separating axis\n\t\tconst r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );\n\t\t// project all 3 vertices of the triangle onto the separating axis\n\t\tconst p0 = v0.dot( _testAxis );\n\t\tconst p1 = v1.dot( _testAxis );\n\t\tconst p2 = v2.dot( _testAxis );\n\t\t// actual test, basically see if either of the most extreme of the triangle points intersects r\n\t\tif ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {\n\n\t\t\t// points of the projected triangle are outside the projected half-length of the aabb\n\t\t\t// the axis is separating and we can exit\n\t\t\treturn false;\n\n\t\t}\n\n\t}\n\n\treturn true;\n\n}\n\nexport { Box3 };\n","import { Box3 } from './Box3.js';\nimport { Vector3 } from './Vector3.js';\n\nconst _box = /*@__PURE__*/ new Box3();\nconst _v1 = /*@__PURE__*/ new Vector3();\nconst _toFarthestPoint = /*@__PURE__*/ new Vector3();\nconst _toPoint = /*@__PURE__*/ new Vector3();\n\nclass Sphere {\n\n\tconstructor( center = new Vector3(), radius = - 1 ) {\n\n\t\tthis.center = center;\n\t\tthis.radius = radius;\n\n\t}\n\n\tset( center, radius ) {\n\n\t\tthis.center.copy( center );\n\t\tthis.radius = radius;\n\n\t\treturn this;\n\n\t}\n\n\tsetFromPoints( points, optionalCenter ) {\n\n\t\tconst center = this.center;\n\n\t\tif ( optionalCenter !== undefined ) {\n\n\t\t\tcenter.copy( optionalCenter );\n\n\t\t} else {\n\n\t\t\t_box.setFromPoints( points ).getCenter( center );\n\n\t\t}\n\n\t\tlet maxRadiusSq = 0;\n\n\t\tfor ( let i = 0, il = points.length; i < il; i ++ ) {\n\n\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\n\n\t\t}\n\n\t\tthis.radius = Math.sqrt( maxRadiusSq );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( sphere ) {\n\n\t\tthis.center.copy( sphere.center );\n\t\tthis.radius = sphere.radius;\n\n\t\treturn this;\n\n\t}\n\n\tisEmpty() {\n\n\t\treturn ( this.radius < 0 );\n\n\t}\n\n\tmakeEmpty() {\n\n\t\tthis.center.set( 0, 0, 0 );\n\t\tthis.radius = - 1;\n\n\t\treturn this;\n\n\t}\n\n\tcontainsPoint( point ) {\n\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\n\n\t}\n\n\tdistanceToPoint( point ) {\n\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\n\n\t}\n\n\tintersectsSphere( sphere ) {\n\n\t\tconst radiusSum = this.radius + sphere.radius;\n\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\n\n\t}\n\n\tintersectsBox( box ) {\n\n\t\treturn box.intersectsSphere( this );\n\n\t}\n\n\tintersectsPlane( plane ) {\n\n\t\treturn Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;\n\n\t}\n\n\tclampPoint( point, target ) {\n\n\t\tconst deltaLengthSq = this.center.distanceToSquared( point );\n\n\t\ttarget.copy( point );\n\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\ttarget.sub( this.center ).normalize();\n\t\t\ttarget.multiplyScalar( this.radius ).add( this.center );\n\n\t\t}\n\n\t\treturn target;\n\n\t}\n\n\tgetBoundingBox( target ) {\n\n\t\tif ( this.isEmpty() ) {\n\n\t\t\t// Empty sphere produces empty bounding box\n\t\t\ttarget.makeEmpty();\n\t\t\treturn target;\n\n\t\t}\n\n\t\ttarget.set( this.center, this.center );\n\t\ttarget.expandByScalar( this.radius );\n\n\t\treturn target;\n\n\t}\n\n\tapplyMatrix4( matrix ) {\n\n\t\tthis.center.applyMatrix4( matrix );\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\n\n\t\treturn this;\n\n\t}\n\n\ttranslate( offset ) {\n\n\t\tthis.center.add( offset );\n\n\t\treturn this;\n\n\t}\n\n\texpandByPoint( point ) {\n\n\t\t// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L649-L671\n\n\t\t_toPoint.subVectors( point, this.center );\n\n\t\tconst lengthSq = _toPoint.lengthSq();\n\n\t\tif ( lengthSq > ( this.radius * this.radius ) ) {\n\n\t\t\tconst length = Math.sqrt( lengthSq );\n\t\t\tconst missingRadiusHalf = ( length - this.radius ) * 0.5;\n\n\t\t\t// Nudge this sphere towards the target point. Add half the missing distance to radius,\n\t\t\t// and the other half to position. This gives a tighter enclosure, instead of if\n\t\t\t// the whole missing distance were just added to radius.\n\n\t\t\tthis.center.add( _toPoint.multiplyScalar( missingRadiusHalf / length ) );\n\t\t\tthis.radius += missingRadiusHalf;\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tunion( sphere ) {\n\n\t\t// from https://github.com/juj/MathGeoLib/blob/2940b99b99cfe575dd45103ef20f4019dee15b54/src/Geometry/Sphere.cpp#L759-L769\n\n\t\t// To enclose another sphere into this sphere, we only need to enclose two points:\n\t\t// 1) Enclose the farthest point on the other sphere into this sphere.\n\t\t// 2) Enclose the opposite point of the farthest point into this sphere.\n\n\t\t if ( this.center.equals( sphere.center ) === true ) {\n\n\t\t\t _toFarthestPoint.set( 0, 0, 1 ).multiplyScalar( sphere.radius );\n\n\n\t\t} else {\n\n\t\t\t_toFarthestPoint.subVectors( sphere.center, this.center ).normalize().multiplyScalar( sphere.radius );\n\n\t\t}\n\n\t\tthis.expandByPoint( _v1.copy( sphere.center ).add( _toFarthestPoint ) );\n\t\tthis.expandByPoint( _v1.copy( sphere.center ).sub( _toFarthestPoint ) );\n\n\t\treturn this;\n\n\t}\n\n\tequals( sphere ) {\n\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nexport { Sphere };\n","function arrayMin( array ) {\n\n\tif ( array.length === 0 ) return Infinity;\n\n\tlet min = array[ 0 ];\n\n\tfor ( let i = 1, l = array.length; i < l; ++ i ) {\n\n\t\tif ( array[ i ] < min ) min = array[ i ];\n\n\t}\n\n\treturn min;\n\n}\n\nfunction arrayMax( array ) {\n\n\tif ( array.length === 0 ) return - Infinity;\n\n\tlet max = array[ 0 ];\n\n\tfor ( let i = 1, l = array.length; i < l; ++ i ) {\n\n\t\tif ( array[ i ] > max ) max = array[ i ];\n\n\t}\n\n\treturn max;\n\n}\n\nfunction arrayNeedsUint32( array ) {\n\n\t// assumes larger values usually on last\n\n\tfor ( let i = array.length - 1; i >= 0; -- i ) {\n\n\t\tif ( array[ i ] > 65535 ) return true;\n\n\t}\n\n\treturn false;\n\n}\n\nconst TYPED_ARRAYS = {\n\tInt8Array: Int8Array,\n\tUint8Array: Uint8Array,\n\tUint8ClampedArray: Uint8ClampedArray,\n\tInt16Array: Int16Array,\n\tUint16Array: Uint16Array,\n\tInt32Array: Int32Array,\n\tUint32Array: Uint32Array,\n\tFloat32Array: Float32Array,\n\tFloat64Array: Float64Array\n};\n\nfunction getTypedArray( type, buffer ) {\n\n\treturn new TYPED_ARRAYS[ type ]( buffer );\n\n}\n\nfunction createElementNS( name ) {\n\n\treturn document.createElementNS( 'http://www.w3.org/1999/xhtml', name );\n\n}\n\nexport { arrayMin, arrayMax, arrayNeedsUint32, getTypedArray, createElementNS };\n"],"names":["_id","_m1","Matrix4","_obj","_offset","Vector3","_box","Box3","_boxMorphTargets","_vector","BufferGeometry","constructor","super","Object","defineProperty","this","value","uuid","name","type","index","attributes","morphAttributes","morphTargetsRelative","groups","boundingBox","boundingSphere","drawRange","start","count","Infinity","userData","getIndex","setIndex","Array","isArray","Uint32BufferAttribute","Uint16BufferAttribute","getAttribute","setAttribute","attribute","deleteAttribute","hasAttribute","undefined","addGroup","materialIndex","push","clearGroups","setDrawRange","applyMatrix4","matrix","position","needsUpdate","normal","normalMatrix","getNormalMatrix","applyNormalMatrix","tangent","transformDirection","computeBoundingBox","computeBoundingSphere","applyQuaternion","q","makeRotationFromQuaternion","rotateX","angle","makeRotationX","rotateY","makeRotationY","rotateZ","makeRotationZ","translate","x","y","z","makeTranslation","scale","makeScale","lookAt","vector","updateMatrix","center","getCenter","negate","setFromPoints","points","i","l","length","point","Float32BufferAttribute","morphAttributesPosition","isGLBufferAttribute","console","error","set","setFromBufferAttribute","il","morphAttribute","addVectors","min","expandByPoint","max","makeEmpty","isNaN","Sphere","maxRadiusSq","fromBufferAttribute","Math","distanceToSquared","j","jl","add","radius","sqrt","computeTangents","uv","indices","array","positions","normals","uvs","nVertices","BufferAttribute","Float32Array","tangents","tan1","tan2","vA","vB","vC","uvA","Vector2","uvB","uvC","sdir","tdir","handleTriangle","a","b","c","fromArray","sub","r","isFinite","copy","multiplyScalar","addScaledVector","group","tmp","tmp2","n","n2","handleVertex","v","t","dot","normalize","crossVectors","w","computeVertexNormals","positionAttribute","normalAttribute","setXYZ","pA","pB","pC","nA","nB","nC","cb","ab","getX","subVectors","cross","normalizeNormals","merge","geometry","offset","isBufferGeometry","warn","key","attributeArray1","attribute2","attributeArray2","attributeOffset","itemSize","toNonIndexed","convertBufferAttribute","normalized","array2","index2","isInterleavedBufferAttribute","data","stride","geometry2","newAttribute","morphArray","toJSON","metadata","version","generator","keys","parameters","prototype","slice","call","hasMorphAttributes","attributeArray","JSON","parse","stringify","toArray","clone","source","assign","dispose","dispatchEvent","setFromArray","minX","minY","minZ","maxX","maxY","maxZ","getY","getZ","setFromCenterAndSize","size","halfSize","setFromObject","object","precise","expandByObject","box","isEmpty","target","getSize","expandByVector","expandByScalar","scalar","addScalar","updateWorldMatrix","matrixWorld","union","children","containsPoint","containsBox","getParameter","intersectsBox","intersectsSphere","sphere","clampPoint","intersectsPlane","plane","constant","intersectsTriangle","triangle","_center","_extents","_v0","_v1","_v2","_f0","_f1","_f2","axes","satForAxes","_triangleNormal","clamp","distanceToPoint","getBoundingSphere","intersect","_points","equals","isBox3","_testAxis","v0","v1","v2","extents","abs","p0","p1","p2","_toFarthestPoint","_toPoint","optionalCenter","distanceTo","radiusSum","deltaLengthSq","getBoundingBox","getMaxScaleOnAxis","lengthSq","missingRadiusHalf","arrayNeedsUint32","createElementNS","document","Int8Array","Uint8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float64Array"],"sourceRoot":""}