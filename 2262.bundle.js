"use strict";(self.webpackChunkjoyride=self.webpackChunkjoyride||[]).push([[2262],{2262:(e,t,n)=>{n.r(t),n.d(t,{BloomPass:()=>a});var r=n(9477),i=n(8304);const s={defines:{KERNEL_SIZE_FLOAT:"25.0",KERNEL_SIZE_INT:"25"},uniforms:{tDiffuse:{value:null},uImageIncrement:{value:new r.FM8(.001953125,0)},cKernel:{value:[]}},vertexShader:"\n\n\t\tuniform vec2 uImageIncrement;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv - ( ( KERNEL_SIZE_FLOAT - 1.0 ) / 2.0 ) * uImageIncrement;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float cKernel[ KERNEL_SIZE_INT ];\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec2 uImageIncrement;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec2 imageCoord = vUv;\n\t\t\tvec4 sum = vec4( 0.0, 0.0, 0.0, 0.0 );\n\n\t\t\tfor( int i = 0; i < KERNEL_SIZE_INT; i ++ ) {\n\n\t\t\t\tsum += texture2D( tDiffuse, imageCoord ) * cKernel[ i ];\n\t\t\t\timageCoord += uImageIncrement;\n\n\t\t\t}\n\n\t\t\tgl_FragColor = sum;\n\n\t\t}",buildKernel:function(e){let t=2*Math.ceil(3*e)+1;t>25&&(t=25);const n=.5*(t-1),r=new Array(t);let i=0;for(let s=0;s<t;++s)r[s]=o(s-n,e),i+=r[s];for(let e=0;e<t;++e)r[e]/=i;return r}};function o(e,t){return Math.exp(-e*e/(2*t*t))}class a extends i.w{constructor(e=1,t=25,n=4,o=256){super(),this.renderTargetX=new r.dd2(o,o),this.renderTargetX.texture.name="BloomPass.x",this.renderTargetY=new r.dd2(o,o),this.renderTargetY.texture.name="BloomPass.y",this.combineUniforms=r.rDY.clone(u.uniforms),this.combineUniforms.strength.value=e,this.materialCombine=new r.jyz({uniforms:this.combineUniforms,vertexShader:u.vertexShader,fragmentShader:u.fragmentShader,blending:r.WMw,transparent:!0}),void 0===s&&console.error("THREE.BloomPass relies on ConvolutionShader");const l=s;this.convolutionUniforms=r.rDY.clone(l.uniforms),this.convolutionUniforms.uImageIncrement.value=a.blurX,this.convolutionUniforms.cKernel.value=s.buildKernel(n),this.materialConvolution=new r.jyz({uniforms:this.convolutionUniforms,vertexShader:l.vertexShader,fragmentShader:l.fragmentShader,defines:{KERNEL_SIZE_FLOAT:t.toFixed(1),KERNEL_SIZE_INT:t.toFixed(0)}}),this.needsSwap=!1,this.fsQuad=new i.T(null)}render(e,t,n,r,i){i&&e.state.buffers.stencil.setTest(!1),this.fsQuad.material=this.materialConvolution,this.convolutionUniforms.tDiffuse.value=n.texture,this.convolutionUniforms.uImageIncrement.value=a.blurX,e.setRenderTarget(this.renderTargetX),e.clear(),this.fsQuad.render(e),this.convolutionUniforms.tDiffuse.value=this.renderTargetX.texture,this.convolutionUniforms.uImageIncrement.value=a.blurY,e.setRenderTarget(this.renderTargetY),e.clear(),this.fsQuad.render(e),this.fsQuad.material=this.materialCombine,this.combineUniforms.tDiffuse.value=this.renderTargetY.texture,i&&e.state.buffers.stencil.setTest(!0),e.setRenderTarget(n),this.clear&&e.clear(),this.fsQuad.render(e)}}const u={uniforms:{tDiffuse:{value:null},strength:{value:1}},vertexShader:"\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",fragmentShader:"\n\n\t\tuniform float strength;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = strength * texel;\n\n\t\t}"};a.blurX=new r.FM8(.001953125,0),a.blurY=new r.FM8(0,.001953125)},8304:(e,t,n)=>{n.d(t,{T:()=>a,w:()=>i});var r=n(9477);class i{constructor(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1}setSize(){}render(){console.error("THREE.Pass: .render() must be implemented in derived pass.")}}const s=new r.iKG(-1,1,1,-1,0,1),o=new r.u9r;o.setAttribute("position",new r.a$l([-1,3,0,-1,-1,0,3,-1,0],3)),o.setAttribute("uv",new r.a$l([0,2,0,0,2,0],2));class a{constructor(e){this._mesh=new r.Kj0(o,e)}dispose(){this._mesh.geometry.dispose()}render(e){e.render(this._mesh,s)}get material(){return this._mesh.material}set material(e){this._mesh.material=e}}}}]);
//# sourceMappingURL=2262.bundle.js.map