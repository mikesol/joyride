{"version":3,"file":"9891.bundle.js","mappings":"oMAIA,MAAMA,UAAuB,EAAAC,eAE5BC,YAAaC,EAAS,EAAGC,EAAgB,GAAIC,EAAiB,GAAIC,EAAW,EAAGC,EAAsB,EAAVC,KAAKC,GAAQC,EAAa,EAAGC,EAAcH,KAAKC,IAE3IG,QACAC,KAAKC,KAAO,iBAEZD,KAAKE,WAAa,CACjBZ,OAAQA,EACRC,cAAeA,EACfC,eAAgBA,EAChBC,SAAUA,EACVC,UAAWA,EACXG,WAAYA,EACZC,YAAaA,GAGdP,EAAgBI,KAAKQ,IAAK,EAAGR,KAAKS,MAAOb,IACzCC,EAAiBG,KAAKQ,IAAK,EAAGR,KAAKS,MAAOZ,IAE1C,MAAMa,EAAWV,KAAKW,IAAKT,EAAaC,EAAaH,KAAKC,IAE1D,IAAIW,EAAQ,EACZ,MAAMC,EAAO,GAEPC,EAAS,IAAI,EAAAC,QACbC,EAAS,IAAI,EAAAD,QAIbE,EAAU,GACVC,EAAW,GACXC,EAAU,GACVC,EAAM,GAIZ,IAAM,IAAIC,EAAK,EAAGA,GAAMxB,EAAgBwB,IAAQ,CAE/C,MAAMC,EAAc,GAEdC,EAAIF,EAAKxB,EAIf,IAAI2B,EAAU,EAEH,GAANH,GAAyB,GAAdnB,EAEfsB,EAAU,GAAM5B,EAELyB,GAAMxB,GAAkBa,GAAYV,KAAKC,KAEpDuB,GAAY,GAAM5B,GAInB,IAAM,IAAI6B,EAAK,EAAGA,GAAM7B,EAAe6B,IAAQ,CAE9C,MAAMC,EAAID,EAAK7B,EAIfkB,EAAOa,GAAMhC,EAASK,KAAK4B,IAAK9B,EAAW4B,EAAI3B,GAAcC,KAAK6B,IAAK3B,EAAaqB,EAAIpB,GACxFW,EAAOgB,EAAInC,EAASK,KAAK4B,IAAK1B,EAAaqB,EAAIpB,GAC/CW,EAAOiB,EAAIpC,EAASK,KAAK6B,IAAK/B,EAAW4B,EAAI3B,GAAcC,KAAK6B,IAAK3B,EAAaqB,EAAIpB,GAEtFe,EAASc,KAAMlB,EAAOa,EAAGb,EAAOgB,EAAGhB,EAAOiB,GAI1Cf,EAAOiB,KAAMnB,GAASoB,YACtBf,EAAQa,KAAMhB,EAAOW,EAAGX,EAAOc,EAAGd,EAAOe,GAIzCX,EAAIY,KAAMN,EAAIF,EAAS,EAAID,GAE3BD,EAAYU,KAAMpB,KAInBC,EAAKmB,KAAMV,GAMZ,IAAM,IAAID,EAAK,EAAGA,EAAKxB,EAAgBwB,IAEtC,IAAM,IAAII,EAAK,EAAGA,EAAK7B,EAAe6B,IAAQ,CAE7C,MAAMU,EAAItB,EAAMQ,GAAMI,EAAK,GACrBW,EAAIvB,EAAMQ,GAAMI,GAChBY,EAAIxB,EAAMQ,EAAK,GAAKI,GACpBa,EAAIzB,EAAMQ,EAAK,GAAKI,EAAK,IAEnB,IAAPJ,GAAYnB,EAAa,IAAIe,EAAQe,KAAMG,EAAGC,EAAGE,IACjDjB,IAAOxB,EAAiB,GAAKa,EAAWV,KAAKC,KAAKgB,EAAQe,KAAMI,EAAGC,EAAGC,GAQ7EjC,KAAKkC,SAAUtB,GACfZ,KAAKmC,aAAc,WAAY,IAAI,EAAAC,uBAAwBvB,EAAU,IACrEb,KAAKmC,aAAc,SAAU,IAAI,EAAAC,uBAAwBtB,EAAS,IAClEd,KAAKmC,aAAc,KAAM,IAAI,EAAAC,uBAAwBrB,EAAK,IAI3DsB,gBAAiBC,GAEhB,OAAO,IAAInD,EAAgBmD,EAAKhD,OAAQgD,EAAK/C,cAAe+C,EAAK9C,eAAgB8C,EAAK7C,SAAU6C,EAAK5C,UAAW4C,EAAKzC,WAAYyC,EAAKxC","sources":["webpack://joyride/./node_modules/three/src/geometries/SphereGeometry.js"],"sourcesContent":["import { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { Vector3 } from '../math/Vector3.js';\n\nclass SphereGeometry extends BufferGeometry {\n\n\tconstructor( radius = 1, widthSegments = 32, heightSegments = 16, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {\n\n\t\tsuper();\n\t\tthis.type = 'SphereGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\twidthSegments: widthSegments,\n\t\t\theightSegments: heightSegments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength,\n\t\t\tthetaStart: thetaStart,\n\t\t\tthetaLength: thetaLength\n\t\t};\n\n\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) );\n\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) );\n\n\t\tconst thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );\n\n\t\tlet index = 0;\n\t\tconst grid = [];\n\n\t\tconst vertex = new Vector3();\n\t\tconst normal = new Vector3();\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\t// generate vertices, normals and uvs\n\n\t\tfor ( let iy = 0; iy <= heightSegments; iy ++ ) {\n\n\t\t\tconst verticesRow = [];\n\n\t\t\tconst v = iy / heightSegments;\n\n\t\t\t// special case for the poles\n\n\t\t\tlet uOffset = 0;\n\n\t\t\tif ( iy == 0 && thetaStart == 0 ) {\n\n\t\t\t\tuOffset = 0.5 / widthSegments;\n\n\t\t\t} else if ( iy == heightSegments && thetaEnd == Math.PI ) {\n\n\t\t\t\tuOffset = - 0.5 / widthSegments;\n\n\t\t\t}\n\n\t\t\tfor ( let ix = 0; ix <= widthSegments; ix ++ ) {\n\n\t\t\t\tconst u = ix / widthSegments;\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\t\t\t\tvertex.y = radius * Math.cos( thetaStart + v * thetaLength );\n\t\t\t\tvertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// normal\n\n\t\t\t\tnormal.copy( vertex ).normalize();\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuvs.push( u + uOffset, 1 - v );\n\n\t\t\t\tverticesRow.push( index ++ );\n\n\t\t\t}\n\n\t\t\tgrid.push( verticesRow );\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let iy = 0; iy < heightSegments; iy ++ ) {\n\n\t\t\tfor ( let ix = 0; ix < widthSegments; ix ++ ) {\n\n\t\t\t\tconst a = grid[ iy ][ ix + 1 ];\n\t\t\t\tconst b = grid[ iy ][ ix ];\n\t\t\t\tconst c = grid[ iy + 1 ][ ix ];\n\t\t\t\tconst d = grid[ iy + 1 ][ ix + 1 ];\n\n\t\t\t\tif ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );\n\t\t\t\tif ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new SphereGeometry( data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength );\n\n\t}\n\n}\n\nexport { SphereGeometry, SphereGeometry as SphereBufferGeometry };\n"],"names":["SphereGeometry","BufferGeometry","constructor","radius","widthSegments","heightSegments","phiStart","phiLength","Math","PI","thetaStart","thetaLength","super","this","type","parameters","max","floor","thetaEnd","min","index","grid","vertex","Vector3","normal","indices","vertices","normals","uvs","iy","verticesRow","v","uOffset","ix","u","x","cos","sin","y","z","push","copy","normalize","a","b","c","d","setIndex","setAttribute","Float32BufferAttribute","static","data"],"sourceRoot":""}