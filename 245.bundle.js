"use strict";(self.webpackChunkjoyride=self.webpackChunkjoyride||[]).push([[245],{1245:(t,e,s)=>{s.r(e),s.d(e,{Matrix4:()=>r});var n=s(4532);class r{constructor(){this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],arguments.length>0&&console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")}set(t,e,s,n,r,i,o,h,a,l,c,m,u,x,M,y){const p=this.elements;return p[0]=t,p[4]=e,p[8]=s,p[12]=n,p[1]=r,p[5]=i,p[9]=o,p[13]=h,p[2]=a,p[6]=l,p[10]=c,p[14]=m,p[3]=u,p[7]=x,p[11]=M,p[15]=y,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new r).fromArray(this.elements)}copy(t){const e=this.elements,s=t.elements;return e[0]=s[0],e[1]=s[1],e[2]=s[2],e[3]=s[3],e[4]=s[4],e[5]=s[5],e[6]=s[6],e[7]=s[7],e[8]=s[8],e[9]=s[9],e[10]=s[10],e[11]=s[11],e[12]=s[12],e[13]=s[13],e[14]=s[14],e[15]=s[15],this}copyPosition(t){const e=this.elements,s=t.elements;return e[12]=s[12],e[13]=s[13],e[14]=s[14],this}setFromMatrix3(t){const e=t.elements;return this.set(e[0],e[3],e[6],0,e[1],e[4],e[7],0,e[2],e[5],e[8],0,0,0,0,1),this}extractBasis(t,e,s){return t.setFromMatrixColumn(this,0),e.setFromMatrixColumn(this,1),s.setFromMatrixColumn(this,2),this}makeBasis(t,e,s){return this.set(t.x,e.x,s.x,0,t.y,e.y,s.y,0,t.z,e.z,s.z,0,0,0,0,1),this}extractRotation(t){const e=this.elements,s=t.elements,n=1/i.setFromMatrixColumn(t,0).length(),r=1/i.setFromMatrixColumn(t,1).length(),o=1/i.setFromMatrixColumn(t,2).length();return e[0]=s[0]*n,e[1]=s[1]*n,e[2]=s[2]*n,e[3]=0,e[4]=s[4]*r,e[5]=s[5]*r,e[6]=s[6]*r,e[7]=0,e[8]=s[8]*o,e[9]=s[9]*o,e[10]=s[10]*o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromEuler(t){t&&t.isEuler||console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");const e=this.elements,s=t.x,n=t.y,r=t.z,i=Math.cos(s),o=Math.sin(s),h=Math.cos(n),a=Math.sin(n),l=Math.cos(r),c=Math.sin(r);if("XYZ"===t.order){const t=i*l,s=i*c,n=o*l,r=o*c;e[0]=h*l,e[4]=-h*c,e[8]=a,e[1]=s+n*a,e[5]=t-r*a,e[9]=-o*h,e[2]=r-t*a,e[6]=n+s*a,e[10]=i*h}else if("YXZ"===t.order){const t=h*l,s=h*c,n=a*l,r=a*c;e[0]=t+r*o,e[4]=n*o-s,e[8]=i*a,e[1]=i*c,e[5]=i*l,e[9]=-o,e[2]=s*o-n,e[6]=r+t*o,e[10]=i*h}else if("ZXY"===t.order){const t=h*l,s=h*c,n=a*l,r=a*c;e[0]=t-r*o,e[4]=-i*c,e[8]=n+s*o,e[1]=s+n*o,e[5]=i*l,e[9]=r-t*o,e[2]=-i*a,e[6]=o,e[10]=i*h}else if("ZYX"===t.order){const t=i*l,s=i*c,n=o*l,r=o*c;e[0]=h*l,e[4]=n*a-s,e[8]=t*a+r,e[1]=h*c,e[5]=r*a+t,e[9]=s*a-n,e[2]=-a,e[6]=o*h,e[10]=i*h}else if("YZX"===t.order){const t=i*h,s=i*a,n=o*h,r=o*a;e[0]=h*l,e[4]=r-t*c,e[8]=n*c+s,e[1]=c,e[5]=i*l,e[9]=-o*l,e[2]=-a*l,e[6]=s*c+n,e[10]=t-r*c}else if("XZY"===t.order){const t=i*h,s=i*a,n=o*h,r=o*a;e[0]=h*l,e[4]=-c,e[8]=a*l,e[1]=t*c+r,e[5]=i*l,e[9]=s*c-n,e[2]=n*c-s,e[6]=o*l,e[10]=r*c+t}return e[3]=0,e[7]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,this}makeRotationFromQuaternion(t){return this.compose(h,t,a)}lookAt(t,e,s){const n=this.elements;return m.subVectors(t,e),0===m.lengthSq()&&(m.z=1),m.normalize(),l.crossVectors(s,m),0===l.lengthSq()&&(1===Math.abs(s.z)?m.x+=1e-4:m.z+=1e-4,m.normalize(),l.crossVectors(s,m)),l.normalize(),c.crossVectors(m,l),n[0]=l.x,n[4]=c.x,n[8]=m.x,n[1]=l.y,n[5]=c.y,n[9]=m.y,n[2]=l.z,n[6]=c.z,n[10]=m.z,this}multiply(t,e){return void 0!==e?(console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."),this.multiplyMatrices(t,e)):this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,e){const s=t.elements,n=e.elements,r=this.elements,i=s[0],o=s[4],h=s[8],a=s[12],l=s[1],c=s[5],m=s[9],u=s[13],x=s[2],M=s[6],y=s[10],p=s[14],d=s[3],z=s[7],k=s[11],w=s[15],f=n[0],g=n[4],R=n[8],E=n[12],V=n[1],F=n[5],C=n[9],X=n[13],Y=n[2],Z=n[6],b=n[10],v=n[14],A=n[3],S=n[7],P=n[11],T=n[15];return r[0]=i*f+o*V+h*Y+a*A,r[4]=i*g+o*F+h*Z+a*S,r[8]=i*R+o*C+h*b+a*P,r[12]=i*E+o*X+h*v+a*T,r[1]=l*f+c*V+m*Y+u*A,r[5]=l*g+c*F+m*Z+u*S,r[9]=l*R+c*C+m*b+u*P,r[13]=l*E+c*X+m*v+u*T,r[2]=x*f+M*V+y*Y+p*A,r[6]=x*g+M*F+y*Z+p*S,r[10]=x*R+M*C+y*b+p*P,r[14]=x*E+M*X+y*v+p*T,r[3]=d*f+z*V+k*Y+w*A,r[7]=d*g+z*F+k*Z+w*S,r[11]=d*R+z*C+k*b+w*P,r[15]=d*E+z*X+k*v+w*T,this}multiplyScalar(t){const e=this.elements;return e[0]*=t,e[4]*=t,e[8]*=t,e[12]*=t,e[1]*=t,e[5]*=t,e[9]*=t,e[13]*=t,e[2]*=t,e[6]*=t,e[10]*=t,e[14]*=t,e[3]*=t,e[7]*=t,e[11]*=t,e[15]*=t,this}determinant(){const t=this.elements,e=t[0],s=t[4],n=t[8],r=t[12],i=t[1],o=t[5],h=t[9],a=t[13],l=t[2],c=t[6],m=t[10],u=t[14];return t[3]*(+r*h*c-n*a*c-r*o*m+s*a*m+n*o*u-s*h*u)+t[7]*(+e*h*u-e*a*m+r*i*m-n*i*u+n*a*l-r*h*l)+t[11]*(+e*a*c-e*o*u-r*i*c+s*i*u+r*o*l-s*a*l)+t[15]*(-n*o*l-e*h*c+e*o*m+n*i*c-s*i*m+s*h*l)}transpose(){const t=this.elements;let e;return e=t[1],t[1]=t[4],t[4]=e,e=t[2],t[2]=t[8],t[8]=e,e=t[6],t[6]=t[9],t[9]=e,e=t[3],t[3]=t[12],t[12]=e,e=t[7],t[7]=t[13],t[13]=e,e=t[11],t[11]=t[14],t[14]=e,this}setPosition(t,e,s){const n=this.elements;return t.isVector3?(n[12]=t.x,n[13]=t.y,n[14]=t.z):(n[12]=t,n[13]=e,n[14]=s),this}invert(){const t=this.elements,e=t[0],s=t[1],n=t[2],r=t[3],i=t[4],o=t[5],h=t[6],a=t[7],l=t[8],c=t[9],m=t[10],u=t[11],x=t[12],M=t[13],y=t[14],p=t[15],d=c*y*a-M*m*a+M*h*u-o*y*u-c*h*p+o*m*p,z=x*m*a-l*y*a-x*h*u+i*y*u+l*h*p-i*m*p,k=l*M*a-x*c*a+x*o*u-i*M*u-l*o*p+i*c*p,w=x*c*h-l*M*h-x*o*m+i*M*m+l*o*y-i*c*y,f=e*d+s*z+n*k+r*w;if(0===f)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const g=1/f;return t[0]=d*g,t[1]=(M*m*r-c*y*r-M*n*u+s*y*u+c*n*p-s*m*p)*g,t[2]=(o*y*r-M*h*r+M*n*a-s*y*a-o*n*p+s*h*p)*g,t[3]=(c*h*r-o*m*r-c*n*a+s*m*a+o*n*u-s*h*u)*g,t[4]=z*g,t[5]=(l*y*r-x*m*r+x*n*u-e*y*u-l*n*p+e*m*p)*g,t[6]=(x*h*r-i*y*r-x*n*a+e*y*a+i*n*p-e*h*p)*g,t[7]=(i*m*r-l*h*r+l*n*a-e*m*a-i*n*u+e*h*u)*g,t[8]=k*g,t[9]=(x*c*r-l*M*r-x*s*u+e*M*u+l*s*p-e*c*p)*g,t[10]=(i*M*r-x*o*r+x*s*a-e*M*a-i*s*p+e*o*p)*g,t[11]=(l*o*r-i*c*r-l*s*a+e*c*a+i*s*u-e*o*u)*g,t[12]=w*g,t[13]=(l*M*n-x*c*n+x*s*m-e*M*m-l*s*y+e*c*y)*g,t[14]=(x*o*n-i*M*n-x*s*h+e*M*h+i*s*y-e*o*y)*g,t[15]=(i*c*n-l*o*n+l*s*h-e*c*h-i*s*m+e*o*m)*g,this}scale(t){const e=this.elements,s=t.x,n=t.y,r=t.z;return e[0]*=s,e[4]*=n,e[8]*=r,e[1]*=s,e[5]*=n,e[9]*=r,e[2]*=s,e[6]*=n,e[10]*=r,e[3]*=s,e[7]*=n,e[11]*=r,this}getMaxScaleOnAxis(){const t=this.elements,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],s=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],n=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,s,n))}makeTranslation(t,e,s){return this.set(1,0,0,t,0,1,0,e,0,0,1,s,0,0,0,1),this}makeRotationX(t){const e=Math.cos(t),s=Math.sin(t);return this.set(1,0,0,0,0,e,-s,0,0,s,e,0,0,0,0,1),this}makeRotationY(t){const e=Math.cos(t),s=Math.sin(t);return this.set(e,0,s,0,0,1,0,0,-s,0,e,0,0,0,0,1),this}makeRotationZ(t){const e=Math.cos(t),s=Math.sin(t);return this.set(e,-s,0,0,s,e,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,e){const s=Math.cos(e),n=Math.sin(e),r=1-s,i=t.x,o=t.y,h=t.z,a=r*i,l=r*o;return this.set(a*i+s,a*o-n*h,a*h+n*o,0,a*o+n*h,l*o+s,l*h-n*i,0,a*h-n*o,l*h+n*i,r*h*h+s,0,0,0,0,1),this}makeScale(t,e,s){return this.set(t,0,0,0,0,e,0,0,0,0,s,0,0,0,0,1),this}makeShear(t,e,s,n,r,i){return this.set(1,s,r,0,t,1,i,0,e,n,1,0,0,0,0,1),this}compose(t,e,s){const n=this.elements,r=e._x,i=e._y,o=e._z,h=e._w,a=r+r,l=i+i,c=o+o,m=r*a,u=r*l,x=r*c,M=i*l,y=i*c,p=o*c,d=h*a,z=h*l,k=h*c,w=s.x,f=s.y,g=s.z;return n[0]=(1-(M+p))*w,n[1]=(u+k)*w,n[2]=(x-z)*w,n[3]=0,n[4]=(u-k)*f,n[5]=(1-(m+p))*f,n[6]=(y+d)*f,n[7]=0,n[8]=(x+z)*g,n[9]=(y-d)*g,n[10]=(1-(m+M))*g,n[11]=0,n[12]=t.x,n[13]=t.y,n[14]=t.z,n[15]=1,this}decompose(t,e,s){const n=this.elements;let r=i.set(n[0],n[1],n[2]).length();const h=i.set(n[4],n[5],n[6]).length(),a=i.set(n[8],n[9],n[10]).length();this.determinant()<0&&(r=-r),t.x=n[12],t.y=n[13],t.z=n[14],o.copy(this);const l=1/r,c=1/h,m=1/a;return o.elements[0]*=l,o.elements[1]*=l,o.elements[2]*=l,o.elements[4]*=c,o.elements[5]*=c,o.elements[6]*=c,o.elements[8]*=m,o.elements[9]*=m,o.elements[10]*=m,e.setFromRotationMatrix(o),s.x=r,s.y=h,s.z=a,this}makePerspective(t,e,s,n,r,i){void 0===i&&console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");const o=this.elements,h=2*r/(e-t),a=2*r/(s-n),l=(e+t)/(e-t),c=(s+n)/(s-n),m=-(i+r)/(i-r),u=-2*i*r/(i-r);return o[0]=h,o[4]=0,o[8]=l,o[12]=0,o[1]=0,o[5]=a,o[9]=c,o[13]=0,o[2]=0,o[6]=0,o[10]=m,o[14]=u,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(t,e,s,n,r,i){const o=this.elements,h=1/(e-t),a=1/(s-n),l=1/(i-r),c=(e+t)*h,m=(s+n)*a,u=(i+r)*l;return o[0]=2*h,o[4]=0,o[8]=0,o[12]=-c,o[1]=0,o[5]=2*a,o[9]=0,o[13]=-m,o[2]=0,o[6]=0,o[10]=-2*l,o[14]=-u,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(t){const e=this.elements,s=t.elements;for(let t=0;t<16;t++)if(e[t]!==s[t])return!1;return!0}fromArray(t,e=0){for(let s=0;s<16;s++)this.elements[s]=t[s+e];return this}toArray(t=[],e=0){const s=this.elements;return t[e]=s[0],t[e+1]=s[1],t[e+2]=s[2],t[e+3]=s[3],t[e+4]=s[4],t[e+5]=s[5],t[e+6]=s[6],t[e+7]=s[7],t[e+8]=s[8],t[e+9]=s[9],t[e+10]=s[10],t[e+11]=s[11],t[e+12]=s[12],t[e+13]=s[13],t[e+14]=s[14],t[e+15]=s[15],t}}r.prototype.isMatrix4=!0;const i=new n.Vector3,o=new r,h=new n.Vector3(0,0,0),a=new n.Vector3(1,1,1),l=new n.Vector3,c=new n.Vector3,m=new n.Vector3}}]);