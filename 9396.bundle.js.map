{"version":3,"file":"9396.bundle.js","mappings":"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","sources":["webpack://joyride/./node_modules/three/src/cameras/PerspectiveCamera.js","webpack://joyride/./node_modules/three/src/lights/PointLightShadow.js","webpack://joyride/./node_modules/three/src/lights/PointLight.js"],"sourcesContent":["import { Camera } from './Camera.js';\nimport * as MathUtils from '../math/MathUtils.js';\n\nclass PerspectiveCamera extends Camera {\n\n\tconstructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'PerspectiveCamera';\n\n\t\tthis.fov = fov;\n\t\tthis.zoom = 1;\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\t\tthis.focus = 10;\n\n\t\tthis.aspect = aspect;\n\t\tthis.view = null;\n\n\t\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\t\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.fov = source.fov;\n\t\tthis.zoom = source.zoom;\n\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\t\tthis.focus = source.focus;\n\n\t\tthis.aspect = source.aspect;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\tthis.filmGauge = source.filmGauge;\n\t\tthis.filmOffset = source.filmOffset;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t *\n\t * The default film gauge is 35, so that the focal length can be specified for\n\t * a 35mm (full frame) camera.\n\t *\n\t * Values for focal length and film gauge must have the same unit.\n\t */\n\tsetFocalLength( focalLength ) {\n\n\t\t/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\n\t\tconst vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\n\t\tthis.fov = MathUtils.RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\t/**\n\t * Calculates the focal length from the current .fov and .filmGauge.\n\t */\n\tgetFocalLength() {\n\n\t\tconst vExtentSlope = Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov );\n\n\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\n\t}\n\n\tgetEffectiveFOV() {\n\n\t\treturn MathUtils.RAD2DEG * 2 * Math.atan(\n\t\t\tMath.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\n\t}\n\n\tgetFilmWidth() {\n\n\t\t// film not completely covered in portrait format (aspect < 1)\n\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\n\t}\n\n\tgetFilmHeight() {\n\n\t\t// film not completely covered in landscape format (aspect > 1)\n\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\n\t}\n\n\t/**\n\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t * multi-monitor/multi-machine setups.\n\t *\n\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t * the monitors are in grid like this\n\t *\n\t *   +---+---+---+\n\t *   | A | B | C |\n\t *   +---+---+---+\n\t *   | D | E | F |\n\t *   +---+---+---+\n\t *\n\t * then for each monitor you would call it like this\n\t *\n\t *   const w = 1920;\n\t *   const h = 1080;\n\t *   const fullWidth = w * 3;\n\t *   const fullHeight = h * 2;\n\t *\n\t *   --A--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t *   --B--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t *   --C--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t *   --D--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t *   --E--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t *   --F--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t *\n\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t */\n\tsetViewOffset( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\tif ( this.view === null ) {\n\n\t\t\tthis.view = {\n\t\t\t\tenabled: true,\n\t\t\t\tfullWidth: 1,\n\t\t\t\tfullHeight: 1,\n\t\t\t\toffsetX: 0,\n\t\t\t\toffsetY: 0,\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1\n\t\t\t};\n\n\t\t}\n\n\t\tthis.view.enabled = true;\n\t\tthis.view.fullWidth = fullWidth;\n\t\tthis.view.fullHeight = fullHeight;\n\t\tthis.view.offsetX = x;\n\t\tthis.view.offsetY = y;\n\t\tthis.view.width = width;\n\t\tthis.view.height = height;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tclearViewOffset() {\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tthis.view.enabled = false;\n\n\t\t}\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tupdateProjectionMatrix() {\n\n\t\tconst near = this.near;\n\t\tlet top = near * Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom;\n\t\tlet height = 2 * top;\n\t\tlet width = this.aspect * height;\n\t\tlet left = - 0.5 * width;\n\t\tconst view = this.view;\n\n\t\tif ( this.view !== null && this.view.enabled ) {\n\n\t\t\tconst fullWidth = view.fullWidth,\n\t\t\t\tfullHeight = view.fullHeight;\n\n\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\twidth *= view.width / fullWidth;\n\t\t\theight *= view.height / fullHeight;\n\n\t\t}\n\n\t\tconst skew = this.filmOffset;\n\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\n\t\tthis.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );\n\n\t\tthis.projectionMatrixInverse.copy( this.projectionMatrix ).invert();\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.fov = this.fov;\n\t\tdata.object.zoom = this.zoom;\n\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\t\tdata.object.focus = this.focus;\n\n\t\tdata.object.aspect = this.aspect;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\tdata.object.filmGauge = this.filmGauge;\n\t\tdata.object.filmOffset = this.filmOffset;\n\n\t\treturn data;\n\n\t}\n\n}\n\nPerspectiveCamera.prototype.isPerspectiveCamera = true;\n\nexport { PerspectiveCamera };\n","import { LightShadow } from './LightShadow.js';\nimport { PerspectiveCamera } from '../cameras/PerspectiveCamera.js';\nimport { Matrix4 } from '../math/Matrix4.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector4 } from '../math/Vector4.js';\n\nconst _projScreenMatrix = /*@__PURE__*/ new Matrix4();\nconst _lightPositionWorld = /*@__PURE__*/ new Vector3();\nconst _lookTarget = /*@__PURE__*/ new Vector3();\n\nclass PointLightShadow extends LightShadow {\n\n\tconstructor() {\n\n\t\tsuper( new PerspectiveCamera( 90, 1, 0.5, 500 ) );\n\n\t\tthis._frameExtents = new Vector2( 4, 2 );\n\n\t\tthis._viewportCount = 6;\n\n\t\tthis._viewports = [\n\t\t\t// These viewports map a cube-map onto a 2D texture with the\n\t\t\t// following orientation:\n\t\t\t//\n\t\t\t//  xzXZ\n\t\t\t//   y Y\n\t\t\t//\n\t\t\t// X - Positive x direction\n\t\t\t// x - Negative x direction\n\t\t\t// Y - Positive y direction\n\t\t\t// y - Negative y direction\n\t\t\t// Z - Positive z direction\n\t\t\t// z - Negative z direction\n\n\t\t\t// positive X\n\t\t\tnew Vector4( 2, 1, 1, 1 ),\n\t\t\t// negative X\n\t\t\tnew Vector4( 0, 1, 1, 1 ),\n\t\t\t// positive Z\n\t\t\tnew Vector4( 3, 1, 1, 1 ),\n\t\t\t// negative Z\n\t\t\tnew Vector4( 1, 1, 1, 1 ),\n\t\t\t// positive Y\n\t\t\tnew Vector4( 3, 0, 1, 1 ),\n\t\t\t// negative Y\n\t\t\tnew Vector4( 1, 0, 1, 1 )\n\t\t];\n\n\t\tthis._cubeDirections = [\n\t\t\tnew Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),\n\t\t\tnew Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )\n\t\t];\n\n\t\tthis._cubeUps = [\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),\n\t\t\tnew Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),\tnew Vector3( 0, 0, - 1 )\n\t\t];\n\n\t}\n\n\tupdateMatrices( light, viewportIndex = 0 ) {\n\n\t\tconst camera = this.camera;\n\t\tconst shadowMatrix = this.matrix;\n\n\t\tconst far = light.distance || camera.far;\n\n\t\tif ( far !== camera.far ) {\n\n\t\t\tcamera.far = far;\n\t\t\tcamera.updateProjectionMatrix();\n\n\t\t}\n\n\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\n\t\tcamera.position.copy( _lightPositionWorld );\n\n\t\t_lookTarget.copy( camera.position );\n\t\t_lookTarget.add( this._cubeDirections[ viewportIndex ] );\n\t\tcamera.up.copy( this._cubeUps[ viewportIndex ] );\n\t\tcamera.lookAt( _lookTarget );\n\t\tcamera.updateMatrixWorld();\n\n\t\tshadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );\n\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\n\t\tthis._frustum.setFromProjectionMatrix( _projScreenMatrix );\n\n\t}\n\n}\n\nPointLightShadow.prototype.isPointLightShadow = true;\n\nexport { PointLightShadow };\n","import { Light } from './Light.js';\nimport { PointLightShadow } from './PointLightShadow.js';\n\nclass PointLight extends Light {\n\n\tconstructor( color, intensity, distance = 0, decay = 1 ) {\n\n\t\tsuper( color, intensity );\n\n\t\tthis.type = 'PointLight';\n\n\t\tthis.distance = distance;\n\t\tthis.decay = decay; // for physically correct lights, should be 2.\n\n\t\tthis.shadow = new PointLightShadow();\n\n\t}\n\n\tget power() {\n\n\t\t// compute the light's luminous power (in lumens) from its intensity (in candela)\n\t\t// for an isotropic light source, luminous power (lm) = 4 Ï€ luminous intensity (cd)\n\t\treturn this.intensity * 4 * Math.PI;\n\n\t}\n\n\tset power( power ) {\n\n\t\t// set the light's intensity (in candela) from the desired luminous power (in lumens)\n\t\tthis.intensity = power / ( 4 * Math.PI );\n\n\t}\n\n\tdispose() {\n\n\t\tthis.shadow.dispose();\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.distance = source.distance;\n\t\tthis.decay = source.decay;\n\n\t\tthis.shadow = source.shadow.clone();\n\n\t\treturn this;\n\n\t}\n\n}\n\nPointLight.prototype.isPointLight = true;\n\nexport { PointLight };\n"],"names":["PerspectiveCamera","constructor","fov","aspect","near","far","super","this","type","zoom","focus","view","filmGauge","filmOffset","updateProjectionMatrix","copy","source","recursive","Object","assign","setFocalLength","focalLength","vExtentSlope","getFilmHeight","Math","atan","getFocalLength","tan","getEffectiveFOV","getFilmWidth","min","max","setViewOffset","fullWidth","fullHeight","x","y","width","height","enabled","offsetX","offsetY","clearViewOffset","top","left","skew","projectionMatrix","makePerspective","projectionMatrixInverse","invert","toJSON","meta","data","object","prototype","isPerspectiveCamera","_projScreenMatrix","Matrix4","_lightPositionWorld","Vector3","_lookTarget","PointLightShadow","LightShadow","_frameExtents","Vector2","_viewportCount","_viewports","Vector4","_cubeDirections","_cubeUps","updateMatrices","light","viewportIndex","camera","shadowMatrix","matrix","distance","setFromMatrixPosition","matrixWorld","position","add","up","lookAt","updateMatrixWorld","makeTranslation","z","multiplyMatrices","matrixWorldInverse","_frustum","setFromProjectionMatrix","isPointLightShadow","PointLight","Light","color","intensity","decay","shadow","power","PI","dispose","clone","isPointLight"],"sourceRoot":""}