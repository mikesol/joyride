{"version":3,"file":"2096.bundle.js","mappings":"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","sources":["webpack://joyride/./node_modules/three/src/cameras/Camera.js","webpack://joyride/./node_modules/three/src/cameras/PerspectiveCamera.js"],"sourcesContent":["import { Matrix4 } from '../math/Matrix4.js';\nimport { Object3D } from '../core/Object3D.js';\n\nclass Camera extends Object3D {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'Camera';\n\n\t\tthis.matrixWorldInverse = new Matrix4();\n\n\t\tthis.projectionMatrix = new Matrix4();\n\t\tthis.projectionMatrixInverse = new Matrix4();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\n\n\t\tthis.projectionMatrix.copy( source.projectionMatrix );\n\t\tthis.projectionMatrixInverse.copy( source.projectionMatrixInverse );\n\n\t\treturn this;\n\n\t}\n\n\tgetWorldDirection( target ) {\n\n\t\tthis.updateWorldMatrix( true, false );\n\n\t\tconst e = this.matrixWorld.elements;\n\n\t\treturn target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();\n\n\t}\n\n\tupdateMatrixWorld( force ) {\n\n\t\tsuper.updateMatrixWorld( force );\n\n\t\tthis.matrixWorldInverse.copy( this.matrixWorld ).invert();\n\n\t}\n\n\tupdateWorldMatrix( updateParents, updateChildren ) {\n\n\t\tsuper.updateWorldMatrix( updateParents, updateChildren );\n\n\t\tthis.matrixWorldInverse.copy( this.matrixWorld ).invert();\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n}\n\nCamera.prototype.isCamera = true;\n\nexport { Camera };\n","import { Camera } from './Camera.js';\nimport * as MathUtils from '../math/MathUtils.js';\n\nclass PerspectiveCamera extends Camera {\n\n\tconstructor( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'PerspectiveCamera';\n\n\t\tthis.fov = fov;\n\t\tthis.zoom = 1;\n\n\t\tthis.near = near;\n\t\tthis.far = far;\n\t\tthis.focus = 10;\n\n\t\tthis.aspect = aspect;\n\t\tthis.view = null;\n\n\t\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\n\t\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tcopy( source, recursive ) {\n\n\t\tsuper.copy( source, recursive );\n\n\t\tthis.fov = source.fov;\n\t\tthis.zoom = source.zoom;\n\n\t\tthis.near = source.near;\n\t\tthis.far = source.far;\n\t\tthis.focus = source.focus;\n\n\t\tthis.aspect = source.aspect;\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\n\n\t\tthis.filmGauge = source.filmGauge;\n\t\tthis.filmOffset = source.filmOffset;\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * Sets the FOV by focal length in respect to the current .filmGauge.\n\t *\n\t * The default film gauge is 35, so that the focal length can be specified for\n\t * a 35mm (full frame) camera.\n\t *\n\t * Values for focal length and film gauge must have the same unit.\n\t */\n\tsetFocalLength( focalLength ) {\n\n\t\t/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */\n\t\tconst vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\n\n\t\tthis.fov = MathUtils.RAD2DEG * 2 * Math.atan( vExtentSlope );\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\t/**\n\t * Calculates the focal length from the current .fov and .filmGauge.\n\t */\n\tgetFocalLength() {\n\n\t\tconst vExtentSlope = Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov );\n\n\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\n\n\t}\n\n\tgetEffectiveFOV() {\n\n\t\treturn MathUtils.RAD2DEG * 2 * Math.atan(\n\t\t\tMath.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom );\n\n\t}\n\n\tgetFilmWidth() {\n\n\t\t// film not completely covered in portrait format (aspect < 1)\n\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\n\n\t}\n\n\tgetFilmHeight() {\n\n\t\t// film not completely covered in landscape format (aspect > 1)\n\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\n\n\t}\n\n\t/**\n\t * Sets an offset in a larger frustum. This is useful for multi-window or\n\t * multi-monitor/multi-machine setups.\n\t *\n\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\n\t * the monitors are in grid like this\n\t *\n\t *   +---+---+---+\n\t *   | A | B | C |\n\t *   +---+---+---+\n\t *   | D | E | F |\n\t *   +---+---+---+\n\t *\n\t * then for each monitor you would call it like this\n\t *\n\t *   const w = 1920;\n\t *   const h = 1080;\n\t *   const fullWidth = w * 3;\n\t *   const fullHeight = h * 2;\n\t *\n\t *   --A--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\n\t *   --B--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\n\t *   --C--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\n\t *   --D--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\n\t *   --E--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\n\t *   --F--\n\t *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\n\t *\n\t *   Note there is no reason monitors have to be the same size or in a grid.\n\t */\n\tsetViewOffset( fullWidth, fullHeight, x, y, width, height ) {\n\n\t\tthis.aspect = fullWidth / fullHeight;\n\n\t\tif ( this.view === null ) {\n\n\t\t\tthis.view = {\n\t\t\t\tenabled: true,\n\t\t\t\tfullWidth: 1,\n\t\t\t\tfullHeight: 1,\n\t\t\t\toffsetX: 0,\n\t\t\t\toffsetY: 0,\n\t\t\t\twidth: 1,\n\t\t\t\theight: 1\n\t\t\t};\n\n\t\t}\n\n\t\tthis.view.enabled = true;\n\t\tthis.view.fullWidth = fullWidth;\n\t\tthis.view.fullHeight = fullHeight;\n\t\tthis.view.offsetX = x;\n\t\tthis.view.offsetY = y;\n\t\tthis.view.width = width;\n\t\tthis.view.height = height;\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tclearViewOffset() {\n\n\t\tif ( this.view !== null ) {\n\n\t\t\tthis.view.enabled = false;\n\n\t\t}\n\n\t\tthis.updateProjectionMatrix();\n\n\t}\n\n\tupdateProjectionMatrix() {\n\n\t\tconst near = this.near;\n\t\tlet top = near * Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom;\n\t\tlet height = 2 * top;\n\t\tlet width = this.aspect * height;\n\t\tlet left = - 0.5 * width;\n\t\tconst view = this.view;\n\n\t\tif ( this.view !== null && this.view.enabled ) {\n\n\t\t\tconst fullWidth = view.fullWidth,\n\t\t\t\tfullHeight = view.fullHeight;\n\n\t\t\tleft += view.offsetX * width / fullWidth;\n\t\t\ttop -= view.offsetY * height / fullHeight;\n\t\t\twidth *= view.width / fullWidth;\n\t\t\theight *= view.height / fullHeight;\n\n\t\t}\n\n\t\tconst skew = this.filmOffset;\n\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\n\n\t\tthis.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );\n\n\t\tthis.projectionMatrixInverse.copy( this.projectionMatrix ).invert();\n\n\t}\n\n\ttoJSON( meta ) {\n\n\t\tconst data = super.toJSON( meta );\n\n\t\tdata.object.fov = this.fov;\n\t\tdata.object.zoom = this.zoom;\n\n\t\tdata.object.near = this.near;\n\t\tdata.object.far = this.far;\n\t\tdata.object.focus = this.focus;\n\n\t\tdata.object.aspect = this.aspect;\n\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\n\n\t\tdata.object.filmGauge = this.filmGauge;\n\t\tdata.object.filmOffset = this.filmOffset;\n\n\t\treturn data;\n\n\t}\n\n}\n\nPerspectiveCamera.prototype.isPerspectiveCamera = true;\n\nexport { PerspectiveCamera };\n"],"names":["Camera","constructor","super","this","type","matrixWorldInverse","Matrix4","projectionMatrix","projectionMatrixInverse","copy","source","recursive","getWorldDirection","target","updateWorldMatrix","e","matrixWorld","elements","set","normalize","updateMatrixWorld","force","invert","updateParents","updateChildren","clone","prototype","isCamera","PerspectiveCamera","fov","aspect","near","far","zoom","focus","view","filmGauge","filmOffset","updateProjectionMatrix","Object","assign","setFocalLength","focalLength","vExtentSlope","getFilmHeight","Math","atan","getFocalLength","tan","getEffectiveFOV","getFilmWidth","min","max","setViewOffset","fullWidth","fullHeight","x","y","width","height","enabled","offsetX","offsetY","clearViewOffset","top","left","skew","makePerspective","toJSON","meta","data","object","isPerspectiveCamera"],"sourceRoot":""}