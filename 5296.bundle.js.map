{"version":3,"file":"5296.bundle.js","mappings":"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","sources":["webpack://joyride/./node_modules/@firebase/installations/dist/esm/index.esm2017.js","webpack://joyride/./node_modules/@firebase/analytics/dist/esm/index.esm2017.js"],"sourcesContent":["import { getApp, _getProvider, _registerComponent, registerVersion } from '@firebase/app';\nimport { Component } from '@firebase/component';\nimport { ErrorFactory, FirebaseError } from '@firebase/util';\nimport { openDB } from 'idb';\n\nconst name = \"@firebase/installations\";\nconst version = \"0.5.10\";\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst PENDING_TIMEOUT_MS = 10000;\r\nconst PACKAGE_VERSION = `w:${version}`;\r\nconst INTERNAL_AUTH_VERSION = 'FIS_v2';\r\nconst INSTALLATIONS_API_URL = 'https://firebaseinstallations.googleapis.com/v1';\r\nconst TOKEN_EXPIRATION_BUFFER = 60 * 60 * 1000; // One hour\r\nconst SERVICE = 'installations';\r\nconst SERVICE_NAME = 'Installations';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst ERROR_DESCRIPTION_MAP = {\r\n    [\"missing-app-config-values\" /* MISSING_APP_CONFIG_VALUES */]: 'Missing App configuration value: \"{$valueName}\"',\r\n    [\"not-registered\" /* NOT_REGISTERED */]: 'Firebase Installation is not registered.',\r\n    [\"installation-not-found\" /* INSTALLATION_NOT_FOUND */]: 'Firebase Installation not found.',\r\n    [\"request-failed\" /* REQUEST_FAILED */]: '{$requestName} request failed with error \"{$serverCode} {$serverStatus}: {$serverMessage}\"',\r\n    [\"app-offline\" /* APP_OFFLINE */]: 'Could not process request. Application offline.',\r\n    [\"delete-pending-registration\" /* DELETE_PENDING_REGISTRATION */]: \"Can't delete installation while there is a pending registration request.\"\r\n};\r\nconst ERROR_FACTORY = new ErrorFactory(SERVICE, SERVICE_NAME, ERROR_DESCRIPTION_MAP);\r\n/** Returns true if error is a FirebaseError that is based on an error from the server. */\r\nfunction isServerError(error) {\r\n    return (error instanceof FirebaseError &&\r\n        error.code.includes(\"request-failed\" /* REQUEST_FAILED */));\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction getInstallationsEndpoint({ projectId }) {\r\n    return `${INSTALLATIONS_API_URL}/projects/${projectId}/installations`;\r\n}\r\nfunction extractAuthTokenInfoFromResponse(response) {\r\n    return {\r\n        token: response.token,\r\n        requestStatus: 2 /* COMPLETED */,\r\n        expiresIn: getExpiresInFromResponseExpiresIn(response.expiresIn),\r\n        creationTime: Date.now()\r\n    };\r\n}\r\nasync function getErrorFromResponse(requestName, response) {\r\n    const responseJson = await response.json();\r\n    const errorData = responseJson.error;\r\n    return ERROR_FACTORY.create(\"request-failed\" /* REQUEST_FAILED */, {\r\n        requestName,\r\n        serverCode: errorData.code,\r\n        serverMessage: errorData.message,\r\n        serverStatus: errorData.status\r\n    });\r\n}\r\nfunction getHeaders({ apiKey }) {\r\n    return new Headers({\r\n        'Content-Type': 'application/json',\r\n        Accept: 'application/json',\r\n        'x-goog-api-key': apiKey\r\n    });\r\n}\r\nfunction getHeadersWithAuth(appConfig, { refreshToken }) {\r\n    const headers = getHeaders(appConfig);\r\n    headers.append('Authorization', getAuthorizationHeader(refreshToken));\r\n    return headers;\r\n}\r\n/**\r\n * Calls the passed in fetch wrapper and returns the response.\r\n * If the returned response has a status of 5xx, re-runs the function once and\r\n * returns the response.\r\n */\r\nasync function retryIfServerError(fn) {\r\n    const result = await fn();\r\n    if (result.status >= 500 && result.status < 600) {\r\n        // Internal Server Error. Retry request.\r\n        return fn();\r\n    }\r\n    return result;\r\n}\r\nfunction getExpiresInFromResponseExpiresIn(responseExpiresIn) {\r\n    // This works because the server will never respond with fractions of a second.\r\n    return Number(responseExpiresIn.replace('s', '000'));\r\n}\r\nfunction getAuthorizationHeader(refreshToken) {\r\n    return `${INTERNAL_AUTH_VERSION} ${refreshToken}`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function createInstallationRequest({ appConfig, heartbeatServiceProvider }, { fid }) {\r\n    const endpoint = getInstallationsEndpoint(appConfig);\r\n    const headers = getHeaders(appConfig);\r\n    // If heartbeat service exists, add the heartbeat string to the header.\r\n    const heartbeatService = heartbeatServiceProvider.getImmediate({\r\n        optional: true\r\n    });\r\n    if (heartbeatService) {\r\n        const heartbeatsHeader = await heartbeatService.getHeartbeatsHeader();\r\n        if (heartbeatsHeader) {\r\n            headers.append('x-firebase-client', heartbeatsHeader);\r\n        }\r\n    }\r\n    const body = {\r\n        fid,\r\n        authVersion: INTERNAL_AUTH_VERSION,\r\n        appId: appConfig.appId,\r\n        sdkVersion: PACKAGE_VERSION\r\n    };\r\n    const request = {\r\n        method: 'POST',\r\n        headers,\r\n        body: JSON.stringify(body)\r\n    };\r\n    const response = await retryIfServerError(() => fetch(endpoint, request));\r\n    if (response.ok) {\r\n        const responseValue = await response.json();\r\n        const registeredInstallationEntry = {\r\n            fid: responseValue.fid || fid,\r\n            registrationStatus: 2 /* COMPLETED */,\r\n            refreshToken: responseValue.refreshToken,\r\n            authToken: extractAuthTokenInfoFromResponse(responseValue.authToken)\r\n        };\r\n        return registeredInstallationEntry;\r\n    }\r\n    else {\r\n        throw await getErrorFromResponse('Create Installation', response);\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Returns a promise that resolves after given time passes. */\r\nfunction sleep(ms) {\r\n    return new Promise(resolve => {\r\n        setTimeout(resolve, ms);\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction bufferToBase64UrlSafe(array) {\r\n    const b64 = btoa(String.fromCharCode(...array));\r\n    return b64.replace(/\\+/g, '-').replace(/\\//g, '_');\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst VALID_FID_PATTERN = /^[cdef][\\w-]{21}$/;\r\nconst INVALID_FID = '';\r\n/**\r\n * Generates a new FID using random values from Web Crypto API.\r\n * Returns an empty string if FID generation fails for any reason.\r\n */\r\nfunction generateFid() {\r\n    try {\r\n        // A valid FID has exactly 22 base64 characters, which is 132 bits, or 16.5\r\n        // bytes. our implementation generates a 17 byte array instead.\r\n        const fidByteArray = new Uint8Array(17);\r\n        const crypto = self.crypto || self.msCrypto;\r\n        crypto.getRandomValues(fidByteArray);\r\n        // Replace the first 4 random bits with the constant FID header of 0b0111.\r\n        fidByteArray[0] = 0b01110000 + (fidByteArray[0] % 0b00010000);\r\n        const fid = encode(fidByteArray);\r\n        return VALID_FID_PATTERN.test(fid) ? fid : INVALID_FID;\r\n    }\r\n    catch (_a) {\r\n        // FID generation errored\r\n        return INVALID_FID;\r\n    }\r\n}\r\n/** Converts a FID Uint8Array to a base64 string representation. */\r\nfunction encode(fidByteArray) {\r\n    const b64String = bufferToBase64UrlSafe(fidByteArray);\r\n    // Remove the 23rd character that was added because of the extra 4 bits at the\r\n    // end of our 17 byte array, and the '=' padding.\r\n    return b64String.substr(0, 22);\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/** Returns a string key that can be used to identify the app. */\r\nfunction getKey(appConfig) {\r\n    return `${appConfig.appName}!${appConfig.appId}`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst fidChangeCallbacks = new Map();\r\n/**\r\n * Calls the onIdChange callbacks with the new FID value, and broadcasts the\r\n * change to other tabs.\r\n */\r\nfunction fidChanged(appConfig, fid) {\r\n    const key = getKey(appConfig);\r\n    callFidChangeCallbacks(key, fid);\r\n    broadcastFidChange(key, fid);\r\n}\r\nfunction addCallback(appConfig, callback) {\r\n    // Open the broadcast channel if it's not already open,\r\n    // to be able to listen to change events from other tabs.\r\n    getBroadcastChannel();\r\n    const key = getKey(appConfig);\r\n    let callbackSet = fidChangeCallbacks.get(key);\r\n    if (!callbackSet) {\r\n        callbackSet = new Set();\r\n        fidChangeCallbacks.set(key, callbackSet);\r\n    }\r\n    callbackSet.add(callback);\r\n}\r\nfunction removeCallback(appConfig, callback) {\r\n    const key = getKey(appConfig);\r\n    const callbackSet = fidChangeCallbacks.get(key);\r\n    if (!callbackSet) {\r\n        return;\r\n    }\r\n    callbackSet.delete(callback);\r\n    if (callbackSet.size === 0) {\r\n        fidChangeCallbacks.delete(key);\r\n    }\r\n    // Close broadcast channel if there are no more callbacks.\r\n    closeBroadcastChannel();\r\n}\r\nfunction callFidChangeCallbacks(key, fid) {\r\n    const callbacks = fidChangeCallbacks.get(key);\r\n    if (!callbacks) {\r\n        return;\r\n    }\r\n    for (const callback of callbacks) {\r\n        callback(fid);\r\n    }\r\n}\r\nfunction broadcastFidChange(key, fid) {\r\n    const channel = getBroadcastChannel();\r\n    if (channel) {\r\n        channel.postMessage({ key, fid });\r\n    }\r\n    closeBroadcastChannel();\r\n}\r\nlet broadcastChannel = null;\r\n/** Opens and returns a BroadcastChannel if it is supported by the browser. */\r\nfunction getBroadcastChannel() {\r\n    if (!broadcastChannel && 'BroadcastChannel' in self) {\r\n        broadcastChannel = new BroadcastChannel('[Firebase] FID Change');\r\n        broadcastChannel.onmessage = e => {\r\n            callFidChangeCallbacks(e.data.key, e.data.fid);\r\n        };\r\n    }\r\n    return broadcastChannel;\r\n}\r\nfunction closeBroadcastChannel() {\r\n    if (fidChangeCallbacks.size === 0 && broadcastChannel) {\r\n        broadcastChannel.close();\r\n        broadcastChannel = null;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst DATABASE_NAME = 'firebase-installations-database';\r\nconst DATABASE_VERSION = 1;\r\nconst OBJECT_STORE_NAME = 'firebase-installations-store';\r\nlet dbPromise = null;\r\nfunction getDbPromise() {\r\n    if (!dbPromise) {\r\n        dbPromise = openDB(DATABASE_NAME, DATABASE_VERSION, {\r\n            upgrade: (db, oldVersion) => {\r\n                // We don't use 'break' in this switch statement, the fall-through\r\n                // behavior is what we want, because if there are multiple versions between\r\n                // the old version and the current version, we want ALL the migrations\r\n                // that correspond to those versions to run, not only the last one.\r\n                // eslint-disable-next-line default-case\r\n                switch (oldVersion) {\r\n                    case 0:\r\n                        db.createObjectStore(OBJECT_STORE_NAME);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    return dbPromise;\r\n}\r\n/** Assigns or overwrites the record for the given key with the given value. */\r\nasync function set(appConfig, value) {\r\n    const key = getKey(appConfig);\r\n    const db = await getDbPromise();\r\n    const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\r\n    const objectStore = tx.objectStore(OBJECT_STORE_NAME);\r\n    const oldValue = (await objectStore.get(key));\r\n    await objectStore.put(value, key);\r\n    await tx.done;\r\n    if (!oldValue || oldValue.fid !== value.fid) {\r\n        fidChanged(appConfig, value.fid);\r\n    }\r\n    return value;\r\n}\r\n/** Removes record(s) from the objectStore that match the given key. */\r\nasync function remove(appConfig) {\r\n    const key = getKey(appConfig);\r\n    const db = await getDbPromise();\r\n    const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\r\n    await tx.objectStore(OBJECT_STORE_NAME).delete(key);\r\n    await tx.done;\r\n}\r\n/**\r\n * Atomically updates a record with the result of updateFn, which gets\r\n * called with the current value. If newValue is undefined, the record is\r\n * deleted instead.\r\n * @return Updated value\r\n */\r\nasync function update(appConfig, updateFn) {\r\n    const key = getKey(appConfig);\r\n    const db = await getDbPromise();\r\n    const tx = db.transaction(OBJECT_STORE_NAME, 'readwrite');\r\n    const store = tx.objectStore(OBJECT_STORE_NAME);\r\n    const oldValue = (await store.get(key));\r\n    const newValue = updateFn(oldValue);\r\n    if (newValue === undefined) {\r\n        await store.delete(key);\r\n    }\r\n    else {\r\n        await store.put(newValue, key);\r\n    }\r\n    await tx.done;\r\n    if (newValue && (!oldValue || oldValue.fid !== newValue.fid)) {\r\n        fidChanged(appConfig, newValue.fid);\r\n    }\r\n    return newValue;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Updates and returns the InstallationEntry from the database.\r\n * Also triggers a registration request if it is necessary and possible.\r\n */\r\nasync function getInstallationEntry(installations) {\r\n    let registrationPromise;\r\n    const installationEntry = await update(installations.appConfig, oldEntry => {\r\n        const installationEntry = updateOrCreateInstallationEntry(oldEntry);\r\n        const entryWithPromise = triggerRegistrationIfNecessary(installations, installationEntry);\r\n        registrationPromise = entryWithPromise.registrationPromise;\r\n        return entryWithPromise.installationEntry;\r\n    });\r\n    if (installationEntry.fid === INVALID_FID) {\r\n        // FID generation failed. Waiting for the FID from the server.\r\n        return { installationEntry: await registrationPromise };\r\n    }\r\n    return {\r\n        installationEntry,\r\n        registrationPromise\r\n    };\r\n}\r\n/**\r\n * Creates a new Installation Entry if one does not exist.\r\n * Also clears timed out pending requests.\r\n */\r\nfunction updateOrCreateInstallationEntry(oldEntry) {\r\n    const entry = oldEntry || {\r\n        fid: generateFid(),\r\n        registrationStatus: 0 /* NOT_STARTED */\r\n    };\r\n    return clearTimedOutRequest(entry);\r\n}\r\n/**\r\n * If the Firebase Installation is not registered yet, this will trigger the\r\n * registration and return an InProgressInstallationEntry.\r\n *\r\n * If registrationPromise does not exist, the installationEntry is guaranteed\r\n * to be registered.\r\n */\r\nfunction triggerRegistrationIfNecessary(installations, installationEntry) {\r\n    if (installationEntry.registrationStatus === 0 /* NOT_STARTED */) {\r\n        if (!navigator.onLine) {\r\n            // Registration required but app is offline.\r\n            const registrationPromiseWithError = Promise.reject(ERROR_FACTORY.create(\"app-offline\" /* APP_OFFLINE */));\r\n            return {\r\n                installationEntry,\r\n                registrationPromise: registrationPromiseWithError\r\n            };\r\n        }\r\n        // Try registering. Change status to IN_PROGRESS.\r\n        const inProgressEntry = {\r\n            fid: installationEntry.fid,\r\n            registrationStatus: 1 /* IN_PROGRESS */,\r\n            registrationTime: Date.now()\r\n        };\r\n        const registrationPromise = registerInstallation(installations, inProgressEntry);\r\n        return { installationEntry: inProgressEntry, registrationPromise };\r\n    }\r\n    else if (installationEntry.registrationStatus === 1 /* IN_PROGRESS */) {\r\n        return {\r\n            installationEntry,\r\n            registrationPromise: waitUntilFidRegistration(installations)\r\n        };\r\n    }\r\n    else {\r\n        return { installationEntry };\r\n    }\r\n}\r\n/** This will be executed only once for each new Firebase Installation. */\r\nasync function registerInstallation(installations, installationEntry) {\r\n    try {\r\n        const registeredInstallationEntry = await createInstallationRequest(installations, installationEntry);\r\n        return set(installations.appConfig, registeredInstallationEntry);\r\n    }\r\n    catch (e) {\r\n        if (isServerError(e) && e.customData.serverCode === 409) {\r\n            // Server returned a \"FID can not be used\" error.\r\n            // Generate a new ID next time.\r\n            await remove(installations.appConfig);\r\n        }\r\n        else {\r\n            // Registration failed. Set FID as not registered.\r\n            await set(installations.appConfig, {\r\n                fid: installationEntry.fid,\r\n                registrationStatus: 0 /* NOT_STARTED */\r\n            });\r\n        }\r\n        throw e;\r\n    }\r\n}\r\n/** Call if FID registration is pending in another request. */\r\nasync function waitUntilFidRegistration(installations) {\r\n    // Unfortunately, there is no way of reliably observing when a value in\r\n    // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),\r\n    // so we need to poll.\r\n    let entry = await updateInstallationRequest(installations.appConfig);\r\n    while (entry.registrationStatus === 1 /* IN_PROGRESS */) {\r\n        // createInstallation request still in progress.\r\n        await sleep(100);\r\n        entry = await updateInstallationRequest(installations.appConfig);\r\n    }\r\n    if (entry.registrationStatus === 0 /* NOT_STARTED */) {\r\n        // The request timed out or failed in a different call. Try again.\r\n        const { installationEntry, registrationPromise } = await getInstallationEntry(installations);\r\n        if (registrationPromise) {\r\n            return registrationPromise;\r\n        }\r\n        else {\r\n            // if there is no registrationPromise, entry is registered.\r\n            return installationEntry;\r\n        }\r\n    }\r\n    return entry;\r\n}\r\n/**\r\n * Called only if there is a CreateInstallation request in progress.\r\n *\r\n * Updates the InstallationEntry in the DB based on the status of the\r\n * CreateInstallation request.\r\n *\r\n * Returns the updated InstallationEntry.\r\n */\r\nfunction updateInstallationRequest(appConfig) {\r\n    return update(appConfig, oldEntry => {\r\n        if (!oldEntry) {\r\n            throw ERROR_FACTORY.create(\"installation-not-found\" /* INSTALLATION_NOT_FOUND */);\r\n        }\r\n        return clearTimedOutRequest(oldEntry);\r\n    });\r\n}\r\nfunction clearTimedOutRequest(entry) {\r\n    if (hasInstallationRequestTimedOut(entry)) {\r\n        return {\r\n            fid: entry.fid,\r\n            registrationStatus: 0 /* NOT_STARTED */\r\n        };\r\n    }\r\n    return entry;\r\n}\r\nfunction hasInstallationRequestTimedOut(installationEntry) {\r\n    return (installationEntry.registrationStatus === 1 /* IN_PROGRESS */ &&\r\n        installationEntry.registrationTime + PENDING_TIMEOUT_MS < Date.now());\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function generateAuthTokenRequest({ appConfig, heartbeatServiceProvider }, installationEntry) {\r\n    const endpoint = getGenerateAuthTokenEndpoint(appConfig, installationEntry);\r\n    const headers = getHeadersWithAuth(appConfig, installationEntry);\r\n    // If heartbeat service exists, add the heartbeat string to the header.\r\n    const heartbeatService = heartbeatServiceProvider.getImmediate({\r\n        optional: true\r\n    });\r\n    if (heartbeatService) {\r\n        const heartbeatsHeader = await heartbeatService.getHeartbeatsHeader();\r\n        if (heartbeatsHeader) {\r\n            headers.append('x-firebase-client', heartbeatsHeader);\r\n        }\r\n    }\r\n    const body = {\r\n        installation: {\r\n            sdkVersion: PACKAGE_VERSION,\r\n            appId: appConfig.appId\r\n        }\r\n    };\r\n    const request = {\r\n        method: 'POST',\r\n        headers,\r\n        body: JSON.stringify(body)\r\n    };\r\n    const response = await retryIfServerError(() => fetch(endpoint, request));\r\n    if (response.ok) {\r\n        const responseValue = await response.json();\r\n        const completedAuthToken = extractAuthTokenInfoFromResponse(responseValue);\r\n        return completedAuthToken;\r\n    }\r\n    else {\r\n        throw await getErrorFromResponse('Generate Auth Token', response);\r\n    }\r\n}\r\nfunction getGenerateAuthTokenEndpoint(appConfig, { fid }) {\r\n    return `${getInstallationsEndpoint(appConfig)}/${fid}/authTokens:generate`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns a valid authentication token for the installation. Generates a new\r\n * token if one doesn't exist, is expired or about to expire.\r\n *\r\n * Should only be called if the Firebase Installation is registered.\r\n */\r\nasync function refreshAuthToken(installations, forceRefresh = false) {\r\n    let tokenPromise;\r\n    const entry = await update(installations.appConfig, oldEntry => {\r\n        if (!isEntryRegistered(oldEntry)) {\r\n            throw ERROR_FACTORY.create(\"not-registered\" /* NOT_REGISTERED */);\r\n        }\r\n        const oldAuthToken = oldEntry.authToken;\r\n        if (!forceRefresh && isAuthTokenValid(oldAuthToken)) {\r\n            // There is a valid token in the DB.\r\n            return oldEntry;\r\n        }\r\n        else if (oldAuthToken.requestStatus === 1 /* IN_PROGRESS */) {\r\n            // There already is a token request in progress.\r\n            tokenPromise = waitUntilAuthTokenRequest(installations, forceRefresh);\r\n            return oldEntry;\r\n        }\r\n        else {\r\n            // No token or token expired.\r\n            if (!navigator.onLine) {\r\n                throw ERROR_FACTORY.create(\"app-offline\" /* APP_OFFLINE */);\r\n            }\r\n            const inProgressEntry = makeAuthTokenRequestInProgressEntry(oldEntry);\r\n            tokenPromise = fetchAuthTokenFromServer(installations, inProgressEntry);\r\n            return inProgressEntry;\r\n        }\r\n    });\r\n    const authToken = tokenPromise\r\n        ? await tokenPromise\r\n        : entry.authToken;\r\n    return authToken;\r\n}\r\n/**\r\n * Call only if FID is registered and Auth Token request is in progress.\r\n *\r\n * Waits until the current pending request finishes. If the request times out,\r\n * tries once in this thread as well.\r\n */\r\nasync function waitUntilAuthTokenRequest(installations, forceRefresh) {\r\n    // Unfortunately, there is no way of reliably observing when a value in\r\n    // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),\r\n    // so we need to poll.\r\n    let entry = await updateAuthTokenRequest(installations.appConfig);\r\n    while (entry.authToken.requestStatus === 1 /* IN_PROGRESS */) {\r\n        // generateAuthToken still in progress.\r\n        await sleep(100);\r\n        entry = await updateAuthTokenRequest(installations.appConfig);\r\n    }\r\n    const authToken = entry.authToken;\r\n    if (authToken.requestStatus === 0 /* NOT_STARTED */) {\r\n        // The request timed out or failed in a different call. Try again.\r\n        return refreshAuthToken(installations, forceRefresh);\r\n    }\r\n    else {\r\n        return authToken;\r\n    }\r\n}\r\n/**\r\n * Called only if there is a GenerateAuthToken request in progress.\r\n *\r\n * Updates the InstallationEntry in the DB based on the status of the\r\n * GenerateAuthToken request.\r\n *\r\n * Returns the updated InstallationEntry.\r\n */\r\nfunction updateAuthTokenRequest(appConfig) {\r\n    return update(appConfig, oldEntry => {\r\n        if (!isEntryRegistered(oldEntry)) {\r\n            throw ERROR_FACTORY.create(\"not-registered\" /* NOT_REGISTERED */);\r\n        }\r\n        const oldAuthToken = oldEntry.authToken;\r\n        if (hasAuthTokenRequestTimedOut(oldAuthToken)) {\r\n            return Object.assign(Object.assign({}, oldEntry), { authToken: { requestStatus: 0 /* NOT_STARTED */ } });\r\n        }\r\n        return oldEntry;\r\n    });\r\n}\r\nasync function fetchAuthTokenFromServer(installations, installationEntry) {\r\n    try {\r\n        const authToken = await generateAuthTokenRequest(installations, installationEntry);\r\n        const updatedInstallationEntry = Object.assign(Object.assign({}, installationEntry), { authToken });\r\n        await set(installations.appConfig, updatedInstallationEntry);\r\n        return authToken;\r\n    }\r\n    catch (e) {\r\n        if (isServerError(e) &&\r\n            (e.customData.serverCode === 401 || e.customData.serverCode === 404)) {\r\n            // Server returned a \"FID not found\" or a \"Invalid authentication\" error.\r\n            // Generate a new ID next time.\r\n            await remove(installations.appConfig);\r\n        }\r\n        else {\r\n            const updatedInstallationEntry = Object.assign(Object.assign({}, installationEntry), { authToken: { requestStatus: 0 /* NOT_STARTED */ } });\r\n            await set(installations.appConfig, updatedInstallationEntry);\r\n        }\r\n        throw e;\r\n    }\r\n}\r\nfunction isEntryRegistered(installationEntry) {\r\n    return (installationEntry !== undefined &&\r\n        installationEntry.registrationStatus === 2 /* COMPLETED */);\r\n}\r\nfunction isAuthTokenValid(authToken) {\r\n    return (authToken.requestStatus === 2 /* COMPLETED */ &&\r\n        !isAuthTokenExpired(authToken));\r\n}\r\nfunction isAuthTokenExpired(authToken) {\r\n    const now = Date.now();\r\n    return (now < authToken.creationTime ||\r\n        authToken.creationTime + authToken.expiresIn < now + TOKEN_EXPIRATION_BUFFER);\r\n}\r\n/** Returns an updated InstallationEntry with an InProgressAuthToken. */\r\nfunction makeAuthTokenRequestInProgressEntry(oldEntry) {\r\n    const inProgressAuthToken = {\r\n        requestStatus: 1 /* IN_PROGRESS */,\r\n        requestTime: Date.now()\r\n    };\r\n    return Object.assign(Object.assign({}, oldEntry), { authToken: inProgressAuthToken });\r\n}\r\nfunction hasAuthTokenRequestTimedOut(authToken) {\r\n    return (authToken.requestStatus === 1 /* IN_PROGRESS */ &&\r\n        authToken.requestTime + PENDING_TIMEOUT_MS < Date.now());\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Creates a Firebase Installation if there isn't one for the app and\r\n * returns the Installation ID.\r\n * @param installations - The `Installations` instance.\r\n *\r\n * @public\r\n */\r\nasync function getId(installations) {\r\n    const installationsImpl = installations;\r\n    const { installationEntry, registrationPromise } = await getInstallationEntry(installationsImpl);\r\n    if (registrationPromise) {\r\n        registrationPromise.catch(console.error);\r\n    }\r\n    else {\r\n        // If the installation is already registered, update the authentication\r\n        // token if needed.\r\n        refreshAuthToken(installationsImpl).catch(console.error);\r\n    }\r\n    return installationEntry.fid;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns a Firebase Installations auth token, identifying the current\r\n * Firebase Installation.\r\n * @param installations - The `Installations` instance.\r\n * @param forceRefresh - Force refresh regardless of token expiration.\r\n *\r\n * @public\r\n */\r\nasync function getToken(installations, forceRefresh = false) {\r\n    const installationsImpl = installations;\r\n    await completeInstallationRegistration(installationsImpl);\r\n    // At this point we either have a Registered Installation in the DB, or we've\r\n    // already thrown an error.\r\n    const authToken = await refreshAuthToken(installationsImpl, forceRefresh);\r\n    return authToken.token;\r\n}\r\nasync function completeInstallationRegistration(installations) {\r\n    const { registrationPromise } = await getInstallationEntry(installations);\r\n    if (registrationPromise) {\r\n        // A createInstallation request is in progress. Wait until it finishes.\r\n        await registrationPromise;\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function deleteInstallationRequest(appConfig, installationEntry) {\r\n    const endpoint = getDeleteEndpoint(appConfig, installationEntry);\r\n    const headers = getHeadersWithAuth(appConfig, installationEntry);\r\n    const request = {\r\n        method: 'DELETE',\r\n        headers\r\n    };\r\n    const response = await retryIfServerError(() => fetch(endpoint, request));\r\n    if (!response.ok) {\r\n        throw await getErrorFromResponse('Delete Installation', response);\r\n    }\r\n}\r\nfunction getDeleteEndpoint(appConfig, { fid }) {\r\n    return `${getInstallationsEndpoint(appConfig)}/${fid}`;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Deletes the Firebase Installation and all associated data.\r\n * @param installations - The `Installations` instance.\r\n *\r\n * @public\r\n */\r\nasync function deleteInstallations(installations) {\r\n    const { appConfig } = installations;\r\n    const entry = await update(appConfig, oldEntry => {\r\n        if (oldEntry && oldEntry.registrationStatus === 0 /* NOT_STARTED */) {\r\n            // Delete the unregistered entry without sending a deleteInstallation request.\r\n            return undefined;\r\n        }\r\n        return oldEntry;\r\n    });\r\n    if (entry) {\r\n        if (entry.registrationStatus === 1 /* IN_PROGRESS */) {\r\n            // Can't delete while trying to register.\r\n            throw ERROR_FACTORY.create(\"delete-pending-registration\" /* DELETE_PENDING_REGISTRATION */);\r\n        }\r\n        else if (entry.registrationStatus === 2 /* COMPLETED */) {\r\n            if (!navigator.onLine) {\r\n                throw ERROR_FACTORY.create(\"app-offline\" /* APP_OFFLINE */);\r\n            }\r\n            else {\r\n                await deleteInstallationRequest(appConfig, entry);\r\n                await remove(appConfig);\r\n            }\r\n        }\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Sets a new callback that will get called when Installation ID changes.\r\n * Returns an unsubscribe function that will remove the callback when called.\r\n * @param installations - The `Installations` instance.\r\n * @param callback - The callback function that is invoked when FID changes.\r\n * @returns A function that can be called to unsubscribe.\r\n *\r\n * @public\r\n */\r\nfunction onIdChange(installations, callback) {\r\n    const { appConfig } = installations;\r\n    addCallback(appConfig, callback);\r\n    return () => {\r\n        removeCallback(appConfig, callback);\r\n    };\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Returns an instance of {@link Installations} associated with the given\r\n * {@link @firebase/app#FirebaseApp} instance.\r\n * @param app - The {@link @firebase/app#FirebaseApp} instance.\r\n *\r\n * @public\r\n */\r\nfunction getInstallations(app = getApp()) {\r\n    const installationsImpl = _getProvider(app, 'installations').getImmediate();\r\n    return installationsImpl;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nfunction extractAppConfig(app) {\r\n    if (!app || !app.options) {\r\n        throw getMissingValueError('App Configuration');\r\n    }\r\n    if (!app.name) {\r\n        throw getMissingValueError('App Name');\r\n    }\r\n    // Required app config keys\r\n    const configKeys = [\r\n        'projectId',\r\n        'apiKey',\r\n        'appId'\r\n    ];\r\n    for (const keyName of configKeys) {\r\n        if (!app.options[keyName]) {\r\n            throw getMissingValueError(keyName);\r\n        }\r\n    }\r\n    return {\r\n        appName: app.name,\r\n        projectId: app.options.projectId,\r\n        apiKey: app.options.apiKey,\r\n        appId: app.options.appId\r\n    };\r\n}\r\nfunction getMissingValueError(valueName) {\r\n    return ERROR_FACTORY.create(\"missing-app-config-values\" /* MISSING_APP_CONFIG_VALUES */, {\r\n        valueName\r\n    });\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst INSTALLATIONS_NAME = 'installations';\r\nconst INSTALLATIONS_NAME_INTERNAL = 'installations-internal';\r\nconst publicFactory = (container) => {\r\n    const app = container.getProvider('app').getImmediate();\r\n    // Throws if app isn't configured properly.\r\n    const appConfig = extractAppConfig(app);\r\n    const heartbeatServiceProvider = _getProvider(app, 'heartbeat');\r\n    const installationsImpl = {\r\n        app,\r\n        appConfig,\r\n        heartbeatServiceProvider,\r\n        _delete: () => Promise.resolve()\r\n    };\r\n    return installationsImpl;\r\n};\r\nconst internalFactory = (container) => {\r\n    const app = container.getProvider('app').getImmediate();\r\n    // Internal FIS instance relies on public FIS instance.\r\n    const installations = _getProvider(app, INSTALLATIONS_NAME).getImmediate();\r\n    const installationsInternal = {\r\n        getId: () => getId(installations),\r\n        getToken: (forceRefresh) => getToken(installations, forceRefresh)\r\n    };\r\n    return installationsInternal;\r\n};\r\nfunction registerInstallations() {\r\n    _registerComponent(new Component(INSTALLATIONS_NAME, publicFactory, \"PUBLIC\" /* PUBLIC */));\r\n    _registerComponent(new Component(INSTALLATIONS_NAME_INTERNAL, internalFactory, \"PRIVATE\" /* PRIVATE */));\r\n}\n\n/**\r\n * Firebase Installations\r\n *\r\n * @packageDocumentation\r\n */\r\nregisterInstallations();\r\nregisterVersion(name, version);\r\n// BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\r\nregisterVersion(name, version, 'esm2017');\n\nexport { deleteInstallations, getId, getInstallations, getToken, onIdChange };\n//# sourceMappingURL=index.esm2017.js.map\n","import { getApp, _getProvider, _registerComponent, registerVersion } from '@firebase/app';\nimport { Logger } from '@firebase/logger';\nimport { ErrorFactory, calculateBackoffMillis, FirebaseError, isIndexedDBAvailable, validateIndexedDBOpenable, isBrowserExtension, areCookiesEnabled, getModularInstance, deepEqual } from '@firebase/util';\nimport { Component } from '@firebase/component';\nimport '@firebase/installations';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Type constant for Firebase Analytics.\r\n */\r\nconst ANALYTICS_TYPE = 'analytics';\r\n// Key to attach FID to in gtag params.\r\nconst GA_FID_KEY = 'firebase_id';\r\nconst ORIGIN_KEY = 'origin';\r\nconst FETCH_TIMEOUT_MILLIS = 60 * 1000;\r\nconst DYNAMIC_CONFIG_URL = 'https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig';\r\nconst GTAG_URL = 'https://www.googletagmanager.com/gtag/js';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst logger = new Logger('@firebase/analytics');\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Makeshift polyfill for Promise.allSettled(). Resolves when all promises\r\n * have either resolved or rejected.\r\n *\r\n * @param promises Array of promises to wait for.\r\n */\r\nfunction promiseAllSettled(promises) {\r\n    return Promise.all(promises.map(promise => promise.catch(e => e)));\r\n}\r\n/**\r\n * Inserts gtag script tag into the page to asynchronously download gtag.\r\n * @param dataLayerName Name of datalayer (most often the default, \"_dataLayer\").\r\n */\r\nfunction insertScriptTag(dataLayerName, measurementId) {\r\n    const script = document.createElement('script');\r\n    // We are not providing an analyticsId in the URL because it would trigger a `page_view`\r\n    // without fid. We will initialize ga-id using gtag (config) command together with fid.\r\n    script.src = `${GTAG_URL}?l=${dataLayerName}&id=${measurementId}`;\r\n    script.async = true;\r\n    document.head.appendChild(script);\r\n}\r\n/**\r\n * Get reference to, or create, global datalayer.\r\n * @param dataLayerName Name of datalayer (most often the default, \"_dataLayer\").\r\n */\r\nfunction getOrCreateDataLayer(dataLayerName) {\r\n    // Check for existing dataLayer and create if needed.\r\n    let dataLayer = [];\r\n    if (Array.isArray(window[dataLayerName])) {\r\n        dataLayer = window[dataLayerName];\r\n    }\r\n    else {\r\n        window[dataLayerName] = dataLayer;\r\n    }\r\n    return dataLayer;\r\n}\r\n/**\r\n * Wrapped gtag logic when gtag is called with 'config' command.\r\n *\r\n * @param gtagCore Basic gtag function that just appends to dataLayer.\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\r\n * @param measurementId GA Measurement ID to set config for.\r\n * @param gtagParams Gtag config params to set.\r\n */\r\nasync function gtagOnConfig(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, measurementId, gtagParams) {\r\n    // If config is already fetched, we know the appId and can use it to look up what FID promise we\r\n    /// are waiting for, and wait only on that one.\r\n    const correspondingAppId = measurementIdToAppId[measurementId];\r\n    try {\r\n        if (correspondingAppId) {\r\n            await initializationPromisesMap[correspondingAppId];\r\n        }\r\n        else {\r\n            // If config is not fetched yet, wait for all configs (we don't know which one we need) and\r\n            // find the appId (if any) corresponding to this measurementId. If there is one, wait on\r\n            // that appId's initialization promise. If there is none, promise resolves and gtag\r\n            // call goes through.\r\n            const dynamicConfigResults = await promiseAllSettled(dynamicConfigPromisesList);\r\n            const foundConfig = dynamicConfigResults.find(config => config.measurementId === measurementId);\r\n            if (foundConfig) {\r\n                await initializationPromisesMap[foundConfig.appId];\r\n            }\r\n        }\r\n    }\r\n    catch (e) {\r\n        logger.error(e);\r\n    }\r\n    gtagCore(\"config\" /* CONFIG */, measurementId, gtagParams);\r\n}\r\n/**\r\n * Wrapped gtag logic when gtag is called with 'event' command.\r\n *\r\n * @param gtagCore Basic gtag function that just appends to dataLayer.\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementId GA Measurement ID to log event to.\r\n * @param gtagParams Params to log with this event.\r\n */\r\nasync function gtagOnEvent(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementId, gtagParams) {\r\n    try {\r\n        let initializationPromisesToWaitFor = [];\r\n        // If there's a 'send_to' param, check if any ID specified matches\r\n        // an initializeIds() promise we are waiting for.\r\n        if (gtagParams && gtagParams['send_to']) {\r\n            let gaSendToList = gtagParams['send_to'];\r\n            // Make it an array if is isn't, so it can be dealt with the same way.\r\n            if (!Array.isArray(gaSendToList)) {\r\n                gaSendToList = [gaSendToList];\r\n            }\r\n            // Checking 'send_to' fields requires having all measurement ID results back from\r\n            // the dynamic config fetch.\r\n            const dynamicConfigResults = await promiseAllSettled(dynamicConfigPromisesList);\r\n            for (const sendToId of gaSendToList) {\r\n                // Any fetched dynamic measurement ID that matches this 'send_to' ID\r\n                const foundConfig = dynamicConfigResults.find(config => config.measurementId === sendToId);\r\n                const initializationPromise = foundConfig && initializationPromisesMap[foundConfig.appId];\r\n                if (initializationPromise) {\r\n                    initializationPromisesToWaitFor.push(initializationPromise);\r\n                }\r\n                else {\r\n                    // Found an item in 'send_to' that is not associated\r\n                    // directly with an FID, possibly a group.  Empty this array,\r\n                    // exit the loop early, and let it get populated below.\r\n                    initializationPromisesToWaitFor = [];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        // This will be unpopulated if there was no 'send_to' field , or\r\n        // if not all entries in the 'send_to' field could be mapped to\r\n        // a FID. In these cases, wait on all pending initialization promises.\r\n        if (initializationPromisesToWaitFor.length === 0) {\r\n            initializationPromisesToWaitFor = Object.values(initializationPromisesMap);\r\n        }\r\n        // Run core gtag function with args after all relevant initialization\r\n        // promises have been resolved.\r\n        await Promise.all(initializationPromisesToWaitFor);\r\n        // Workaround for http://b/141370449 - third argument cannot be undefined.\r\n        gtagCore(\"event\" /* EVENT */, measurementId, gtagParams || {});\r\n    }\r\n    catch (e) {\r\n        logger.error(e);\r\n    }\r\n}\r\n/**\r\n * Wraps a standard gtag function with extra code to wait for completion of\r\n * relevant initialization promises before sending requests.\r\n *\r\n * @param gtagCore Basic gtag function that just appends to dataLayer.\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\r\n */\r\nfunction wrapGtag(gtagCore, \r\n/**\r\n * Allows wrapped gtag calls to wait on whichever intialization promises are required,\r\n * depending on the contents of the gtag params' `send_to` field, if any.\r\n */\r\ninitializationPromisesMap, \r\n/**\r\n * Wrapped gtag calls sometimes require all dynamic config fetches to have returned\r\n * before determining what initialization promises (which include FIDs) to wait for.\r\n */\r\ndynamicConfigPromisesList, \r\n/**\r\n * Wrapped gtag config calls can narrow down which initialization promise (with FID)\r\n * to wait for if the measurementId is already fetched, by getting the corresponding appId,\r\n * which is the key for the initialization promises map.\r\n */\r\nmeasurementIdToAppId) {\r\n    /**\r\n     * Wrapper around gtag that ensures FID is sent with gtag calls.\r\n     * @param command Gtag command type.\r\n     * @param idOrNameOrParams Measurement ID if command is EVENT/CONFIG, params if command is SET.\r\n     * @param gtagParams Params if event is EVENT/CONFIG.\r\n     */\r\n    async function gtagWrapper(command, idOrNameOrParams, gtagParams) {\r\n        try {\r\n            // If event, check that relevant initialization promises have completed.\r\n            if (command === \"event\" /* EVENT */) {\r\n                // If EVENT, second arg must be measurementId.\r\n                await gtagOnEvent(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, idOrNameOrParams, gtagParams);\r\n            }\r\n            else if (command === \"config\" /* CONFIG */) {\r\n                // If CONFIG, second arg must be measurementId.\r\n                await gtagOnConfig(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, idOrNameOrParams, gtagParams);\r\n            }\r\n            else {\r\n                // If SET, second arg must be params.\r\n                gtagCore(\"set\" /* SET */, idOrNameOrParams);\r\n            }\r\n        }\r\n        catch (e) {\r\n            logger.error(e);\r\n        }\r\n    }\r\n    return gtagWrapper;\r\n}\r\n/**\r\n * Creates global gtag function or wraps existing one if found.\r\n * This wrapped function attaches Firebase instance ID (FID) to gtag 'config' and\r\n * 'event' calls that belong to the GAID associated with this Firebase instance.\r\n *\r\n * @param initializationPromisesMap Map of appIds to their initialization promises.\r\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\r\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\r\n * @param dataLayerName Name of global GA datalayer array.\r\n * @param gtagFunctionName Name of global gtag function (\"gtag\" if not user-specified).\r\n */\r\nfunction wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagFunctionName) {\r\n    // Create a basic core gtag function\r\n    let gtagCore = function (..._args) {\r\n        // Must push IArguments object, not an array.\r\n        window[dataLayerName].push(arguments);\r\n    };\r\n    // Replace it with existing one if found\r\n    if (window[gtagFunctionName] &&\r\n        typeof window[gtagFunctionName] === 'function') {\r\n        // @ts-ignore\r\n        gtagCore = window[gtagFunctionName];\r\n    }\r\n    window[gtagFunctionName] = wrapGtag(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId);\r\n    return {\r\n        gtagCore,\r\n        wrappedGtag: window[gtagFunctionName]\r\n    };\r\n}\r\n/**\r\n * Returns first script tag in DOM matching our gtag url pattern.\r\n */\r\nfunction findGtagScriptOnPage() {\r\n    const scriptTags = window.document.getElementsByTagName('script');\r\n    for (const tag of Object.values(scriptTags)) {\r\n        if (tag.src && tag.src.includes(GTAG_URL)) {\r\n            return tag;\r\n        }\r\n    }\r\n    return null;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nconst ERRORS = {\r\n    [\"already-exists\" /* ALREADY_EXISTS */]: 'A Firebase Analytics instance with the appId {$id} ' +\r\n        ' already exists. ' +\r\n        'Only one Firebase Analytics instance can be created for each appId.',\r\n    [\"already-initialized\" /* ALREADY_INITIALIZED */]: 'initializeAnalytics() cannot be called again with different options than those ' +\r\n        'it was initially called with. It can be called again with the same options to ' +\r\n        'return the existing instance, or getAnalytics() can be used ' +\r\n        'to get a reference to the already-intialized instance.',\r\n    [\"already-initialized-settings\" /* ALREADY_INITIALIZED_SETTINGS */]: 'Firebase Analytics has already been initialized.' +\r\n        'settings() must be called before initializing any Analytics instance' +\r\n        'or it will have no effect.',\r\n    [\"interop-component-reg-failed\" /* INTEROP_COMPONENT_REG_FAILED */]: 'Firebase Analytics Interop Component failed to instantiate: {$reason}',\r\n    [\"invalid-analytics-context\" /* INVALID_ANALYTICS_CONTEXT */]: 'Firebase Analytics is not supported in this environment. ' +\r\n        'Wrap initialization of analytics in analytics.isSupported() ' +\r\n        'to prevent initialization in unsupported environments. Details: {$errorInfo}',\r\n    [\"indexeddb-unavailable\" /* INDEXEDDB_UNAVAILABLE */]: 'IndexedDB unavailable or restricted in this environment. ' +\r\n        'Wrap initialization of analytics in analytics.isSupported() ' +\r\n        'to prevent initialization in unsupported environments. Details: {$errorInfo}',\r\n    [\"fetch-throttle\" /* FETCH_THROTTLE */]: 'The config fetch request timed out while in an exponential backoff state.' +\r\n        ' Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.',\r\n    [\"config-fetch-failed\" /* CONFIG_FETCH_FAILED */]: 'Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}',\r\n    [\"no-api-key\" /* NO_API_KEY */]: 'The \"apiKey\" field is empty in the local Firebase config. Firebase Analytics requires this field to' +\r\n        'contain a valid API key.',\r\n    [\"no-app-id\" /* NO_APP_ID */]: 'The \"appId\" field is empty in the local Firebase config. Firebase Analytics requires this field to' +\r\n        'contain a valid app ID.'\r\n};\r\nconst ERROR_FACTORY = new ErrorFactory('analytics', 'Analytics', ERRORS);\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Backoff factor for 503 errors, which we want to be conservative about\r\n * to avoid overloading servers. Each retry interval will be\r\n * BASE_INTERVAL_MILLIS * LONG_RETRY_FACTOR ^ retryCount, so the second one\r\n * will be ~30 seconds (with fuzzing).\r\n */\r\nconst LONG_RETRY_FACTOR = 30;\r\n/**\r\n * Base wait interval to multiplied by backoffFactor^backoffCount.\r\n */\r\nconst BASE_INTERVAL_MILLIS = 1000;\r\n/**\r\n * Stubbable retry data storage class.\r\n */\r\nclass RetryData {\r\n    constructor(throttleMetadata = {}, intervalMillis = BASE_INTERVAL_MILLIS) {\r\n        this.throttleMetadata = throttleMetadata;\r\n        this.intervalMillis = intervalMillis;\r\n    }\r\n    getThrottleMetadata(appId) {\r\n        return this.throttleMetadata[appId];\r\n    }\r\n    setThrottleMetadata(appId, metadata) {\r\n        this.throttleMetadata[appId] = metadata;\r\n    }\r\n    deleteThrottleMetadata(appId) {\r\n        delete this.throttleMetadata[appId];\r\n    }\r\n}\r\nconst defaultRetryData = new RetryData();\r\n/**\r\n * Set GET request headers.\r\n * @param apiKey App API key.\r\n */\r\nfunction getHeaders(apiKey) {\r\n    return new Headers({\r\n        Accept: 'application/json',\r\n        'x-goog-api-key': apiKey\r\n    });\r\n}\r\n/**\r\n * Fetches dynamic config from backend.\r\n * @param app Firebase app to fetch config for.\r\n */\r\nasync function fetchDynamicConfig(appFields) {\r\n    var _a;\r\n    const { appId, apiKey } = appFields;\r\n    const request = {\r\n        method: 'GET',\r\n        headers: getHeaders(apiKey)\r\n    };\r\n    const appUrl = DYNAMIC_CONFIG_URL.replace('{app-id}', appId);\r\n    const response = await fetch(appUrl, request);\r\n    if (response.status !== 200 && response.status !== 304) {\r\n        let errorMessage = '';\r\n        try {\r\n            // Try to get any error message text from server response.\r\n            const jsonResponse = (await response.json());\r\n            if ((_a = jsonResponse.error) === null || _a === void 0 ? void 0 : _a.message) {\r\n                errorMessage = jsonResponse.error.message;\r\n            }\r\n        }\r\n        catch (_ignored) { }\r\n        throw ERROR_FACTORY.create(\"config-fetch-failed\" /* CONFIG_FETCH_FAILED */, {\r\n            httpStatus: response.status,\r\n            responseMessage: errorMessage\r\n        });\r\n    }\r\n    return response.json();\r\n}\r\n/**\r\n * Fetches dynamic config from backend, retrying if failed.\r\n * @param app Firebase app to fetch config for.\r\n */\r\nasync function fetchDynamicConfigWithRetry(app, \r\n// retryData and timeoutMillis are parameterized to allow passing a different value for testing.\r\nretryData = defaultRetryData, timeoutMillis) {\r\n    const { appId, apiKey, measurementId } = app.options;\r\n    if (!appId) {\r\n        throw ERROR_FACTORY.create(\"no-app-id\" /* NO_APP_ID */);\r\n    }\r\n    if (!apiKey) {\r\n        if (measurementId) {\r\n            return {\r\n                measurementId,\r\n                appId\r\n            };\r\n        }\r\n        throw ERROR_FACTORY.create(\"no-api-key\" /* NO_API_KEY */);\r\n    }\r\n    const throttleMetadata = retryData.getThrottleMetadata(appId) || {\r\n        backoffCount: 0,\r\n        throttleEndTimeMillis: Date.now()\r\n    };\r\n    const signal = new AnalyticsAbortSignal();\r\n    setTimeout(async () => {\r\n        // Note a very low delay, eg < 10ms, can elapse before listeners are initialized.\r\n        signal.abort();\r\n    }, timeoutMillis !== undefined ? timeoutMillis : FETCH_TIMEOUT_MILLIS);\r\n    return attemptFetchDynamicConfigWithRetry({ appId, apiKey, measurementId }, throttleMetadata, signal, retryData);\r\n}\r\n/**\r\n * Runs one retry attempt.\r\n * @param appFields Necessary app config fields.\r\n * @param throttleMetadata Ongoing metadata to determine throttling times.\r\n * @param signal Abort signal.\r\n */\r\nasync function attemptFetchDynamicConfigWithRetry(appFields, { throttleEndTimeMillis, backoffCount }, signal, retryData = defaultRetryData // for testing\r\n) {\r\n    const { appId, measurementId } = appFields;\r\n    // Starts with a (potentially zero) timeout to support resumption from stored state.\r\n    // Ensures the throttle end time is honored if the last attempt timed out.\r\n    // Note the SDK will never make a request if the fetch timeout expires at this point.\r\n    try {\r\n        await setAbortableTimeout(signal, throttleEndTimeMillis);\r\n    }\r\n    catch (e) {\r\n        if (measurementId) {\r\n            logger.warn(`Timed out fetching this Firebase app's measurement ID from the server.` +\r\n                ` Falling back to the measurement ID ${measurementId}` +\r\n                ` provided in the \"measurementId\" field in the local Firebase config. [${e.message}]`);\r\n            return { appId, measurementId };\r\n        }\r\n        throw e;\r\n    }\r\n    try {\r\n        const response = await fetchDynamicConfig(appFields);\r\n        // Note the SDK only clears throttle state if response is success or non-retriable.\r\n        retryData.deleteThrottleMetadata(appId);\r\n        return response;\r\n    }\r\n    catch (e) {\r\n        if (!isRetriableError(e)) {\r\n            retryData.deleteThrottleMetadata(appId);\r\n            if (measurementId) {\r\n                logger.warn(`Failed to fetch this Firebase app's measurement ID from the server.` +\r\n                    ` Falling back to the measurement ID ${measurementId}` +\r\n                    ` provided in the \"measurementId\" field in the local Firebase config. [${e.message}]`);\r\n                return { appId, measurementId };\r\n            }\r\n            else {\r\n                throw e;\r\n            }\r\n        }\r\n        const backoffMillis = Number(e.customData.httpStatus) === 503\r\n            ? calculateBackoffMillis(backoffCount, retryData.intervalMillis, LONG_RETRY_FACTOR)\r\n            : calculateBackoffMillis(backoffCount, retryData.intervalMillis);\r\n        // Increments backoff state.\r\n        const throttleMetadata = {\r\n            throttleEndTimeMillis: Date.now() + backoffMillis,\r\n            backoffCount: backoffCount + 1\r\n        };\r\n        // Persists state.\r\n        retryData.setThrottleMetadata(appId, throttleMetadata);\r\n        logger.debug(`Calling attemptFetch again in ${backoffMillis} millis`);\r\n        return attemptFetchDynamicConfigWithRetry(appFields, throttleMetadata, signal, retryData);\r\n    }\r\n}\r\n/**\r\n * Supports waiting on a backoff by:\r\n *\r\n * <ul>\r\n *   <li>Promisifying setTimeout, so we can set a timeout in our Promise chain</li>\r\n *   <li>Listening on a signal bus for abort events, just like the Fetch API</li>\r\n *   <li>Failing in the same way the Fetch API fails, so timing out a live request and a throttled\r\n *       request appear the same.</li>\r\n * </ul>\r\n *\r\n * <p>Visible for testing.\r\n */\r\nfunction setAbortableTimeout(signal, throttleEndTimeMillis) {\r\n    return new Promise((resolve, reject) => {\r\n        // Derives backoff from given end time, normalizing negative numbers to zero.\r\n        const backoffMillis = Math.max(throttleEndTimeMillis - Date.now(), 0);\r\n        const timeout = setTimeout(resolve, backoffMillis);\r\n        // Adds listener, rather than sets onabort, because signal is a shared object.\r\n        signal.addEventListener(() => {\r\n            clearTimeout(timeout);\r\n            // If the request completes before this timeout, the rejection has no effect.\r\n            reject(ERROR_FACTORY.create(\"fetch-throttle\" /* FETCH_THROTTLE */, {\r\n                throttleEndTimeMillis\r\n            }));\r\n        });\r\n    });\r\n}\r\n/**\r\n * Returns true if the {@link Error} indicates a fetch request may succeed later.\r\n */\r\nfunction isRetriableError(e) {\r\n    if (!(e instanceof FirebaseError) || !e.customData) {\r\n        return false;\r\n    }\r\n    // Uses string index defined by ErrorData, which FirebaseError implements.\r\n    const httpStatus = Number(e.customData['httpStatus']);\r\n    return (httpStatus === 429 ||\r\n        httpStatus === 500 ||\r\n        httpStatus === 503 ||\r\n        httpStatus === 504);\r\n}\r\n/**\r\n * Shims a minimal AbortSignal (copied from Remote Config).\r\n *\r\n * <p>AbortController's AbortSignal conveniently decouples fetch timeout logic from other aspects\r\n * of networking, such as retries. Firebase doesn't use AbortController enough to justify a\r\n * polyfill recommendation, like we do with the Fetch API, but this minimal shim can easily be\r\n * swapped out if/when we do.\r\n */\r\nclass AnalyticsAbortSignal {\r\n    constructor() {\r\n        this.listeners = [];\r\n    }\r\n    addEventListener(listener) {\r\n        this.listeners.push(listener);\r\n    }\r\n    abort() {\r\n        this.listeners.forEach(listener => listener());\r\n    }\r\n}\n\n/**\r\n * @license\r\n * Copyright 2020 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nasync function validateIndexedDB() {\r\n    if (!isIndexedDBAvailable()) {\r\n        logger.warn(ERROR_FACTORY.create(\"indexeddb-unavailable\" /* INDEXEDDB_UNAVAILABLE */, {\r\n            errorInfo: 'IndexedDB is not available in this environment.'\r\n        }).message);\r\n        return false;\r\n    }\r\n    else {\r\n        try {\r\n            await validateIndexedDBOpenable();\r\n        }\r\n        catch (e) {\r\n            logger.warn(ERROR_FACTORY.create(\"indexeddb-unavailable\" /* INDEXEDDB_UNAVAILABLE */, {\r\n                errorInfo: e\r\n            }).message);\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n/**\r\n * Initialize the analytics instance in gtag.js by calling config command with fid.\r\n *\r\n * NOTE: We combine analytics initialization and setting fid together because we want fid to be\r\n * part of the `page_view` event that's sent during the initialization\r\n * @param app Firebase app\r\n * @param gtagCore The gtag function that's not wrapped.\r\n * @param dynamicConfigPromisesList Array of all dynamic config promises.\r\n * @param measurementIdToAppId Maps measurementID to appID.\r\n * @param installations _FirebaseInstallationsInternal instance.\r\n *\r\n * @returns Measurement ID.\r\n */\r\nasync function _initializeAnalytics(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCore, dataLayerName, options) {\r\n    var _a;\r\n    const dynamicConfigPromise = fetchDynamicConfigWithRetry(app);\r\n    // Once fetched, map measurementIds to appId, for ease of lookup in wrapped gtag function.\r\n    dynamicConfigPromise\r\n        .then(config => {\r\n        measurementIdToAppId[config.measurementId] = config.appId;\r\n        if (app.options.measurementId &&\r\n            config.measurementId !== app.options.measurementId) {\r\n            logger.warn(`The measurement ID in the local Firebase config (${app.options.measurementId})` +\r\n                ` does not match the measurement ID fetched from the server (${config.measurementId}).` +\r\n                ` To ensure analytics events are always sent to the correct Analytics property,` +\r\n                ` update the` +\r\n                ` measurement ID field in the local config or remove it from the local config.`);\r\n        }\r\n    })\r\n        .catch(e => logger.error(e));\r\n    // Add to list to track state of all dynamic config promises.\r\n    dynamicConfigPromisesList.push(dynamicConfigPromise);\r\n    const fidPromise = validateIndexedDB().then(envIsValid => {\r\n        if (envIsValid) {\r\n            return installations.getId();\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    });\r\n    const [dynamicConfig, fid] = await Promise.all([\r\n        dynamicConfigPromise,\r\n        fidPromise\r\n    ]);\r\n    // Detect if user has already put the gtag <script> tag on this page.\r\n    if (!findGtagScriptOnPage()) {\r\n        insertScriptTag(dataLayerName, dynamicConfig.measurementId);\r\n    }\r\n    // This command initializes gtag.js and only needs to be called once for the entire web app,\r\n    // but since it is idempotent, we can call it multiple times.\r\n    // We keep it together with other initialization logic for better code structure.\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    gtagCore('js', new Date());\r\n    // User config added first. We don't want users to accidentally overwrite\r\n    // base Firebase config properties.\r\n    const configProperties = (_a = options === null || options === void 0 ? void 0 : options.config) !== null && _a !== void 0 ? _a : {};\r\n    // guard against developers accidentally setting properties with prefix `firebase_`\r\n    configProperties[ORIGIN_KEY] = 'firebase';\r\n    configProperties.update = true;\r\n    if (fid != null) {\r\n        configProperties[GA_FID_KEY] = fid;\r\n    }\r\n    // It should be the first config command called on this GA-ID\r\n    // Initialize this GA-ID and set FID on it using the gtag config API.\r\n    // Note: This will trigger a page_view event unless 'send_page_view' is set to false in\r\n    // `configProperties`.\r\n    gtagCore(\"config\" /* CONFIG */, dynamicConfig.measurementId, configProperties);\r\n    return dynamicConfig.measurementId;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Analytics Service class.\r\n */\r\nclass AnalyticsService {\r\n    constructor(app) {\r\n        this.app = app;\r\n    }\r\n    _delete() {\r\n        delete initializationPromisesMap[this.app.options.appId];\r\n        return Promise.resolve();\r\n    }\r\n}\r\n/**\r\n * Maps appId to full initialization promise. Wrapped gtag calls must wait on\r\n * all or some of these, depending on the call's `send_to` param and the status\r\n * of the dynamic config fetches (see below).\r\n */\r\nlet initializationPromisesMap = {};\r\n/**\r\n * List of dynamic config fetch promises. In certain cases, wrapped gtag calls\r\n * wait on all these to be complete in order to determine if it can selectively\r\n * wait for only certain initialization (FID) promises or if it must wait for all.\r\n */\r\nlet dynamicConfigPromisesList = [];\r\n/**\r\n * Maps fetched measurementIds to appId. Populated when the app's dynamic config\r\n * fetch completes. If already populated, gtag config calls can use this to\r\n * selectively wait for only this app's initialization promise (FID) instead of all\r\n * initialization promises.\r\n */\r\nconst measurementIdToAppId = {};\r\n/**\r\n * Name for window global data layer array used by GA: defaults to 'dataLayer'.\r\n */\r\nlet dataLayerName = 'dataLayer';\r\n/**\r\n * Name for window global gtag function used by GA: defaults to 'gtag'.\r\n */\r\nlet gtagName = 'gtag';\r\n/**\r\n * Reproduction of standard gtag function or reference to existing\r\n * gtag function on window object.\r\n */\r\nlet gtagCoreFunction;\r\n/**\r\n * Wrapper around gtag function that ensures FID is sent with all\r\n * relevant event and config calls.\r\n */\r\nlet wrappedGtagFunction;\r\n/**\r\n * Flag to ensure page initialization steps (creation or wrapping of\r\n * dataLayer and gtag script) are only run once per page load.\r\n */\r\nlet globalInitDone = false;\r\n/**\r\n * Configures Firebase Analytics to use custom `gtag` or `dataLayer` names.\r\n * Intended to be used if `gtag.js` script has been installed on\r\n * this page independently of Firebase Analytics, and is using non-default\r\n * names for either the `gtag` function or for `dataLayer`.\r\n * Must be called before calling `getAnalytics()` or it won't\r\n * have any effect.\r\n *\r\n * @public\r\n *\r\n * @param options - Custom gtag and dataLayer names.\r\n */\r\nfunction settings(options) {\r\n    if (globalInitDone) {\r\n        throw ERROR_FACTORY.create(\"already-initialized\" /* ALREADY_INITIALIZED */);\r\n    }\r\n    if (options.dataLayerName) {\r\n        dataLayerName = options.dataLayerName;\r\n    }\r\n    if (options.gtagName) {\r\n        gtagName = options.gtagName;\r\n    }\r\n}\r\n/**\r\n * Returns true if no environment mismatch is found.\r\n * If environment mismatches are found, throws an INVALID_ANALYTICS_CONTEXT\r\n * error that also lists details for each mismatch found.\r\n */\r\nfunction warnOnBrowserContextMismatch() {\r\n    const mismatchedEnvMessages = [];\r\n    if (isBrowserExtension()) {\r\n        mismatchedEnvMessages.push('This is a browser extension environment.');\r\n    }\r\n    if (!areCookiesEnabled()) {\r\n        mismatchedEnvMessages.push('Cookies are not available.');\r\n    }\r\n    if (mismatchedEnvMessages.length > 0) {\r\n        const details = mismatchedEnvMessages\r\n            .map((message, index) => `(${index + 1}) ${message}`)\r\n            .join(' ');\r\n        const err = ERROR_FACTORY.create(\"invalid-analytics-context\" /* INVALID_ANALYTICS_CONTEXT */, {\r\n            errorInfo: details\r\n        });\r\n        logger.warn(err.message);\r\n    }\r\n}\r\n/**\r\n * Analytics instance factory.\r\n * @internal\r\n */\r\nfunction factory(app, installations, options) {\r\n    warnOnBrowserContextMismatch();\r\n    const appId = app.options.appId;\r\n    if (!appId) {\r\n        throw ERROR_FACTORY.create(\"no-app-id\" /* NO_APP_ID */);\r\n    }\r\n    if (!app.options.apiKey) {\r\n        if (app.options.measurementId) {\r\n            logger.warn(`The \"apiKey\" field is empty in the local Firebase config. This is needed to fetch the latest` +\r\n                ` measurement ID for this Firebase app. Falling back to the measurement ID ${app.options.measurementId}` +\r\n                ` provided in the \"measurementId\" field in the local Firebase config.`);\r\n        }\r\n        else {\r\n            throw ERROR_FACTORY.create(\"no-api-key\" /* NO_API_KEY */);\r\n        }\r\n    }\r\n    if (initializationPromisesMap[appId] != null) {\r\n        throw ERROR_FACTORY.create(\"already-exists\" /* ALREADY_EXISTS */, {\r\n            id: appId\r\n        });\r\n    }\r\n    if (!globalInitDone) {\r\n        // Steps here should only be done once per page: creation or wrapping\r\n        // of dataLayer and global gtag function.\r\n        getOrCreateDataLayer(dataLayerName);\r\n        const { wrappedGtag, gtagCore } = wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagName);\r\n        wrappedGtagFunction = wrappedGtag;\r\n        gtagCoreFunction = gtagCore;\r\n        globalInitDone = true;\r\n    }\r\n    // Async but non-blocking.\r\n    // This map reflects the completion state of all promises for each appId.\r\n    initializationPromisesMap[appId] = _initializeAnalytics(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCoreFunction, dataLayerName, options);\r\n    const analyticsInstance = new AnalyticsService(app);\r\n    return analyticsInstance;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Logs an analytics event through the Firebase SDK.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param eventName Google Analytics event name, choose from standard list or use a custom string.\r\n * @param eventParams Analytics event parameters.\r\n */\r\nasync function logEvent$1(gtagFunction, initializationPromise, eventName, eventParams, options) {\r\n    if (options && options.global) {\r\n        gtagFunction(\"event\" /* EVENT */, eventName, eventParams);\r\n        return;\r\n    }\r\n    else {\r\n        const measurementId = await initializationPromise;\r\n        const params = Object.assign(Object.assign({}, eventParams), { 'send_to': measurementId });\r\n        gtagFunction(\"event\" /* EVENT */, eventName, params);\r\n    }\r\n}\r\n/**\r\n * Set screen_name parameter for this Google Analytics ID.\r\n *\r\n * @deprecated Use {@link logEvent} with `eventName` as 'screen_view' and add relevant `eventParams`.\r\n * See {@link https://firebase.google.com/docs/analytics/screenviews | Track Screenviews}.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param screenName Screen name string to set.\r\n */\r\nasync function setCurrentScreen$1(gtagFunction, initializationPromise, screenName, options) {\r\n    if (options && options.global) {\r\n        gtagFunction(\"set\" /* SET */, { 'screen_name': screenName });\r\n        return Promise.resolve();\r\n    }\r\n    else {\r\n        const measurementId = await initializationPromise;\r\n        gtagFunction(\"config\" /* CONFIG */, measurementId, {\r\n            update: true,\r\n            'screen_name': screenName\r\n        });\r\n    }\r\n}\r\n/**\r\n * Set user_id parameter for this Google Analytics ID.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param id User ID string to set\r\n */\r\nasync function setUserId$1(gtagFunction, initializationPromise, id, options) {\r\n    if (options && options.global) {\r\n        gtagFunction(\"set\" /* SET */, { 'user_id': id });\r\n        return Promise.resolve();\r\n    }\r\n    else {\r\n        const measurementId = await initializationPromise;\r\n        gtagFunction(\"config\" /* CONFIG */, measurementId, {\r\n            update: true,\r\n            'user_id': id\r\n        });\r\n    }\r\n}\r\n/**\r\n * Set all other user properties other than user_id and screen_name.\r\n *\r\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\r\n * @param properties Map of user properties to set\r\n */\r\nasync function setUserProperties$1(gtagFunction, initializationPromise, properties, options) {\r\n    if (options && options.global) {\r\n        const flatProperties = {};\r\n        for (const key of Object.keys(properties)) {\r\n            // use dot notation for merge behavior in gtag.js\r\n            flatProperties[`user_properties.${key}`] = properties[key];\r\n        }\r\n        gtagFunction(\"set\" /* SET */, flatProperties);\r\n        return Promise.resolve();\r\n    }\r\n    else {\r\n        const measurementId = await initializationPromise;\r\n        gtagFunction(\"config\" /* CONFIG */, measurementId, {\r\n            update: true,\r\n            'user_properties': properties\r\n        });\r\n    }\r\n}\r\n/**\r\n * Set whether collection is enabled for this ID.\r\n *\r\n * @param enabled If true, collection is enabled for this ID.\r\n */\r\nasync function setAnalyticsCollectionEnabled$1(initializationPromise, enabled) {\r\n    const measurementId = await initializationPromise;\r\n    window[`ga-disable-${measurementId}`] = !enabled;\r\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\n/**\r\n * Returns an {@link Analytics} instance for the given app.\r\n *\r\n * @public\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\r\n */\r\nfunction getAnalytics(app = getApp()) {\r\n    app = getModularInstance(app);\r\n    // Dependencies\r\n    const analyticsProvider = _getProvider(app, ANALYTICS_TYPE);\r\n    if (analyticsProvider.isInitialized()) {\r\n        return analyticsProvider.getImmediate();\r\n    }\r\n    return initializeAnalytics(app);\r\n}\r\n/**\r\n * Returns an {@link Analytics} instance for the given app.\r\n *\r\n * @public\r\n *\r\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\r\n */\r\nfunction initializeAnalytics(app, options = {}) {\r\n    // Dependencies\r\n    const analyticsProvider = _getProvider(app, ANALYTICS_TYPE);\r\n    if (analyticsProvider.isInitialized()) {\r\n        const existingInstance = analyticsProvider.getImmediate();\r\n        if (deepEqual(options, analyticsProvider.getOptions())) {\r\n            return existingInstance;\r\n        }\r\n        else {\r\n            throw ERROR_FACTORY.create(\"already-initialized\" /* ALREADY_INITIALIZED */);\r\n        }\r\n    }\r\n    const analyticsInstance = analyticsProvider.initialize({ options });\r\n    return analyticsInstance;\r\n}\r\n/**\r\n * This is a public static method provided to users that wraps four different checks:\r\n *\r\n * 1. Check if it's not a browser extension environment.\r\n * 2. Check if cookies are enabled in current browser.\r\n * 3. Check if IndexedDB is supported by the browser environment.\r\n * 4. Check if the current browser context is valid for using `IndexedDB.open()`.\r\n *\r\n * @public\r\n *\r\n */\r\nasync function isSupported() {\r\n    if (isBrowserExtension()) {\r\n        return false;\r\n    }\r\n    if (!areCookiesEnabled()) {\r\n        return false;\r\n    }\r\n    if (!isIndexedDBAvailable()) {\r\n        return false;\r\n    }\r\n    try {\r\n        const isDBOpenable = await validateIndexedDBOpenable();\r\n        return isDBOpenable;\r\n    }\r\n    catch (error) {\r\n        return false;\r\n    }\r\n}\r\n/**\r\n * Use gtag `config` command to set `screen_name`.\r\n *\r\n * @public\r\n *\r\n * @deprecated Use {@link logEvent} with `eventName` as 'screen_view' and add relevant `eventParams`.\r\n * See {@link https://firebase.google.com/docs/analytics/screenviews | Track Screenviews}.\r\n *\r\n * @param analyticsInstance - The {@link Analytics} instance.\r\n * @param screenName - Screen name to set.\r\n */\r\nfunction setCurrentScreen(analyticsInstance, screenName, options) {\r\n    analyticsInstance = getModularInstance(analyticsInstance);\r\n    setCurrentScreen$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], screenName, options).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Use gtag `config` command to set `user_id`.\r\n *\r\n * @public\r\n *\r\n * @param analyticsInstance - The {@link Analytics} instance.\r\n * @param id - User ID to set.\r\n */\r\nfunction setUserId(analyticsInstance, id, options) {\r\n    analyticsInstance = getModularInstance(analyticsInstance);\r\n    setUserId$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], id, options).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Use gtag `config` command to set all params specified.\r\n *\r\n * @public\r\n */\r\nfunction setUserProperties(analyticsInstance, properties, options) {\r\n    analyticsInstance = getModularInstance(analyticsInstance);\r\n    setUserProperties$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], properties, options).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Sets whether Google Analytics collection is enabled for this app on this device.\r\n * Sets global `window['ga-disable-analyticsId'] = true;`\r\n *\r\n * @public\r\n *\r\n * @param analyticsInstance - The {@link Analytics} instance.\r\n * @param enabled - If true, enables collection, if false, disables it.\r\n */\r\nfunction setAnalyticsCollectionEnabled(analyticsInstance, enabled) {\r\n    analyticsInstance = getModularInstance(analyticsInstance);\r\n    setAnalyticsCollectionEnabled$1(initializationPromisesMap[analyticsInstance.app.options.appId], enabled).catch(e => logger.error(e));\r\n}\r\n/**\r\n * Sends a Google Analytics event with given `eventParams`. This method\r\n * automatically associates this logged event with this Firebase web\r\n * app instance on this device.\r\n * List of official event parameters can be found in the gtag.js\r\n * reference documentation:\r\n * {@link https://developers.google.com/gtagjs/reference/ga4-events\r\n * | the GA4 reference documentation}.\r\n *\r\n * @public\r\n */\r\nfunction logEvent(analyticsInstance, eventName, eventParams, options) {\r\n    analyticsInstance = getModularInstance(analyticsInstance);\r\n    logEvent$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], eventName, eventParams, options).catch(e => logger.error(e));\r\n}\n\nconst name = \"@firebase/analytics\";\nconst version = \"0.7.10\";\n\n/**\r\n * Firebase Analytics\r\n *\r\n * @packageDocumentation\r\n */\r\nfunction registerAnalytics() {\r\n    _registerComponent(new Component(ANALYTICS_TYPE, (container, { options: analyticsOptions }) => {\r\n        // getImmediate for FirebaseApp will always succeed\r\n        const app = container.getProvider('app').getImmediate();\r\n        const installations = container\r\n            .getProvider('installations-internal')\r\n            .getImmediate();\r\n        return factory(app, installations, analyticsOptions);\r\n    }, \"PUBLIC\" /* PUBLIC */));\r\n    _registerComponent(new Component('analytics-internal', internalFactory, \"PRIVATE\" /* PRIVATE */));\r\n    registerVersion(name, version);\r\n    // BUILD_TARGET will be replaced by values like esm5, esm2017, cjs5, etc during the compilation\r\n    registerVersion(name, version, 'esm2017');\r\n    function internalFactory(container) {\r\n        try {\r\n            const analytics = container.getProvider(ANALYTICS_TYPE).getImmediate();\r\n            return {\r\n                logEvent: (eventName, eventParams, options) => logEvent(analytics, eventName, eventParams, options)\r\n            };\r\n        }\r\n        catch (e) {\r\n            throw ERROR_FACTORY.create(\"interop-component-reg-failed\" /* INTEROP_COMPONENT_REG_FAILED */, {\r\n                reason: e\r\n            });\r\n        }\r\n    }\r\n}\r\nregisterAnalytics();\n\nexport { getAnalytics, initializeAnalytics, isSupported, logEvent, setAnalyticsCollectionEnabled, setCurrentScreen, setUserId, setUserProperties, settings };\n//# sourceMappingURL=index.esm2017.js.map\n"],"names":["version","PACKAGE_VERSION","ERROR_FACTORY","isServerError","error","code","includes","getInstallationsEndpoint","projectId","extractAuthTokenInfoFromResponse","response","token","requestStatus","expiresIn","responseExpiresIn","Number","replace","creationTime","Date","now","async","getErrorFromResponse","requestName","errorData","json","create","serverCode","serverMessage","message","serverStatus","status","getHeaders","apiKey","Headers","Accept","retryIfServerError","fn","result","sleep","ms","Promise","resolve","setTimeout","VALID_FID_PATTERN","generateFid","fidByteArray","Uint8Array","self","crypto","msCrypto","getRandomValues","fid","array","btoa","String","fromCharCode","substr","encode","test","_a","getKey","appConfig","appName","appId","fidChangeCallbacks","Map","fidChanged","key","callFidChangeCallbacks","channel","broadcastChannel","BroadcastChannel","onmessage","e","data","postMessage","size","close","broadcastFidChange","callbacks","get","callback","OBJECT_STORE_NAME","dbPromise","getDbPromise","upgrade","db","oldVersion","createObjectStore","set","value","tx","transaction","objectStore","oldValue","put","done","remove","delete","update","updateFn","store","newValue","undefined","getInstallationEntry","installations","registrationPromise","installationEntry","oldEntry","clearTimedOutRequest","registrationStatus","updateOrCreateInstallationEntry","entryWithPromise","navigator","onLine","reject","inProgressEntry","registrationTime","registeredInstallationEntry","heartbeatServiceProvider","endpoint","headers","heartbeatService","getImmediate","optional","heartbeatsHeader","getHeartbeatsHeader","append","body","authVersion","sdkVersion","request","method","JSON","stringify","fetch","ok","responseValue","refreshToken","authToken","createInstallationRequest","customData","registerInstallation","waitUntilFidRegistration","triggerRegistrationIfNecessary","entry","updateInstallationRequest","generateAuthTokenRequest","getGenerateAuthTokenEndpoint","getAuthorizationHeader","getHeadersWithAuth","installation","refreshAuthToken","forceRefresh","tokenPromise","isEntryRegistered","oldAuthToken","isAuthTokenExpired","updateAuthTokenRequest","waitUntilAuthTokenRequest","inProgressAuthToken","requestTime","Object","assign","makeAuthTokenRequestInProgressEntry","updatedInstallationEntry","fetchAuthTokenFromServer","getMissingValueError","valueName","INSTALLATIONS_NAME","container","app","getProvider","options","name","configKeys","keyName","extractAppConfig","_delete","getId","installationsImpl","catch","console","getToken","completeInstallationRegistration","ANALYTICS_TYPE","GTAG_URL","logger","promiseAllSettled","promises","all","map","promise","defaultRetryData","constructor","throttleMetadata","intervalMillis","this","getThrottleMetadata","setThrottleMetadata","metadata","deleteThrottleMetadata","fetchDynamicConfigWithRetry","retryData","timeoutMillis","measurementId","backoffCount","throttleEndTimeMillis","signal","AnalyticsAbortSignal","abort","attemptFetchDynamicConfigWithRetry","appFields","backoffMillis","Math","max","timeout","addEventListener","clearTimeout","setAbortableTimeout","warn","appUrl","errorMessage","jsonResponse","_ignored","httpStatus","responseMessage","fetchDynamicConfig","isRetriableError","debug","listeners","listener","push","forEach","AnalyticsService","initializationPromisesMap","dynamicConfigPromisesList","measurementIdToAppId","gtagCoreFunction","wrappedGtagFunction","dataLayerName","gtagName","globalInitDone","settings","factory","mismatchedEnvMessages","length","details","index","join","err","errorInfo","warnOnBrowserContextMismatch","id","dataLayer","Array","isArray","window","getOrCreateDataLayer","wrappedGtag","gtagCore","gtagFunctionName","_args","arguments","command","idOrNameOrParams","gtagParams","initializationPromisesToWaitFor","gaSendToList","dynamicConfigResults","sendToId","foundConfig","find","config","initializationPromise","values","gtagOnEvent","correspondingAppId","gtagOnConfig","wrapGtag","wrapOrCreateGtag","dynamicConfigPromise","then","fidPromise","validateIndexedDB","envIsValid","dynamicConfig","scriptTags","document","getElementsByTagName","tag","src","findGtagScriptOnPage","script","createElement","head","appendChild","insertScriptTag","configProperties","_initializeAnalytics","getAnalytics","analyticsProvider","isInitialized","initializeAnalytics","existingInstance","getOptions","initialize","isSupported","setCurrentScreen","analyticsInstance","screenName","gtagFunction","global","setCurrentScreen$1","setUserId","setUserId$1","setUserProperties","properties","flatProperties","keys","setUserProperties$1","setAnalyticsCollectionEnabled","enabled","setAnalyticsCollectionEnabled$1","logEvent","eventName","eventParams","logEvent$1","analyticsOptions","analytics","reason"],"sourceRoot":""}