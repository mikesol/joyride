"use strict";(self.webpackChunkjoyride=self.webpackChunkjoyride||[]).push([[699],{4430:(t,e,r)=>{r.d(e,{Tl:()=>l,a$:()=>f,lC:()=>d,ql:()=>c});var i=r(6980),s=r(4532),o=r(6120),n=r(7282),a=r(7006);const u=new s.Vector3,h=new o.Vector2;class l{constructor(t,e,r){if(Array.isArray(t))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.name="",this.array=t,this.itemSize=e,this.count=void 0!==t?t.length/e:0,this.normalized=!0===r,this.usage=a.W2J,this.updateRange={offset:0,count:-1},this.version=0}onUploadCallback(){}set needsUpdate(t){!0===t&&this.version++}setUsage(t){return this.usage=t,this}copy(t){return this.name=t.name,this.array=new t.array.constructor(t.array),this.itemSize=t.itemSize,this.count=t.count,this.normalized=t.normalized,this.usage=t.usage,this}copyAt(t,e,r){t*=this.itemSize,r*=e.itemSize;for(let i=0,s=this.itemSize;i<s;i++)this.array[t+i]=e.array[r+i];return this}copyArray(t){return this.array.set(t),this}copyColorsArray(t){const e=this.array;let r=0;for(let i=0,s=t.length;i<s;i++){let s=t[i];void 0===s&&(console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined",i),s=new n.Color),e[r++]=s.r,e[r++]=s.g,e[r++]=s.b}return this}copyVector2sArray(t){const e=this.array;let r=0;for(let i=0,s=t.length;i<s;i++){let s=t[i];void 0===s&&(console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined",i),s=new o.Vector2),e[r++]=s.x,e[r++]=s.y}return this}copyVector3sArray(t){const e=this.array;let r=0;for(let i=0,o=t.length;i<o;i++){let o=t[i];void 0===o&&(console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined",i),o=new s.Vector3),e[r++]=o.x,e[r++]=o.y,e[r++]=o.z}return this}copyVector4sArray(t){const e=this.array;let r=0;for(let s=0,o=t.length;s<o;s++){let o=t[s];void 0===o&&(console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined",s),o=new i.L),e[r++]=o.x,e[r++]=o.y,e[r++]=o.z,e[r++]=o.w}return this}applyMatrix3(t){if(2===this.itemSize)for(let e=0,r=this.count;e<r;e++)h.fromBufferAttribute(this,e),h.applyMatrix3(t),this.setXY(e,h.x,h.y);else if(3===this.itemSize)for(let e=0,r=this.count;e<r;e++)u.fromBufferAttribute(this,e),u.applyMatrix3(t),this.setXYZ(e,u.x,u.y,u.z);return this}applyMatrix4(t){for(let e=0,r=this.count;e<r;e++)u.fromBufferAttribute(this,e),u.applyMatrix4(t),this.setXYZ(e,u.x,u.y,u.z);return this}applyNormalMatrix(t){for(let e=0,r=this.count;e<r;e++)u.fromBufferAttribute(this,e),u.applyNormalMatrix(t),this.setXYZ(e,u.x,u.y,u.z);return this}transformDirection(t){for(let e=0,r=this.count;e<r;e++)u.fromBufferAttribute(this,e),u.transformDirection(t),this.setXYZ(e,u.x,u.y,u.z);return this}set(t,e=0){return this.array.set(t,e),this}getX(t){return this.array[t*this.itemSize]}setX(t,e){return this.array[t*this.itemSize]=e,this}getY(t){return this.array[t*this.itemSize+1]}setY(t,e){return this.array[t*this.itemSize+1]=e,this}getZ(t){return this.array[t*this.itemSize+2]}setZ(t,e){return this.array[t*this.itemSize+2]=e,this}getW(t){return this.array[t*this.itemSize+3]}setW(t,e){return this.array[t*this.itemSize+3]=e,this}setXY(t,e,r){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=r,this}setXYZ(t,e,r,i){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=r,this.array[t+2]=i,this}setXYZW(t,e,r,i,s){return t*=this.itemSize,this.array[t+0]=e,this.array[t+1]=r,this.array[t+2]=i,this.array[t+3]=s,this}onUpload(t){return this.onUploadCallback=t,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const t={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.prototype.slice.call(this.array),normalized:this.normalized};return""!==this.name&&(t.name=this.name),this.usage!==a.W2J&&(t.usage=this.usage),0===this.updateRange.offset&&-1===this.updateRange.count||(t.updateRange=this.updateRange),t}}l.prototype.isBufferAttribute=!0;class c extends l{constructor(t,e,r){super(new Uint16Array(t),e,r)}}class d extends l{constructor(t,e,r){super(new Uint32Array(t),e,r)}}(class extends l{constructor(t,e,r){super(new Uint16Array(t),e,r)}}).prototype.isFloat16BufferAttribute=!0;class f extends l{constructor(t,e,r){super(new Float32Array(t),e,r)}}},5699:(t,e,r)=>{r.d(e,{u:()=>B});var i=r(4532),s=r(6120),o=r(7232),n=r(9574),a=r(4430),u=r(9771),h=r(3802),l=r(1245),c=r(4894),d=r(9542),f=r(5042);let m=0;const p=new l.Matrix4,y=new h.T,g=new i.Vector3,b=new o.Box3,x=new o.Box3,A=new i.Vector3;class B extends n.p{constructor(){super(),Object.defineProperty(this,"id",{value:m++}),this.uuid=d.DO(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(t){return Array.isArray(t)?this.index=new((0,f.H7)(t)?a.lC:a.ql)(t,1):this.index=t,this}getAttribute(t){return this.attributes[t]}setAttribute(t,e){return this.attributes[t]=e,this}deleteAttribute(t){return delete this.attributes[t],this}hasAttribute(t){return void 0!==this.attributes[t]}addGroup(t,e,r=0){this.groups.push({start:t,count:e,materialIndex:r})}clearGroups(){this.groups=[]}setDrawRange(t,e){this.drawRange.start=t,this.drawRange.count=e}applyMatrix4(t){const e=this.attributes.position;void 0!==e&&(e.applyMatrix4(t),e.needsUpdate=!0);const r=this.attributes.normal;if(void 0!==r){const e=(new c.V).getNormalMatrix(t);r.applyNormalMatrix(e),r.needsUpdate=!0}const i=this.attributes.tangent;return void 0!==i&&(i.transformDirection(t),i.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(t){return p.makeRotationFromQuaternion(t),this.applyMatrix4(p),this}rotateX(t){return p.makeRotationX(t),this.applyMatrix4(p),this}rotateY(t){return p.makeRotationY(t),this.applyMatrix4(p),this}rotateZ(t){return p.makeRotationZ(t),this.applyMatrix4(p),this}translate(t,e,r){return p.makeTranslation(t,e,r),this.applyMatrix4(p),this}scale(t,e,r){return p.makeScale(t,e,r),this.applyMatrix4(p),this}lookAt(t){return y.lookAt(t),y.updateMatrix(),this.applyMatrix4(y.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(g).negate(),this.translate(g.x,g.y,g.z),this}setFromPoints(t){const e=[];for(let r=0,i=t.length;r<i;r++){const i=t[r];e.push(i.x,i.y,i.z||0)}return this.setAttribute("position",new a.a$(e,3)),this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new o.Box3);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingBox.set(new i.Vector3(-1/0,-1/0,-1/0),new i.Vector3(1/0,1/0,1/0));if(void 0!==t){if(this.boundingBox.setFromBufferAttribute(t),e)for(let t=0,r=e.length;t<r;t++){const r=e[t];b.setFromBufferAttribute(r),this.morphTargetsRelative?(A.addVectors(this.boundingBox.min,b.min),this.boundingBox.expandByPoint(A),A.addVectors(this.boundingBox.max,b.max),this.boundingBox.expandByPoint(A)):(this.boundingBox.expandByPoint(b.min),this.boundingBox.expandByPoint(b.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new u.Sphere);const t=this.attributes.position,e=this.morphAttributes.position;if(t&&t.isGLBufferAttribute)return console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),void this.boundingSphere.set(new i.Vector3,1/0);if(t){const r=this.boundingSphere.center;if(b.setFromBufferAttribute(t),e)for(let t=0,r=e.length;t<r;t++){const r=e[t];x.setFromBufferAttribute(r),this.morphTargetsRelative?(A.addVectors(b.min,x.min),b.expandByPoint(A),A.addVectors(b.max,x.max),b.expandByPoint(A)):(b.expandByPoint(x.min),b.expandByPoint(x.max))}b.getCenter(r);let i=0;for(let e=0,s=t.count;e<s;e++)A.fromBufferAttribute(t,e),i=Math.max(i,r.distanceToSquared(A));if(e)for(let s=0,o=e.length;s<o;s++){const o=e[s],n=this.morphTargetsRelative;for(let e=0,s=o.count;e<s;e++)A.fromBufferAttribute(o,e),n&&(g.fromBufferAttribute(t,e),A.add(g)),i=Math.max(i,r.distanceToSquared(A))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const t=this.index,e=this.attributes;if(null===t||void 0===e.position||void 0===e.normal||void 0===e.uv)return void console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const r=t.array,o=e.position.array,n=e.normal.array,u=e.uv.array,h=o.length/3;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new a.Tl(new Float32Array(4*h),4));const l=this.getAttribute("tangent").array,c=[],d=[];for(let t=0;t<h;t++)c[t]=new i.Vector3,d[t]=new i.Vector3;const f=new i.Vector3,m=new i.Vector3,p=new i.Vector3,y=new s.Vector2,g=new s.Vector2,b=new s.Vector2,x=new i.Vector3,A=new i.Vector3;function B(t,e,r){f.fromArray(o,3*t),m.fromArray(o,3*e),p.fromArray(o,3*r),y.fromArray(u,2*t),g.fromArray(u,2*e),b.fromArray(u,2*r),m.sub(f),p.sub(f),g.sub(y),b.sub(y);const i=1/(g.x*b.y-b.x*g.y);isFinite(i)&&(x.copy(m).multiplyScalar(b.y).addScaledVector(p,-g.y).multiplyScalar(i),A.copy(p).multiplyScalar(g.x).addScaledVector(m,-b.x).multiplyScalar(i),c[t].add(x),c[e].add(x),c[r].add(x),d[t].add(A),d[e].add(A),d[r].add(A))}let w=this.groups;0===w.length&&(w=[{start:0,count:r.length}]);for(let t=0,e=w.length;t<e;++t){const e=w[t],i=e.start;for(let t=i,s=i+e.count;t<s;t+=3)B(r[t+0],r[t+1],r[t+2])}const S=new i.Vector3,v=new i.Vector3,z=new i.Vector3,V=new i.Vector3;function R(t){z.fromArray(n,3*t),V.copy(z);const e=c[t];S.copy(e),S.sub(z.multiplyScalar(z.dot(e))).normalize(),v.crossVectors(V,e);const r=v.dot(d[t])<0?-1:1;l[4*t]=S.x,l[4*t+1]=S.y,l[4*t+2]=S.z,l[4*t+3]=r}for(let t=0,e=w.length;t<e;++t){const e=w[t],i=e.start;for(let t=i,s=i+e.count;t<s;t+=3)R(r[t+0]),R(r[t+1]),R(r[t+2])}}computeVertexNormals(){const t=this.index,e=this.getAttribute("position");if(void 0!==e){let r=this.getAttribute("normal");if(void 0===r)r=new a.Tl(new Float32Array(3*e.count),3),this.setAttribute("normal",r);else for(let t=0,e=r.count;t<e;t++)r.setXYZ(t,0,0,0);const s=new i.Vector3,o=new i.Vector3,n=new i.Vector3,u=new i.Vector3,h=new i.Vector3,l=new i.Vector3,c=new i.Vector3,d=new i.Vector3;if(t)for(let i=0,a=t.count;i<a;i+=3){const a=t.getX(i+0),f=t.getX(i+1),m=t.getX(i+2);s.fromBufferAttribute(e,a),o.fromBufferAttribute(e,f),n.fromBufferAttribute(e,m),c.subVectors(n,o),d.subVectors(s,o),c.cross(d),u.fromBufferAttribute(r,a),h.fromBufferAttribute(r,f),l.fromBufferAttribute(r,m),u.add(c),h.add(c),l.add(c),r.setXYZ(a,u.x,u.y,u.z),r.setXYZ(f,h.x,h.y,h.z),r.setXYZ(m,l.x,l.y,l.z)}else for(let t=0,i=e.count;t<i;t+=3)s.fromBufferAttribute(e,t+0),o.fromBufferAttribute(e,t+1),n.fromBufferAttribute(e,t+2),c.subVectors(n,o),d.subVectors(s,o),c.cross(d),r.setXYZ(t+0,c.x,c.y,c.z),r.setXYZ(t+1,c.x,c.y,c.z),r.setXYZ(t+2,c.x,c.y,c.z);this.normalizeNormals(),r.needsUpdate=!0}}merge(t,e){if(!t||!t.isBufferGeometry)return void console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",t);void 0===e&&(e=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));const r=this.attributes;for(const i in r){if(void 0===t.attributes[i])continue;const s=r[i].array,o=t.attributes[i],n=o.array,a=o.itemSize*e,u=Math.min(n.length,s.length-a);for(let t=0,e=a;t<u;t++,e++)s[e]=n[t]}return this}normalizeNormals(){const t=this.attributes.normal;for(let e=0,r=t.count;e<r;e++)A.fromBufferAttribute(t,e),A.normalize(),t.setXYZ(e,A.x,A.y,A.z)}toNonIndexed(){function t(t,e){const r=t.array,i=t.itemSize,s=t.normalized,o=new r.constructor(e.length*i);let n=0,u=0;for(let s=0,a=e.length;s<a;s++){n=t.isInterleavedBufferAttribute?e[s]*t.data.stride+t.offset:e[s]*i;for(let t=0;t<i;t++)o[u++]=r[n++]}return new a.Tl(o,i,s)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const e=new B,r=this.index.array,i=this.attributes;for(const s in i){const o=t(i[s],r);e.setAttribute(s,o)}const s=this.morphAttributes;for(const i in s){const o=[],n=s[i];for(let e=0,i=n.length;e<i;e++){const i=t(n[e],r);o.push(i)}e.morphAttributes[i]=o}e.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let t=0,r=o.length;t<r;t++){const r=o[t];e.addGroup(r.start,r.count,r.materialIndex)}return e}toJSON(){const t={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(t.uuid=this.uuid,t.type=this.type,""!==this.name&&(t.name=this.name),Object.keys(this.userData).length>0&&(t.userData=this.userData),void 0!==this.parameters){const e=this.parameters;for(const r in e)void 0!==e[r]&&(t[r]=e[r]);return t}t.data={attributes:{}};const e=this.index;null!==e&&(t.data.index={type:e.array.constructor.name,array:Array.prototype.slice.call(e.array)});const r=this.attributes;for(const e in r){const i=r[e];t.data.attributes[e]=i.toJSON(t.data)}const i={};let s=!1;for(const e in this.morphAttributes){const r=this.morphAttributes[e],o=[];for(let e=0,i=r.length;e<i;e++){const i=r[e];o.push(i.toJSON(t.data))}o.length>0&&(i[e]=o,s=!0)}s&&(t.data.morphAttributes=i,t.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(t.data.groups=JSON.parse(JSON.stringify(o)));const n=this.boundingSphere;return null!==n&&(t.data.boundingSphere={center:n.center.toArray(),radius:n.radius}),t}clone(){return(new this.constructor).copy(this)}copy(t){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const e={};this.name=t.name;const r=t.index;null!==r&&this.setIndex(r.clone(e));const i=t.attributes;for(const t in i){const r=i[t];this.setAttribute(t,r.clone(e))}const s=t.morphAttributes;for(const t in s){const r=[],i=s[t];for(let t=0,s=i.length;t<s;t++)r.push(i[t].clone(e));this.morphAttributes[t]=r}this.morphTargetsRelative=t.morphTargetsRelative;const o=t.groups;for(let t=0,e=o.length;t<e;t++){const e=o[t];this.addGroup(e.start,e.count,e.materialIndex)}const n=t.boundingBox;null!==n&&(this.boundingBox=n.clone());const a=t.boundingSphere;return null!==a&&(this.boundingSphere=a.clone()),this.drawRange.start=t.drawRange.start,this.drawRange.count=t.drawRange.count,this.userData=t.userData,void 0!==t.parameters&&(this.parameters=Object.assign({},t.parameters)),this}dispose(){this.dispatchEvent({type:"dispose"})}}B.prototype.isBufferGeometry=!0},5042:(t,e,r)=>{function i(t){for(let e=t.length-1;e>=0;--e)if(t[e]>65535)return!0;return!1}function s(t){return document.createElementNS("http://www.w3.org/1999/xhtml",t)}r.d(e,{H7:()=>i,c:()=>s}),Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array}}]);