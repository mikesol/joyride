"use strict";(self.webpackChunkjoyride=self.webpackChunkjoyride||[]).push([[344],{7033:(t,e,r)=>{r.r(e),r.d(e,{InstancedMesh:()=>l});var s=r(4430);class i extends s.Tl{constructor(t,e,r,s=1){"number"==typeof r&&(s=r,r=!1,console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")),super(t,e,r),this.meshPerAttribute=s}copy(t){return super.copy(t),this.meshPerAttribute=t.meshPerAttribute,this}toJSON(){const t=super.toJSON();return t.meshPerAttribute=this.meshPerAttribute,t.isInstancedBufferAttribute=!0,t}}i.prototype.isInstancedBufferAttribute=!0;var n=r(9150),a=r(1245);const o=new a.Matrix4,c=new a.Matrix4,h=[],u=new n.Mesh;class l extends n.Mesh{constructor(t,e,r){super(t,e),this.instanceMatrix=new i(new Float32Array(16*r),16),this.instanceColor=null,this.count=r,this.frustumCulled=!1}copy(t){return super.copy(t),this.instanceMatrix.copy(t.instanceMatrix),null!==t.instanceColor&&(this.instanceColor=t.instanceColor.clone()),this.count=t.count,this}getColorAt(t,e){e.fromArray(this.instanceColor.array,3*t)}getMatrixAt(t,e){e.fromArray(this.instanceMatrix.array,16*t)}raycast(t,e){const r=this.matrixWorld,s=this.count;if(u.geometry=this.geometry,u.material=this.material,void 0!==u.material)for(let i=0;i<s;i++){this.getMatrixAt(i,o),c.multiplyMatrices(r,o),u.matrixWorld=c,u.raycast(t,h);for(let t=0,r=h.length;t<r;t++){const r=h[t];r.instanceId=i,r.object=this,e.push(r)}h.length=0}}setColorAt(t,e){null===this.instanceColor&&(this.instanceColor=new i(new Float32Array(3*this.instanceMatrix.count),3)),e.toArray(this.instanceColor.array,3*t)}setMatrixAt(t,e){e.toArray(this.instanceMatrix.array,16*t)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}l.prototype.isInstancedMesh=!0}}]);