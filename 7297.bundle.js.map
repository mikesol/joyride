{"version":3,"file":"7297.bundle.js","mappings":"2bAmCA,MAAMA,EAELC,cAECC,KAAKC,KAAO,QAEZD,KAAKE,mBAAqB,IAO3BC,WAGC,OADAC,QAAQC,KAAM,6CACP,KAORC,WAAYC,EAAGC,GAEd,MAAMC,EAAIT,KAAKU,eAAgBH,GAC/B,OAAOP,KAAKG,SAAUM,EAAGD,GAM1BG,UAAWC,EAAY,GAEtB,MAAMC,EAAS,GAEf,IAAM,IAAIC,EAAI,EAAGA,GAAKF,EAAWE,IAEhCD,EAAOE,KAAMf,KAAKG,SAAUW,EAAIF,IAIjC,OAAOC,EAMRG,gBAAiBJ,EAAY,GAE5B,MAAMC,EAAS,GAEf,IAAM,IAAIC,EAAI,EAAGA,GAAKF,EAAWE,IAEhCD,EAAOE,KAAMf,KAAKM,WAAYQ,EAAIF,IAInC,OAAOC,EAMRI,YAEC,MAAMC,EAAUlB,KAAKmB,aACrB,OAAOD,EAASA,EAAQE,OAAS,GAMlCD,WAAYP,EAAYZ,KAAKE,oBAE5B,GAAKF,KAAKqB,iBACPrB,KAAKqB,gBAAgBD,SAAWR,EAAY,IAC5CZ,KAAKsB,YAEP,OAAOtB,KAAKqB,gBAIbrB,KAAKsB,aAAc,EAEnB,MAAMC,EAAQ,GACd,IAAIC,EAASC,EAAOzB,KAAKG,SAAU,GAC/BuB,EAAM,EAEVH,EAAMR,KAAM,GAEZ,IAAM,IAAIY,EAAI,EAAGA,GAAKf,EAAWe,IAEhCH,EAAUxB,KAAKG,SAAUwB,EAAIf,GAC7Bc,GAAOF,EAAQI,WAAYH,GAC3BF,EAAMR,KAAMW,GACZD,EAAOD,EAMR,OAFAxB,KAAKqB,gBAAkBE,EAEhBA,EAIRM,mBAEC7B,KAAKsB,aAAc,EACnBtB,KAAKmB,aAMNT,eAAgBH,EAAGuB,GAElB,MAAMC,EAAa/B,KAAKmB,aAExB,IAAIa,EAAI,EACR,MAAMC,EAAKF,EAAWX,OAEtB,IAAIc,EAIHA,EAFIJ,GAMcvB,EAAIwB,EAAYE,EAAK,GAMxC,IAA4BE,EAAxBC,EAAM,EAAGC,EAAOJ,EAAK,EAEzB,KAAQG,GAAOC,GAMd,GAJAL,EAAIM,KAAKC,MAAOH,GAAQC,EAAOD,GAAQ,GAEvCD,EAAaJ,EAAYC,GAAME,EAE1BC,EAAa,EAEjBC,EAAMJ,EAAI,MAEJ,MAAKG,EAAa,GAIlB,CAENE,EAAOL,EACP,MALAK,EAAOL,EAAI,EAeb,GAFAA,EAAIK,EAECN,EAAYC,KAAQE,EAExB,OAAOF,GAAMC,EAAK,GAMnB,MAAMO,EAAeT,EAAYC,GAajC,OAFYA,GAJcE,EAAkBM,IANxBT,EAAYC,EAAI,GAEAQ,KAQEP,EAAK,GAW5CQ,WAAYhC,EAAGD,GAEd,MAAMkC,EAAQ,KACd,IAAIC,EAAKlC,EAAIiC,EACTE,EAAKnC,EAAIiC,EAIRC,EAAK,IAAIA,EAAK,GACdC,EAAK,IAAIA,EAAK,GAEnB,MAAMC,EAAM7C,KAAKG,SAAUwC,GACrBG,EAAM9C,KAAKG,SAAUyC,GAErBG,EAAUvC,IAAsBqC,EAAc,UAAI,IAAIG,EAAAA,QAAY,IAAIC,EAAAA,SAI5E,OAFAF,EAAQG,KAAMJ,GAAMK,IAAKN,GAAMO,YAExBL,EAIRM,aAAc9C,EAAGC,GAEhB,MAAMC,EAAIT,KAAKU,eAAgBH,GAC/B,OAAOP,KAAKyC,WAAYhC,EAAGD,GAI5B8C,oBAAqBC,EAAUC,GAI9B,MAAMC,EAAS,IAAIR,EAAAA,QAEbS,EAAW,GACXC,EAAU,GACVC,EAAY,GAEZC,EAAM,IAAIZ,EAAAA,QACVa,EAAM,IAAIC,EAAAA,QAIhB,IAAM,IAAI/B,EAAI,EAAGA,GAAKuB,EAAUvB,IAAO,CAEtC,MAAMzB,EAAIyB,EAAIuB,EAEdG,EAAU1B,GAAMhC,KAAKqD,aAAc9C,EAAG,IAAI0C,EAAAA,SAO3CU,EAAS,GAAM,IAAIV,EAAAA,QACnBW,EAAW,GAAM,IAAIX,EAAAA,QACrB,IAAIe,EAAMC,OAAOC,UACjB,MAAMC,EAAK7B,KAAK8B,IAAKV,EAAU,GAAIW,GAC7BC,EAAKhC,KAAK8B,IAAKV,EAAU,GAAIa,GAC7BC,EAAKlC,KAAK8B,IAAKV,EAAU,GAAIe,GAE9BN,GAAMH,IAEVA,EAAMG,EACNV,EAAOiB,IAAK,EAAG,EAAG,IAIdJ,GAAMN,IAEVA,EAAMM,EACNb,EAAOiB,IAAK,EAAG,EAAG,IAIdF,GAAMR,GAEVP,EAAOiB,IAAK,EAAG,EAAG,GAInBb,EAAIc,aAAcjB,EAAU,GAAKD,GAASL,YAE1CO,EAAS,GAAIgB,aAAcjB,EAAU,GAAKG,GAC1CD,EAAW,GAAIe,aAAcjB,EAAU,GAAKC,EAAS,IAKrD,IAAM,IAAI3B,EAAI,EAAGA,GAAKuB,EAAUvB,IAAO,CAQtC,GANA2B,EAAS3B,GAAM2B,EAAS3B,EAAI,GAAI4C,QAEhChB,EAAW5B,GAAM4B,EAAW5B,EAAI,GAAI4C,QAEpCf,EAAIc,aAAcjB,EAAU1B,EAAI,GAAK0B,EAAU1B,IAE1C6B,EAAIzC,SAAW6C,OAAOY,QAAU,CAEpChB,EAAIT,YAEJ,MAAM0B,EAAQxC,KAAKyC,KAAMC,EAAA,GAAiBtB,EAAU1B,EAAI,GAAIiD,IAAKvB,EAAU1B,KAAS,EAAG,IAEvF2B,EAAS3B,GAAIkD,aAAcpB,EAAIqB,iBAAkBtB,EAAKiB,IAIvDlB,EAAW5B,GAAI2C,aAAcjB,EAAU1B,GAAK2B,EAAS3B,IAMtD,IAAgB,IAAXwB,EAAkB,CAEtB,IAAIsB,EAAQxC,KAAKyC,KAAMC,EAAA,GAAiBrB,EAAS,GAAIsB,IAAKtB,EAASJ,KAAgB,EAAG,IACtFuB,GAASvB,EAEJG,EAAU,GAAIuB,IAAKpB,EAAIc,aAAchB,EAAS,GAAKA,EAASJ,KAAiB,IAEjFuB,GAAUA,GAIX,IAAM,IAAI9C,EAAI,EAAGA,GAAKuB,EAAUvB,IAG/B2B,EAAS3B,GAAIkD,aAAcpB,EAAIqB,iBAAkBzB,EAAU1B,GAAK8C,EAAQ9C,IACxE4B,EAAW5B,GAAI2C,aAAcjB,EAAU1B,GAAK2B,EAAS3B,IAMvD,MAAO,CACN0B,SAAUA,EACVC,QAASA,EACTC,UAAWA,GAKbgB,QAEC,OAAO,IAAI5E,KAAKD,aAAcmD,KAAMlD,MAIrCkD,KAAMkC,GAIL,OAFApF,KAAKE,mBAAqBkF,EAAOlF,mBAE1BF,KAIRqF,SAEC,MAAMC,EAAO,CACZC,SAAU,CACTC,QAAS,IACTvF,KAAM,QACNwF,UAAW,iBAOb,OAHAH,EAAKpF,mBAAqBF,KAAKE,mBAC/BoF,EAAKrF,KAAOD,KAAKC,KAEVqF,EAIRI,SAAUC,GAIT,OAFA3F,KAAKE,mBAAqByF,EAAKzF,mBAExBF,MCrZT,MAAM4F,UAAqB9F,EAE1BC,YAAa8F,EAAK,EAAGC,EAAK,EAAGC,EAAU,EAAGC,EAAU,EAAGC,EAAc,EAAGC,EAAsB,EAAV5D,KAAK6D,GAAQC,GAAa,EAAOC,EAAY,GAEhIC,QAEAtG,KAAKC,KAAO,eAEZD,KAAK6F,GAAKA,EACV7F,KAAK8F,GAAKA,EAEV9F,KAAK+F,QAAUA,EACf/F,KAAKgG,QAAUA,EAEfhG,KAAKiG,YAAcA,EACnBjG,KAAKkG,UAAYA,EAEjBlG,KAAKoG,WAAaA,EAElBpG,KAAKqG,UAAYA,EAIlBlG,SAAUM,EAAGD,GAEZ,MAAM+F,EAAQ/F,GAAkB,IAAIwC,EAAAA,QAE9BwD,EAAkB,EAAVlE,KAAK6D,GACnB,IAAIM,EAAazG,KAAKkG,UAAYlG,KAAKiG,YACvC,MAAMS,EAAapE,KAAK8B,IAAKqC,GAAexC,OAAOY,QAGnD,KAAQ4B,EAAa,GAAIA,GAAcD,EACvC,KAAQC,EAAaD,GAAQC,GAAcD,EAEtCC,EAAaxC,OAAOY,UAIvB4B,EAFIC,EAES,EAIAF,IAMU,IAApBxG,KAAKoG,YAAyBM,IAE7BD,IAAeD,EAEnBC,GAAeD,EAIfC,GAA0BD,GAM5B,MAAMG,EAAQ3G,KAAKiG,YAAcxF,EAAIgG,EACrC,IAAIpC,EAAIrE,KAAK6F,GAAK7F,KAAK+F,QAAUzD,KAAKsE,IAAKD,GACvCpC,EAAIvE,KAAK8F,GAAK9F,KAAKgG,QAAU1D,KAAKuE,IAAKF,GAE3C,GAAwB,IAAnB3G,KAAKqG,UAAkB,CAE3B,MAAMO,EAAMtE,KAAKsE,IAAK5G,KAAKqG,WACrBQ,EAAMvE,KAAKuE,IAAK7G,KAAKqG,WAErBlC,EAAKE,EAAIrE,KAAK6F,GACdvB,EAAKC,EAAIvE,KAAK8F,GAGpBzB,EAAIF,EAAKyC,EAAMtC,EAAKuC,EAAM7G,KAAK6F,GAC/BtB,EAAIJ,EAAK0C,EAAMvC,EAAKsC,EAAM5G,KAAK8F,GAIhC,OAAOS,EAAM7B,IAAKL,EAAGE,GAItBrB,KAAMkC,GAiBL,OAfAkB,MAAMpD,KAAMkC,GAEZpF,KAAK6F,GAAKT,EAAOS,GACjB7F,KAAK8F,GAAKV,EAAOU,GAEjB9F,KAAK+F,QAAUX,EAAOW,QACtB/F,KAAKgG,QAAUZ,EAAOY,QAEtBhG,KAAKiG,YAAcb,EAAOa,YAC1BjG,KAAKkG,UAAYd,EAAOc,UAExBlG,KAAKoG,WAAahB,EAAOgB,WAEzBpG,KAAKqG,UAAYjB,EAAOiB,UAEjBrG,KAIRqF,SAEC,MAAMC,EAAOgB,MAAMjB,SAenB,OAbAC,EAAKO,GAAK7F,KAAK6F,GACfP,EAAKQ,GAAK9F,KAAK8F,GAEfR,EAAKS,QAAU/F,KAAK+F,QACpBT,EAAKU,QAAUhG,KAAKgG,QAEpBV,EAAKW,YAAcjG,KAAKiG,YACxBX,EAAKY,UAAYlG,KAAKkG,UAEtBZ,EAAKc,WAAapG,KAAKoG,WAEvBd,EAAKe,UAAYrG,KAAKqG,UAEff,EAIRI,SAAUC,GAiBT,OAfAW,MAAMZ,SAAUC,GAEhB3F,KAAK6F,GAAKF,EAAKE,GACf7F,KAAK8F,GAAKH,EAAKG,GAEf9F,KAAK+F,QAAUJ,EAAKI,QACpB/F,KAAKgG,QAAUL,EAAKK,QAEpBhG,KAAKiG,YAAcN,EAAKM,YACxBjG,KAAKkG,UAAYP,EAAKO,UAEtBlG,KAAKoG,WAAaT,EAAKS,WAEvBpG,KAAKqG,UAAYV,EAAKU,UAEfrG,MAMT4F,EAAakB,UAAUC,gBAAiB,ECvJxC,MAAMC,UAAiBpB,EAEtB7F,YAAa8F,EAAIC,EAAImB,EAAShB,EAAaC,EAAWE,GAErDE,MAAOT,EAAIC,EAAImB,EAASA,EAAShB,EAAaC,EAAWE,GAEzDpG,KAAKC,KAAO,YCed,SAASiH,IAER,IAAIC,EAAK,EAAGC,EAAK,EAAGC,EAAK,EAAGC,EAAK,EAUjC,SAASC,EAAMC,EAAIC,EAAIC,EAAI/E,GAE1BwE,EAAKK,EACLJ,EAAKM,EACLL,GAAO,EAAIG,EAAK,EAAIC,EAAK,EAAIC,EAAK/E,EAClC2E,EAAK,EAAIE,EAAK,EAAIC,EAAKC,EAAK/E,EAI7B,MAAO,CAENgF,eAAgB,SAAWH,EAAIC,EAAIG,EAAIC,EAAIC,GAE1CP,EAAME,EAAIG,EAAIE,GAAYF,EAAKJ,GAAMM,GAAYD,EAAKJ,KAIvDM,yBAA0B,SAAWP,EAAIC,EAAIG,EAAIC,EAAIG,EAAKC,EAAKC,GAG9D,IAAIvF,GAAO8E,EAAKD,GAAOQ,GAAQJ,EAAKJ,IAASQ,EAAMC,IAAUL,EAAKH,GAAOQ,EACrErF,GAAOgF,EAAKH,GAAOQ,GAAQJ,EAAKJ,IAASQ,EAAMC,IAAUL,EAAKD,GAAOM,EAGzEvF,GAAMsF,EACNrF,GAAMqF,EAENV,EAAME,EAAIG,EAAIjF,EAAIC,IAInBuF,KAAM,SAAW1H,GAEhB,MAAMmC,EAAKnC,EAAIA,EAEf,OAAO0G,EAAKC,EAAK3G,EAAI4G,EAAKzE,EAAK0E,GADpB1E,EAAKnC,KDvDnBuG,EAASF,UAAUsB,YAAa,ECkEhC,MAAMC,EAAM,IAAIpF,EAAAA,QACVqF,EAAK,IAAIpB,EAAaqB,EAAK,IAAIrB,EAAasB,EAAK,IAAItB,EAE3D,MAAMuB,UAAyB3I,EAE9BC,YAAac,EAAS,GAAI2C,GAAS,EAAOkF,EAAY,cAAeZ,EAAU,IAE9ExB,QAEAtG,KAAKC,KAAO,mBAEZD,KAAKa,OAASA,EACdb,KAAKwD,OAASA,EACdxD,KAAK0I,UAAYA,EACjB1I,KAAK8H,QAAUA,EAIhB3H,SAAUM,EAAGD,EAAiB,IAAIyC,EAAAA,SAEjC,MAAMsD,EAAQ/F,EAERK,EAASb,KAAKa,OACd8H,EAAI9H,EAAOO,OAEXO,GAAMgH,GAAM3I,KAAKwD,OAAS,EAAI,IAAQ/C,EAC5C,IAcImI,EAAIC,EAdJC,EAAWxG,KAAKC,MAAOZ,GACvBoH,EAASpH,EAAImH,EAEZ9I,KAAKwD,OAETsF,GAAYA,EAAW,EAAI,GAAMxG,KAAKC,MAAOD,KAAK8B,IAAK0E,GAAaH,GAAM,GAAMA,EAE1D,IAAXI,GAAgBD,IAAaH,EAAI,IAE5CG,EAAWH,EAAI,EACfI,EAAS,GAML/I,KAAKwD,QAAUsF,EAAW,EAE9BF,EAAK/H,GAAUiI,EAAW,GAAMH,IAKhCN,EAAIW,WAAYnI,EAAQ,GAAKA,EAAQ,IAAMoI,IAAKpI,EAAQ,IACxD+H,EAAKP,GAIN,MAAMa,EAAKrI,EAAQiI,EAAWH,GACxBQ,EAAKtI,GAAUiI,EAAW,GAAMH,GActC,GAZK3I,KAAKwD,QAAUsF,EAAW,EAAIH,EAElCE,EAAKhI,GAAUiI,EAAW,GAAMH,IAKhCN,EAAIW,WAAYnI,EAAQ8H,EAAI,GAAK9H,EAAQ8H,EAAI,IAAMM,IAAKpI,EAAQ8H,EAAI,IACpEE,EAAKR,GAIkB,gBAAnBrI,KAAK0I,WAAkD,YAAnB1I,KAAK0I,UAA0B,CAGvE,MAAMU,EAAyB,YAAnBpJ,KAAK0I,UAA0B,GAAM,IACjD,IAAIV,EAAM1F,KAAK8G,IAAKR,EAAGS,kBAAmBH,GAAME,GAC5CnB,EAAM3F,KAAK8G,IAAKF,EAAGG,kBAAmBF,GAAMC,GAC5ClB,EAAM5F,KAAK8G,IAAKD,EAAGE,kBAAmBR,GAAMO,GAG3CnB,EAAM,OAAOA,EAAM,GACnBD,EAAM,OAAOA,EAAMC,GACnBC,EAAM,OAAOA,EAAMD,GAExBK,EAAGP,yBAA0Ba,EAAGvE,EAAG6E,EAAG7E,EAAG8E,EAAG9E,EAAGwE,EAAGxE,EAAG2D,EAAKC,EAAKC,GAC/DK,EAAGR,yBAA0Ba,EAAGrE,EAAG2E,EAAG3E,EAAG4E,EAAG5E,EAAGsE,EAAGtE,EAAGyD,EAAKC,EAAKC,GAC/DM,EAAGT,yBAA0Ba,EAAGnE,EAAGyE,EAAGzE,EAAG0E,EAAG1E,EAAGoE,EAAGpE,EAAGuD,EAAKC,EAAKC,OAEjC,eAAnBlI,KAAK0I,YAEhBJ,EAAGX,eAAgBiB,EAAGvE,EAAG6E,EAAG7E,EAAG8E,EAAG9E,EAAGwE,EAAGxE,EAAGrE,KAAK8H,SAChDS,EAAGZ,eAAgBiB,EAAGrE,EAAG2E,EAAG3E,EAAG4E,EAAG5E,EAAGsE,EAAGtE,EAAGvE,KAAK8H,SAChDU,EAAGb,eAAgBiB,EAAGnE,EAAGyE,EAAGzE,EAAG0E,EAAG1E,EAAGoE,EAAGpE,EAAGzE,KAAK8H,UAUjD,OANAvB,EAAM7B,IACL4D,EAAGH,KAAMY,GACTR,EAAGJ,KAAMY,GACTP,EAAGL,KAAMY,IAGHxC,EAIRrD,KAAMkC,GAELkB,MAAMpD,KAAMkC,GAEZpF,KAAKa,OAAS,GAEd,IAAM,IAAImB,EAAI,EAAG2G,EAAIvD,EAAOvE,OAAOO,OAAQY,EAAI2G,EAAG3G,IAAO,CAExD,MAAMuE,EAAQnB,EAAOvE,OAAQmB,GAE7BhC,KAAKa,OAAOE,KAAMwF,EAAM3B,SAQzB,OAJA5E,KAAKwD,OAAS4B,EAAO5B,OACrBxD,KAAK0I,UAAYtD,EAAOsD,UACxB1I,KAAK8H,QAAU1C,EAAO0C,QAEf9H,KAIRqF,SAEC,MAAMC,EAAOgB,MAAMjB,SAEnBC,EAAKzE,OAAS,GAEd,IAAM,IAAImB,EAAI,EAAG2G,EAAI3I,KAAKa,OAAOO,OAAQY,EAAI2G,EAAG3G,IAAO,CAEtD,MAAMuE,EAAQvG,KAAKa,OAAQmB,GAC3BsD,EAAKzE,OAAOE,KAAMwF,EAAM+C,WAQzB,OAJAhE,EAAK9B,OAASxD,KAAKwD,OACnB8B,EAAKoD,UAAY1I,KAAK0I,UACtBpD,EAAKwC,QAAU9H,KAAK8H,QAEbxC,EAIRI,SAAUC,GAETW,MAAMZ,SAAUC,GAEhB3F,KAAKa,OAAS,GAEd,IAAM,IAAImB,EAAI,EAAG2G,EAAIhD,EAAK9E,OAAOO,OAAQY,EAAI2G,EAAG3G,IAAO,CAEtD,MAAMuE,EAAQZ,EAAK9E,OAAQmB,GAC3BhC,KAAKa,OAAOE,MAAM,IAAIkC,EAAAA,SAAUsG,UAAWhD,IAQ5C,OAJAvG,KAAKwD,OAASmC,EAAKnC,OACnBxD,KAAK0I,UAAY/C,EAAK+C,UACtB1I,KAAK8H,QAAUnC,EAAKmC,QAEb9H,MC/OT,SAASwJ,EAAY/I,EAAGmI,EAAIM,EAAIC,EAAIN,GAEnC,MAAMY,EAAmB,IAAZN,EAAKP,GACZc,EAAmB,IAAZb,EAAKK,GACZtG,EAAKnC,EAAIA,EAEf,OAAS,EAAIyI,EAAK,EAAIC,EAAKM,EAAKC,IADrBjJ,EAAImC,KACiC,EAAIsG,EAAK,EAAIC,EAAK,EAAIM,EAAKC,GAAO9G,EAAK6G,EAAKhJ,EAAIyI,EAyBjG,SAASS,EAAiBlJ,EAAGmI,EAAIM,EAAIC,GAEpC,OArBD,SAA4B1I,EAAGkB,GAE9B,MAAMiI,EAAI,EAAInJ,EACd,OAAOmJ,EAAIA,EAAIjI,EAkBRkI,CAAmBpJ,EAAGmI,GAd9B,SAA4BnI,EAAGkB,GAE9B,OAAO,GAAM,EAAIlB,GAAMA,EAAIkB,EAYSmI,CAAmBrJ,EAAGyI,GAR3D,SAA4BzI,EAAGkB,GAE9B,OAAOlB,EAAIA,EAAIkB,EAOdoI,CAAmBtJ,EAAG0I,GAgCxB,SAASa,EAAavJ,EAAGmI,EAAIM,EAAIC,EAAIN,GAEpC,OA5BD,SAAwBpI,EAAGkB,GAE1B,MAAMiI,EAAI,EAAInJ,EACd,OAAOmJ,EAAIA,EAAIA,EAAIjI,EAyBZsI,CAAexJ,EAAGmI,GArB1B,SAAwBnI,EAAGkB,GAE1B,MAAMiI,EAAI,EAAInJ,EACd,OAAO,EAAImJ,EAAIA,EAAInJ,EAAIkB,EAkBSuI,CAAezJ,EAAGyI,GAdnD,SAAwBzI,EAAGkB,GAE1B,OAAO,GAAM,EAAIlB,GAAMA,EAAIA,EAAIkB,EAY0BwI,CAAe1J,EAAG0I,GAR5E,SAAwB1I,EAAGkB,GAE1B,OAAOlB,EAAIA,EAAIA,EAAIkB,EAOlByI,CAAe3J,EAAGoI,GDgLpBJ,EAAiB3B,UAAUuD,oBAAqB,EEtPhD,MAAMC,UAAyBxK,EAE9BC,YAAa0J,EAAK,IAAIzG,EAAAA,QAAW0G,EAAK,IAAI1G,EAAAA,QAAWuH,EAAK,IAAIvH,EAAAA,QAAWwH,EAAK,IAAIxH,EAAAA,SAEjFsD,QAEAtG,KAAKC,KAAO,mBAEZD,KAAKyJ,GAAKA,EACVzJ,KAAK0J,GAAKA,EACV1J,KAAKuK,GAAKA,EACVvK,KAAKwK,GAAKA,EAIXrK,SAAUM,EAAGD,EAAiB,IAAIwC,EAAAA,SAEjC,MAAMuD,EAAQ/F,EAERiJ,EAAKzJ,KAAKyJ,GAAIC,EAAK1J,KAAK0J,GAAIa,EAAKvK,KAAKuK,GAAIC,EAAKxK,KAAKwK,GAO1D,OALAjE,EAAM7B,IACLsF,EAAavJ,EAAGgJ,EAAGpF,EAAGqF,EAAGrF,EAAGkG,EAAGlG,EAAGmG,EAAGnG,GACrC2F,EAAavJ,EAAGgJ,EAAGlF,EAAGmF,EAAGnF,EAAGgG,EAAGhG,EAAGiG,EAAGjG,IAG/BgC,EAIRrD,KAAMkC,GASL,OAPAkB,MAAMpD,KAAMkC,GAEZpF,KAAKyJ,GAAGvG,KAAMkC,EAAOqE,IACrBzJ,KAAK0J,GAAGxG,KAAMkC,EAAOsE,IACrB1J,KAAKuK,GAAGrH,KAAMkC,EAAOmF,IACrBvK,KAAKwK,GAAGtH,KAAMkC,EAAOoF,IAEdxK,KAIRqF,SAEC,MAAMC,EAAOgB,MAAMjB,SAOnB,OALAC,EAAKmE,GAAKzJ,KAAKyJ,GAAGH,UAClBhE,EAAKoE,GAAK1J,KAAK0J,GAAGJ,UAClBhE,EAAKiF,GAAKvK,KAAKuK,GAAGjB,UAClBhE,EAAKkF,GAAKxK,KAAKwK,GAAGlB,UAEXhE,EAIRI,SAAUC,GAST,OAPAW,MAAMZ,SAAUC,GAEhB3F,KAAKyJ,GAAGF,UAAW5D,EAAK8D,IACxBzJ,KAAK0J,GAAGH,UAAW5D,EAAK+D,IACxB1J,KAAKuK,GAAGhB,UAAW5D,EAAK4E,IACxBvK,KAAKwK,GAAGjB,UAAW5D,EAAK6E,IAEjBxK,MAMTsK,EAAiBxD,UAAU2D,oBAAqB,ECvEhD,MAAMC,UAA0B5K,EAE/BC,YAAa0J,EAAK,IAAIxG,EAAAA,QAAWyG,EAAK,IAAIzG,EAAAA,QAAWsH,EAAK,IAAItH,EAAAA,QAAWuH,EAAK,IAAIvH,EAAAA,SAEjFqD,QAEAtG,KAAKC,KAAO,oBAEZD,KAAKyJ,GAAKA,EACVzJ,KAAK0J,GAAKA,EACV1J,KAAKuK,GAAKA,EACVvK,KAAKwK,GAAKA,EAIXrK,SAAUM,EAAGD,EAAiB,IAAIyC,EAAAA,SAEjC,MAAMsD,EAAQ/F,EAERiJ,EAAKzJ,KAAKyJ,GAAIC,EAAK1J,KAAK0J,GAAIa,EAAKvK,KAAKuK,GAAIC,EAAKxK,KAAKwK,GAQ1D,OANAjE,EAAM7B,IACLsF,EAAavJ,EAAGgJ,EAAGpF,EAAGqF,EAAGrF,EAAGkG,EAAGlG,EAAGmG,EAAGnG,GACrC2F,EAAavJ,EAAGgJ,EAAGlF,EAAGmF,EAAGnF,EAAGgG,EAAGhG,EAAGiG,EAAGjG,GACrCyF,EAAavJ,EAAGgJ,EAAGhF,EAAGiF,EAAGjF,EAAG8F,EAAG9F,EAAG+F,EAAG/F,IAG/B8B,EAIRrD,KAAMkC,GASL,OAPAkB,MAAMpD,KAAMkC,GAEZpF,KAAKyJ,GAAGvG,KAAMkC,EAAOqE,IACrBzJ,KAAK0J,GAAGxG,KAAMkC,EAAOsE,IACrB1J,KAAKuK,GAAGrH,KAAMkC,EAAOmF,IACrBvK,KAAKwK,GAAGtH,KAAMkC,EAAOoF,IAEdxK,KAIRqF,SAEC,MAAMC,EAAOgB,MAAMjB,SAOnB,OALAC,EAAKmE,GAAKzJ,KAAKyJ,GAAGH,UAClBhE,EAAKoE,GAAK1J,KAAK0J,GAAGJ,UAClBhE,EAAKiF,GAAKvK,KAAKuK,GAAGjB,UAClBhE,EAAKkF,GAAKxK,KAAKwK,GAAGlB,UAEXhE,EAIRI,SAAUC,GAST,OAPAW,MAAMZ,SAAUC,GAEhB3F,KAAKyJ,GAAGF,UAAW5D,EAAK8D,IACxBzJ,KAAK0J,GAAGH,UAAW5D,EAAK+D,IACxB1J,KAAKuK,GAAGhB,UAAW5D,EAAK4E,IACxBvK,KAAKwK,GAAGjB,UAAW5D,EAAK6E,IAEjBxK,MAMT0K,EAAkB5D,UAAU6D,qBAAsB,ECzElD,MAAMC,UAAkB9K,EAEvBC,YAAa2J,EAAK,IAAI1G,EAAAA,QAAWuH,EAAK,IAAIvH,EAAAA,SAEzCsD,QAEAtG,KAAKC,KAAO,YAEZD,KAAK0J,GAAKA,EACV1J,KAAKuK,GAAKA,EAIXpK,SAAUM,EAAGD,EAAiB,IAAIwC,EAAAA,SAEjC,MAAMuD,EAAQ/F,EAad,OAXW,IAANC,EAEJ8F,EAAMrD,KAAMlD,KAAKuK,KAIjBhE,EAAMrD,KAAMlD,KAAKuK,IAAKpH,IAAKnD,KAAK0J,IAChCnD,EAAMsE,eAAgBpK,GAAIwI,IAAKjJ,KAAK0J,KAI9BnD,EAKRjG,WAAYC,EAAGC,GAEd,OAAOR,KAAKG,SAAUI,EAAGC,GAI1BiC,WAAYhC,EAAGD,GAEd,MAAMuC,EAAUvC,GAAkB,IAAIwC,EAAAA,QAItC,OAFAD,EAAQG,KAAMlD,KAAKuK,IAAKpH,IAAKnD,KAAK0J,IAAKtG,YAEhCL,EAIRG,KAAMkC,GAOL,OALAkB,MAAMpD,KAAMkC,GAEZpF,KAAK0J,GAAGxG,KAAMkC,EAAOsE,IACrB1J,KAAKuK,GAAGrH,KAAMkC,EAAOmF,IAEdvK,KAIRqF,SAEC,MAAMC,EAAOgB,MAAMjB,SAKnB,OAHAC,EAAKoE,GAAK1J,KAAK0J,GAAGJ,UAClBhE,EAAKiF,GAAKvK,KAAKuK,GAAGjB,UAEXhE,EAIRI,SAAUC,GAOT,OALAW,MAAMZ,SAAUC,GAEhB3F,KAAK0J,GAAGH,UAAW5D,EAAK+D,IACxB1J,KAAKuK,GAAGhB,UAAW5D,EAAK4E,IAEjBvK,MAMT4K,EAAU9D,UAAUgE,aAAc,ECpFlC,MAAMC,UAAmBjL,EAExBC,YAAa2J,EAAK,IAAIzG,EAAAA,QAAWsH,EAAK,IAAItH,EAAAA,SAEzCqD,QAEAtG,KAAKC,KAAO,aACZD,KAAKgL,cAAe,EAEpBhL,KAAK0J,GAAKA,EACV1J,KAAKuK,GAAKA,EAGXpK,SAAUM,EAAGD,EAAiB,IAAIyC,EAAAA,SAEjC,MAAMsD,EAAQ/F,EAad,OAXW,IAANC,EAEJ8F,EAAMrD,KAAMlD,KAAKuK,KAIjBhE,EAAMrD,KAAMlD,KAAKuK,IAAKpH,IAAKnD,KAAK0J,IAChCnD,EAAMsE,eAAgBpK,GAAIwI,IAAKjJ,KAAK0J,KAI9BnD,EAIRjG,WAAYC,EAAGC,GAEd,OAAOR,KAAKG,SAAUI,EAAGC,GAG1B0C,KAAMkC,GAOL,OALAkB,MAAMpD,KAAMkC,GAEZpF,KAAK0J,GAAGxG,KAAMkC,EAAOsE,IACrB1J,KAAKuK,GAAGrH,KAAMkC,EAAOmF,IAEdvK,KAGRqF,SAEC,MAAMC,EAAOgB,MAAMjB,SAKnB,OAHAC,EAAKoE,GAAK1J,KAAK0J,GAAGJ,UAClBhE,EAAKiF,GAAKvK,KAAKuK,GAAGjB,UAEXhE,EAGRI,SAAUC,GAOT,OALAW,MAAMZ,SAAUC,GAEhB3F,KAAK0J,GAAGH,UAAW5D,EAAK+D,IACxB1J,KAAKuK,GAAGhB,UAAW5D,EAAK4E,IAEjBvK,MC/DT,MAAMiL,UAA6BnL,EAElCC,YAAa0J,EAAK,IAAIzG,EAAAA,QAAW0G,EAAK,IAAI1G,EAAAA,QAAWuH,EAAK,IAAIvH,EAAAA,SAE7DsD,QAEAtG,KAAKC,KAAO,uBAEZD,KAAKyJ,GAAKA,EACVzJ,KAAK0J,GAAKA,EACV1J,KAAKuK,GAAKA,EAIXpK,SAAUM,EAAGD,EAAiB,IAAIwC,EAAAA,SAEjC,MAAMuD,EAAQ/F,EAERiJ,EAAKzJ,KAAKyJ,GAAIC,EAAK1J,KAAK0J,GAAIa,EAAKvK,KAAKuK,GAO5C,OALAhE,EAAM7B,IACLiF,EAAiBlJ,EAAGgJ,EAAGpF,EAAGqF,EAAGrF,EAAGkG,EAAGlG,GACnCsF,EAAiBlJ,EAAGgJ,EAAGlF,EAAGmF,EAAGnF,EAAGgG,EAAGhG,IAG7BgC,EAIRrD,KAAMkC,GAQL,OANAkB,MAAMpD,KAAMkC,GAEZpF,KAAKyJ,GAAGvG,KAAMkC,EAAOqE,IACrBzJ,KAAK0J,GAAGxG,KAAMkC,EAAOsE,IACrB1J,KAAKuK,GAAGrH,KAAMkC,EAAOmF,IAEdvK,KAIRqF,SAEC,MAAMC,EAAOgB,MAAMjB,SAMnB,OAJAC,EAAKmE,GAAKzJ,KAAKyJ,GAAGH,UAClBhE,EAAKoE,GAAK1J,KAAK0J,GAAGJ,UAClBhE,EAAKiF,GAAKvK,KAAKuK,GAAGjB,UAEXhE,EAIRI,SAAUC,GAQT,OANAW,MAAMZ,SAAUC,GAEhB3F,KAAKyJ,GAAGF,UAAW5D,EAAK8D,IACxBzJ,KAAK0J,GAAGH,UAAW5D,EAAK+D,IACxB1J,KAAKuK,GAAGhB,UAAW5D,EAAK4E,IAEjBvK,MAMTiL,EAAqBnE,UAAUoE,wBAAyB,ECnExD,MAAMC,UAA8BrL,EAEnCC,YAAa0J,EAAK,IAAIxG,EAAAA,QAAWyG,EAAK,IAAIzG,EAAAA,QAAWsH,EAAK,IAAItH,EAAAA,SAE7DqD,QAEAtG,KAAKC,KAAO,wBAEZD,KAAKyJ,GAAKA,EACVzJ,KAAK0J,GAAKA,EACV1J,KAAKuK,GAAKA,EAIXpK,SAAUM,EAAGD,EAAiB,IAAIyC,EAAAA,SAEjC,MAAMsD,EAAQ/F,EAERiJ,EAAKzJ,KAAKyJ,GAAIC,EAAK1J,KAAK0J,GAAIa,EAAKvK,KAAKuK,GAQ5C,OANAhE,EAAM7B,IACLiF,EAAiBlJ,EAAGgJ,EAAGpF,EAAGqF,EAAGrF,EAAGkG,EAAGlG,GACnCsF,EAAiBlJ,EAAGgJ,EAAGlF,EAAGmF,EAAGnF,EAAGgG,EAAGhG,GACnCoF,EAAiBlJ,EAAGgJ,EAAGhF,EAAGiF,EAAGjF,EAAG8F,EAAG9F,IAG7B8B,EAIRrD,KAAMkC,GAQL,OANAkB,MAAMpD,KAAMkC,GAEZpF,KAAKyJ,GAAGvG,KAAMkC,EAAOqE,IACrBzJ,KAAK0J,GAAGxG,KAAMkC,EAAOsE,IACrB1J,KAAKuK,GAAGrH,KAAMkC,EAAOmF,IAEdvK,KAIRqF,SAEC,MAAMC,EAAOgB,MAAMjB,SAMnB,OAJAC,EAAKmE,GAAKzJ,KAAKyJ,GAAGH,UAClBhE,EAAKoE,GAAK1J,KAAK0J,GAAGJ,UAClBhE,EAAKiF,GAAKvK,KAAKuK,GAAGjB,UAEXhE,EAIRI,SAAUC,GAQT,OANAW,MAAMZ,SAAUC,GAEhB3F,KAAKyJ,GAAGF,UAAW5D,EAAK8D,IACxBzJ,KAAK0J,GAAGH,UAAW5D,EAAK+D,IACxB1J,KAAKuK,GAAGhB,UAAW5D,EAAK4E,IAEjBvK,MAMTmL,EAAsBrE,UAAUsE,yBAA0B,ECpE1D,MAAMC,UAAoBvL,EAEzBC,YAAac,EAAS,IAErByF,QAEAtG,KAAKC,KAAO,cAEZD,KAAKa,OAASA,EAIfV,SAAUM,EAAGD,EAAiB,IAAIwC,EAAAA,SAEjC,MAAMuD,EAAQ/F,EAERK,EAASb,KAAKa,OACdc,GAAMd,EAAOO,OAAS,GAAMX,EAE5BqI,EAAWxG,KAAKC,MAAOZ,GACvBoH,EAASpH,EAAImH,EAEbF,EAAK/H,EAAqB,IAAbiI,EAAiBA,EAAWA,EAAW,GACpDI,EAAKrI,EAAQiI,GACbK,EAAKtI,EAAQiI,EAAWjI,EAAOO,OAAS,EAAIP,EAAOO,OAAS,EAAI0H,EAAW,GAC3ED,EAAKhI,EAAQiI,EAAWjI,EAAOO,OAAS,EAAIP,EAAOO,OAAS,EAAI0H,EAAW,GAOjF,OALAvC,EAAM7B,IACL8E,EAAYT,EAAQH,EAAGvE,EAAG6E,EAAG7E,EAAG8E,EAAG9E,EAAGwE,EAAGxE,GACzCmF,EAAYT,EAAQH,EAAGrE,EAAG2E,EAAG3E,EAAG4E,EAAG5E,EAAGsE,EAAGtE,IAGnCgC,EAIRrD,KAAMkC,GAELkB,MAAMpD,KAAMkC,GAEZpF,KAAKa,OAAS,GAEd,IAAM,IAAImB,EAAI,EAAG2G,EAAIvD,EAAOvE,OAAOO,OAAQY,EAAI2G,EAAG3G,IAAO,CAExD,MAAMuE,EAAQnB,EAAOvE,OAAQmB,GAE7BhC,KAAKa,OAAOE,KAAMwF,EAAM3B,SAIzB,OAAO5E,KAIRqF,SAEC,MAAMC,EAAOgB,MAAMjB,SAEnBC,EAAKzE,OAAS,GAEd,IAAM,IAAImB,EAAI,EAAG2G,EAAI3I,KAAKa,OAAOO,OAAQY,EAAI2G,EAAG3G,IAAO,CAEtD,MAAMuE,EAAQvG,KAAKa,OAAQmB,GAC3BsD,EAAKzE,OAAOE,KAAMwF,EAAM+C,WAIzB,OAAOhE,EAIRI,SAAUC,GAETW,MAAMZ,SAAUC,GAEhB3F,KAAKa,OAAS,GAEd,IAAM,IAAImB,EAAI,EAAG2G,EAAIhD,EAAK9E,OAAOO,OAAQY,EAAI2G,EAAG3G,IAAO,CAEtD,MAAMuE,EAAQZ,EAAK9E,OAAQmB,GAC3BhC,KAAKa,OAAOE,MAAM,IAAIiC,EAAAA,SAAUuG,UAAWhD,IAI5C,OAAOvG,MAMTqL,EAAYvE,UAAUwE,eAAgB,ECtFtC,MAAMC,UAAkBzL,EAEvBC,cAECuG,QAEAtG,KAAKC,KAAO,YAEZD,KAAKwL,OAAS,GACdxL,KAAKyL,WAAY,EAIlBxC,IAAKyC,GAEJ1L,KAAKwL,OAAOzK,KAAM2K,GAInBC,YAGC,MAAMC,EAAa5L,KAAKwL,OAAQ,GAAIrL,SAAU,GACxC0L,EAAW7L,KAAKwL,OAAQxL,KAAKwL,OAAOpK,OAAS,GAAIjB,SAAU,GAE1DyL,EAAWE,OAAQD,IAEzB7L,KAAKwL,OAAOzK,KAAM,IAAI,EAAuB8K,EAAUD,IAezDzL,SAAUM,EAAGD,GAEZ,MAAMM,EAAIL,EAAIT,KAAKiB,YACb8K,EAAe/L,KAAKgM,kBAC1B,IAAIhK,EAAI,EAIR,KAAQA,EAAI+J,EAAa3K,QAAS,CAEjC,GAAK2K,EAAc/J,IAAOlB,EAAI,CAE7B,MAAMmL,EAAOF,EAAc/J,GAAMlB,EAC3B4K,EAAQ1L,KAAKwL,OAAQxJ,GAErBkK,EAAgBR,EAAMzK,YACtBV,EAAsB,IAAlB2L,EAAsB,EAAI,EAAID,EAAOC,EAE/C,OAAOR,EAAMpL,WAAYC,EAAGC,GAI7BwB,IAID,OAAO,KAURf,YAEC,MAAMkL,EAAOnM,KAAKgM,kBAClB,OAAOG,EAAMA,EAAK/K,OAAS,GAK5BS,mBAEC7B,KAAKsB,aAAc,EACnBtB,KAAKoM,aAAe,KACpBpM,KAAKgM,kBAONA,kBAIC,GAAKhM,KAAKoM,cAAgBpM,KAAKoM,aAAahL,SAAWpB,KAAKwL,OAAOpK,OAElE,OAAOpB,KAAKoM,aAOb,MAAMlL,EAAU,GAChB,IAAImL,EAAO,EAEX,IAAM,IAAIrK,EAAI,EAAG2G,EAAI3I,KAAKwL,OAAOpK,OAAQY,EAAI2G,EAAG3G,IAE/CqK,GAAQrM,KAAKwL,OAAQxJ,GAAIf,YACzBC,EAAQH,KAAMsL,GAMf,OAFArM,KAAKoM,aAAelL,EAEbA,EAIRF,gBAAiBJ,EAAY,IAE5B,MAAMC,EAAS,GAEf,IAAM,IAAImB,EAAI,EAAGA,GAAKpB,EAAWoB,IAEhCnB,EAAOE,KAAMf,KAAKG,SAAU6B,EAAIpB,IAUjC,OANKZ,KAAKyL,WAET5K,EAAOE,KAAMF,EAAQ,IAIfA,EAIRF,UAAWC,EAAY,IAEtB,MAAMC,EAAS,GACf,IAAIY,EAEJ,IAAM,IAAIO,EAAI,EAAGwJ,EAASxL,KAAKwL,OAAQxJ,EAAIwJ,EAAOpK,OAAQY,IAAO,CAEhE,MAAM0J,EAAQF,EAAQxJ,GAChBsK,EAAaZ,EAAM3E,eAA6B,EAAZnG,EACrC8K,EAAMZ,aAAeY,EAAMV,aAAiB,EAC7CU,EAAMJ,cAAgB1K,EAAY8K,EAAM7K,OAAOO,OAC9CR,EAEC2L,EAAMb,EAAM/K,UAAW2L,GAE7B,IAAM,IAAIE,EAAI,EAAGA,EAAID,EAAInL,OAAQoL,IAAO,CAEvC,MAAMjG,EAAQgG,EAAKC,GAEd/K,GAAQA,EAAKqK,OAAQvF,KAE1B1F,EAAOE,KAAMwF,GACb9E,EAAO8E,IAYT,OANKvG,KAAKyL,WAAa5K,EAAOO,OAAS,IAAOP,EAAQA,EAAOO,OAAS,GAAI0K,OAAQjL,EAAQ,KAEzFA,EAAOE,KAAMF,EAAQ,IAIfA,EAIRqC,KAAMkC,GAELkB,MAAMpD,KAAMkC,GAEZpF,KAAKwL,OAAS,GAEd,IAAM,IAAIxJ,EAAI,EAAG2G,EAAIvD,EAAOoG,OAAOpK,OAAQY,EAAI2G,EAAG3G,IAAO,CAExD,MAAM0J,EAAQtG,EAAOoG,OAAQxJ,GAE7BhC,KAAKwL,OAAOzK,KAAM2K,EAAM9G,SAMzB,OAFA5E,KAAKyL,UAAYrG,EAAOqG,UAEjBzL,KAIRqF,SAEC,MAAMC,EAAOgB,MAAMjB,SAEnBC,EAAKmG,UAAYzL,KAAKyL,UACtBnG,EAAKkG,OAAS,GAEd,IAAM,IAAIxJ,EAAI,EAAG2G,EAAI3I,KAAKwL,OAAOpK,OAAQY,EAAI2G,EAAG3G,IAAO,CAEtD,MAAM0J,EAAQ1L,KAAKwL,OAAQxJ,GAC3BsD,EAAKkG,OAAOzK,KAAM2K,EAAMrG,UAIzB,OAAOC,EAIRI,SAAUC,GAETW,MAAMZ,SAAUC,GAEhB3F,KAAKyL,UAAY9F,EAAK8F,UACtBzL,KAAKwL,OAAS,GAEd,IAAM,IAAIxJ,EAAI,EAAG2G,EAAIhD,EAAK6F,OAAOpK,OAAQY,EAAI2G,EAAG3G,IAAO,CAEtD,MAAM0J,EAAQ/F,EAAK6F,OAAQxJ,GAC3BhC,KAAKwL,OAAOzK,MAAM,IAAI,EAAQ2K,EAAMzL,OAASyF,SAAUgG,IAIxD,OAAO1L,MC5OT,MAAMyM,UAAalB,EAElBxL,YAAac,GAEZyF,QACAtG,KAAKC,KAAO,OAEZD,KAAK0M,aAAe,IAAI1J,EAAAA,QAEnBnC,GAEJb,KAAK2M,cAAe9L,GAMtB8L,cAAe9L,GAEdb,KAAK4M,OAAQ/L,EAAQ,GAAIwD,EAAGxD,EAAQ,GAAI0D,GAExC,IAAM,IAAIvC,EAAI,EAAG2G,EAAI9H,EAAOO,OAAQY,EAAI2G,EAAG3G,IAE1ChC,KAAK6M,OAAQhM,EAAQmB,GAAIqC,EAAGxD,EAAQmB,GAAIuC,GAIzC,OAAOvE,KAIR4M,OAAQvI,EAAGE,GAIV,OAFAvE,KAAK0M,aAAahI,IAAKL,EAAGE,GAEnBvE,KAIR6M,OAAQxI,EAAGE,GAEV,MAAMmH,EAAQ,IAAId,EAAW5K,KAAK0M,aAAa9H,QAAS,IAAI5B,EAAAA,QAASqB,EAAGE,IAKxE,OAJAvE,KAAKwL,OAAOzK,KAAM2K,GAElB1L,KAAK0M,aAAahI,IAAKL,EAAGE,GAEnBvE,KAIR8M,iBAAkBC,EAAMC,EAAMnH,EAAIC,GAEjC,MAAM4F,EAAQ,IAAIT,EACjBjL,KAAK0M,aAAa9H,QAClB,IAAI5B,EAAAA,QAAS+J,EAAMC,GACnB,IAAIhK,EAAAA,QAAS6C,EAAIC,IAOlB,OAJA9F,KAAKwL,OAAOzK,KAAM2K,GAElB1L,KAAK0M,aAAahI,IAAKmB,EAAIC,GAEpB9F,KAIRiN,cAAeC,EAAOC,EAAOC,EAAOC,EAAOxH,EAAIC,GAE9C,MAAM4F,EAAQ,IAAIpB,EACjBtK,KAAK0M,aAAa9H,QAClB,IAAI5B,EAAAA,QAASkK,EAAOC,GACpB,IAAInK,EAAAA,QAASoK,EAAOC,GACpB,IAAIrK,EAAAA,QAAS6C,EAAIC,IAOlB,OAJA9F,KAAKwL,OAAOzK,KAAM2K,GAElB1L,KAAK0M,aAAahI,IAAKmB,EAAIC,GAEpB9F,KAIRsN,WAAYf,GAEX,MAAMgB,EAAO,CAAEvN,KAAK0M,aAAa9H,SAAU4I,OAAQjB,GAE7Cb,EAAQ,IAAIL,EAAakC,GAK/B,OAJAvN,KAAKwL,OAAOzK,KAAM2K,GAElB1L,KAAK0M,aAAaxJ,KAAMqJ,EAAKA,EAAInL,OAAS,IAEnCpB,KAIRyN,IAAK5H,EAAIC,EAAImB,EAAShB,EAAaC,EAAWE,GAE7C,MAAMoB,EAAKxH,KAAK0M,aAAarI,EACvBqJ,EAAK1N,KAAK0M,aAAanI,EAK7B,OAHAvE,KAAK2N,OAAQ9H,EAAK2B,EAAI1B,EAAK4H,EAAIzG,EAC9BhB,EAAaC,EAAWE,GAElBpG,KAIR2N,OAAQ9H,EAAIC,EAAImB,EAAShB,EAAaC,EAAWE,GAIhD,OAFApG,KAAK4N,WAAY/H,EAAIC,EAAImB,EAASA,EAAShB,EAAaC,EAAWE,GAE5DpG,KAIR6N,QAAShI,EAAIC,EAAIC,EAASC,EAASC,EAAaC,EAAWE,EAAYC,GAEtE,MAAMmB,EAAKxH,KAAK0M,aAAarI,EACvBqJ,EAAK1N,KAAK0M,aAAanI,EAI7B,OAFAvE,KAAK4N,WAAY/H,EAAK2B,EAAI1B,EAAK4H,EAAI3H,EAASC,EAASC,EAAaC,EAAWE,EAAYC,GAElFrG,KAIR4N,WAAY/H,EAAIC,EAAIC,EAASC,EAASC,EAAaC,EAAWE,EAAYC,GAEzE,MAAMqF,EAAQ,IAAI9F,EAAcC,EAAIC,EAAIC,EAASC,EAASC,EAAaC,EAAWE,EAAYC,GAE9F,GAAKrG,KAAKwL,OAAOpK,OAAS,EAAI,CAG7B,MAAM0M,EAAapC,EAAMvL,SAAU,GAE5B2N,EAAWhC,OAAQ9L,KAAK0M,eAE9B1M,KAAK6M,OAAQiB,EAAWzJ,EAAGyJ,EAAWvJ,GAMxCvE,KAAKwL,OAAOzK,KAAM2K,GAElB,MAAMqC,EAAYrC,EAAMvL,SAAU,GAGlC,OAFAH,KAAK0M,aAAaxJ,KAAM6K,GAEjB/N,KAIRkD,KAAMkC,GAML,OAJAkB,MAAMpD,KAAMkC,GAEZpF,KAAK0M,aAAaxJ,KAAMkC,EAAOsH,cAExB1M,KAIRqF,SAEC,MAAMC,EAAOgB,MAAMjB,SAInB,OAFAC,EAAKoH,aAAe1M,KAAK0M,aAAapD,UAE/BhE,EAIRI,SAAUC,GAMT,OAJAW,MAAMZ,SAAUC,GAEhB3F,KAAK0M,aAAanD,UAAW5D,EAAK+G,cAE3B1M,M,wBCrLT,MAAMgO,UAAsBC,EAAAA,eAE3BlO,YAAac,EAAS,CAAE,IAAImC,EAAAA,QAAS,EAAG,IAAO,IAAIA,EAAAA,QAAS,GAAK,GAAK,IAAIA,EAAAA,QAAS,GAAK,KAASO,EAAW,GAAI2K,EAAW,EAAGC,EAAsB,EAAV7L,KAAK6D,IAE9IG,QAEAtG,KAAKC,KAAO,gBAEZD,KAAKoO,WAAa,CACjBvN,OAAQA,EACR0C,SAAUA,EACV2K,SAAUA,EACVC,UAAWA,GAGZ5K,EAAWjB,KAAKC,MAAOgB,GAIvB4K,EAAYnJ,EAAA,GAAiBmJ,EAAW,EAAa,EAAV7L,KAAK6D,IAIhD,MAAMkI,EAAU,GACVC,EAAW,GACXC,EAAM,GACNC,EAAc,GACd7K,EAAU,GAIV8K,EAAkB,EAAMlL,EACxBmL,EAAS,IAAIzL,EAAAA,QACb0L,EAAK,IAAI3L,EAAAA,QACTS,EAAS,IAAIR,EAAAA,QACb2L,EAAY,IAAI3L,EAAAA,QAChB4L,EAAa,IAAI5L,EAAAA,QACvB,IAAI6L,EAAK,EACLC,EAAK,EAIT,IAAM,IAAIvC,EAAI,EAAGA,GAAO3L,EAAOO,OAAS,EAAKoL,IAE5C,OAASA,GAER,KAAK,EAEJsC,EAAKjO,EAAQ2L,EAAI,GAAInI,EAAIxD,EAAQ2L,GAAInI,EACrC0K,EAAKlO,EAAQ2L,EAAI,GAAIjI,EAAI1D,EAAQ2L,GAAIjI,EAErCd,EAAOY,EAAS,EAAL0K,EACXtL,EAAOc,GAAMuK,EACbrL,EAAOgB,EAAS,EAALsK,EAEXF,EAAW3L,KAAMO,GAEjBA,EAAOL,YAEPoL,EAAYzN,KAAM0C,EAAOY,EAAGZ,EAAOc,EAAGd,EAAOgB,GAE7C,MAED,KAAO5D,EAAOO,OAAS,EAEtBoN,EAAYzN,KAAM8N,EAAWxK,EAAGwK,EAAWtK,EAAGsK,EAAWpK,GAEzD,MAED,QAECqK,EAAKjO,EAAQ2L,EAAI,GAAInI,EAAIxD,EAAQ2L,GAAInI,EACrC0K,EAAKlO,EAAQ2L,EAAI,GAAIjI,EAAI1D,EAAQ2L,GAAIjI,EAErCd,EAAOY,EAAS,EAAL0K,EACXtL,EAAOc,GAAMuK,EACbrL,EAAOgB,EAAS,EAALsK,EAEXH,EAAU1L,KAAMO,GAEhBA,EAAOY,GAAKwK,EAAWxK,EACvBZ,EAAOc,GAAKsK,EAAWtK,EACvBd,EAAOgB,GAAKoK,EAAWpK,EAEvBhB,EAAOL,YAEPoL,EAAYzN,KAAM0C,EAAOY,EAAGZ,EAAOc,EAAGd,EAAOgB,GAE7CoK,EAAW3L,KAAM0L,GAQpB,IAAM,IAAI5M,EAAI,EAAGA,GAAKuB,EAAUvB,IAAO,CAEtC,MAAMgN,EAAMd,EAAWlM,EAAIyM,EAAkBN,EAEvCtH,EAAMvE,KAAKuE,IAAKmI,GAChBpI,EAAMtE,KAAKsE,IAAKoI,GAEtB,IAAM,IAAIxC,EAAI,EAAGA,GAAO3L,EAAOO,OAAS,EAAKoL,IAAO,CAInDkC,EAAOrK,EAAIxD,EAAQ2L,GAAInI,EAAIwC,EAC3B6H,EAAOnK,EAAI1D,EAAQ2L,GAAIjI,EACvBmK,EAAOjK,EAAI5D,EAAQ2L,GAAInI,EAAIuC,EAE3B0H,EAASvN,KAAM2N,EAAOrK,EAAGqK,EAAOnK,EAAGmK,EAAOjK,GAI1CkK,EAAGtK,EAAIrC,EAAIuB,EACXoL,EAAGpK,EAAIiI,GAAM3L,EAAOO,OAAS,GAE7BmN,EAAIxN,KAAM4N,EAAGtK,EAAGsK,EAAGpK,GAInB,MAAMF,EAAImK,EAAa,EAAIhC,EAAI,GAAM3F,EAC/BtC,EAAIiK,EAAa,EAAIhC,EAAI,GACzB/H,EAAI+J,EAAa,EAAIhC,EAAI,GAAM5F,EAErCjD,EAAQ5C,KAAMsD,EAAGE,EAAGE,IAQtB,IAAM,IAAIzC,EAAI,EAAGA,EAAIuB,EAAUvB,IAE9B,IAAM,IAAIwK,EAAI,EAAGA,EAAM3L,EAAOO,OAAS,EAAKoL,IAAO,CAElD,MAAMyC,EAAOzC,EAAIxK,EAAInB,EAAOO,OAEtB8N,EAAID,EACJE,EAAIF,EAAOpO,EAAOO,OAClBgO,EAAIH,EAAOpO,EAAOO,OAAS,EAC3BN,EAAImO,EAAO,EAIjBZ,EAAQtN,KAAMmO,EAAGC,EAAGrO,GACpBuN,EAAQtN,KAAMqO,EAAGtO,EAAGqO,GAQtBnP,KAAKqP,SAAUhB,GACfrO,KAAKsP,aAAc,WAAY,IAAI,EAAAC,uBAAwBjB,EAAU,IACrEtO,KAAKsP,aAAc,KAAM,IAAI,EAAAC,uBAAwBhB,EAAK,IAC1DvO,KAAKsP,aAAc,SAAU,IAAI,EAAAC,uBAAwB5L,EAAS,IAInE6L,gBAAiBlK,GAEhB,OAAO,IAAI0I,EAAe1I,EAAKzE,OAAQyE,EAAK/B,SAAU+B,EAAK4I,SAAU5I,EAAK6I,YCxK5E,MAAMsB,UAAwBzB,EAE7BjO,YAAa2P,EAAS,EAAGtO,EAAS,EAAGuO,EAAc,EAAGC,EAAiB,GAEtE,MAAMC,EAAO,IAAIpD,EACjBoD,EAAKlC,OAAQ,GAAKvM,EAAS,EAAGsO,EAAkB,IAAVpN,KAAK6D,GAAU,GACrD0J,EAAKlC,OAAQ,EAAGvM,EAAS,EAAGsO,EAAQ,EAAa,GAAVpN,KAAK6D,IAE5CG,MAAOuJ,EAAKlP,UAAWgP,GAAeC,GAEtC5P,KAAKC,KAAO,kBAEZD,KAAKoO,WAAa,CACjBsB,OAAQA,EACRI,OAAQ1O,EACRuO,YAAaA,EACbC,eAAgBA,GAKlBJ,gBAAiBlK,GAEhB,OAAO,IAAImK,EAAiBnK,EAAKoK,OAAQpK,EAAKlE,OAAQkE,EAAKqK,YAAarK,EAAKsK","sources":["webpack://joyride/./node_modules/three/src/extras/core/Curve.js","webpack://joyride/./node_modules/three/src/extras/curves/EllipseCurve.js","webpack://joyride/./node_modules/three/src/extras/curves/ArcCurve.js","webpack://joyride/./node_modules/three/src/extras/curves/CatmullRomCurve3.js","webpack://joyride/./node_modules/three/src/extras/core/Interpolations.js","webpack://joyride/./node_modules/three/src/extras/curves/CubicBezierCurve.js","webpack://joyride/./node_modules/three/src/extras/curves/CubicBezierCurve3.js","webpack://joyride/./node_modules/three/src/extras/curves/LineCurve.js","webpack://joyride/./node_modules/three/src/extras/curves/LineCurve3.js","webpack://joyride/./node_modules/three/src/extras/curves/QuadraticBezierCurve.js","webpack://joyride/./node_modules/three/src/extras/curves/QuadraticBezierCurve3.js","webpack://joyride/./node_modules/three/src/extras/curves/SplineCurve.js","webpack://joyride/./node_modules/three/src/extras/core/CurvePath.js","webpack://joyride/./node_modules/three/src/extras/core/Path.js","webpack://joyride/./node_modules/three/src/geometries/LatheGeometry.js","webpack://joyride/./node_modules/three/src/geometries/CapsuleGeometry.js"],"sourcesContent":["import * as MathUtils from '../../math/MathUtils.js';\nimport { Vector2 } from '../../math/Vector2.js';\nimport { Vector3 } from '../../math/Vector3.js';\nimport { Matrix4 } from '../../math/Matrix4.js';\n\n/**\n * Extensible curve object.\n *\n * Some common of curve methods:\n * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )\n * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )\n * .getPoints(), .getSpacedPoints()\n * .getLength()\n * .updateArcLengths()\n *\n * This following curves inherit from THREE.Curve:\n *\n * -- 2D curves --\n * THREE.ArcCurve\n * THREE.CubicBezierCurve\n * THREE.EllipseCurve\n * THREE.LineCurve\n * THREE.QuadraticBezierCurve\n * THREE.SplineCurve\n *\n * -- 3D curves --\n * THREE.CatmullRomCurve3\n * THREE.CubicBezierCurve3\n * THREE.LineCurve3\n * THREE.QuadraticBezierCurve3\n *\n * A series of curves can be represented as a THREE.CurvePath.\n *\n **/\n\nclass Curve {\n\n\tconstructor() {\n\n\t\tthis.type = 'Curve';\n\n\t\tthis.arcLengthDivisions = 200;\n\n\t}\n\n\t// Virtual base class method to overwrite and implement in subclasses\n\t//\t- t [0 .. 1]\n\n\tgetPoint( /* t, optionalTarget */ ) {\n\n\t\tconsole.warn( 'THREE.Curve: .getPoint() not implemented.' );\n\t\treturn null;\n\n\t}\n\n\t// Get point at relative position in curve according to arc length\n\t// - u [0 .. 1]\n\n\tgetPointAt( u, optionalTarget ) {\n\n\t\tconst t = this.getUtoTmapping( u );\n\t\treturn this.getPoint( t, optionalTarget );\n\n\t}\n\n\t// Get sequence of points using getPoint( t )\n\n\tgetPoints( divisions = 5 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPoint( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\t// Get sequence of points using getPointAt( u )\n\n\tgetSpacedPoints( divisions = 5 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let d = 0; d <= divisions; d ++ ) {\n\n\t\t\tpoints.push( this.getPointAt( d / divisions ) );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\t// Get total curve arc length\n\n\tgetLength() {\n\n\t\tconst lengths = this.getLengths();\n\t\treturn lengths[ lengths.length - 1 ];\n\n\t}\n\n\t// Get list of cumulative segment lengths\n\n\tgetLengths( divisions = this.arcLengthDivisions ) {\n\n\t\tif ( this.cacheArcLengths &&\n\t\t\t( this.cacheArcLengths.length === divisions + 1 ) &&\n\t\t\t! this.needsUpdate ) {\n\n\t\t\treturn this.cacheArcLengths;\n\n\t\t}\n\n\t\tthis.needsUpdate = false;\n\n\t\tconst cache = [];\n\t\tlet current, last = this.getPoint( 0 );\n\t\tlet sum = 0;\n\n\t\tcache.push( 0 );\n\n\t\tfor ( let p = 1; p <= divisions; p ++ ) {\n\n\t\t\tcurrent = this.getPoint( p / divisions );\n\t\t\tsum += current.distanceTo( last );\n\t\t\tcache.push( sum );\n\t\t\tlast = current;\n\n\t\t}\n\n\t\tthis.cacheArcLengths = cache;\n\n\t\treturn cache; // { sums: cache, sum: sum }; Sum is in the last element.\n\n\t}\n\n\tupdateArcLengths() {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.getLengths();\n\n\t}\n\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\n\n\tgetUtoTmapping( u, distance ) {\n\n\t\tconst arcLengths = this.getLengths();\n\n\t\tlet i = 0;\n\t\tconst il = arcLengths.length;\n\n\t\tlet targetArcLength; // The targeted u distance value to get\n\n\t\tif ( distance ) {\n\n\t\t\ttargetArcLength = distance;\n\n\t\t} else {\n\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\n\n\t\t}\n\n\t\t// binary search for the index with largest value smaller than target u distance\n\n\t\tlet low = 0, high = il - 1, comparison;\n\n\t\twhile ( low <= high ) {\n\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\n\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\n\n\t\t\tif ( comparison < 0 ) {\n\n\t\t\t\tlow = i + 1;\n\n\t\t\t} else if ( comparison > 0 ) {\n\n\t\t\t\thigh = i - 1;\n\n\t\t\t} else {\n\n\t\t\t\thigh = i;\n\t\t\t\tbreak;\n\n\t\t\t\t// DONE\n\n\t\t\t}\n\n\t\t}\n\n\t\ti = high;\n\n\t\tif ( arcLengths[ i ] === targetArcLength ) {\n\n\t\t\treturn i / ( il - 1 );\n\n\t\t}\n\n\t\t// we could get finer grain at lengths, or use simple interpolation between two points\n\n\t\tconst lengthBefore = arcLengths[ i ];\n\t\tconst lengthAfter = arcLengths[ i + 1 ];\n\n\t\tconst segmentLength = lengthAfter - lengthBefore;\n\n\t\t// determine where we are between the 'before' and 'after' points\n\n\t\tconst segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\n\n\t\t// add that fractional amount to t\n\n\t\tconst t = ( i + segmentFraction ) / ( il - 1 );\n\n\t\treturn t;\n\n\t}\n\n\t// Returns a unit vector tangent at t\n\t// In case any sub curve does not implement its tangent derivation,\n\t// 2 points a small delta apart will be used to find its gradient\n\t// which seems to give a reasonable approximation\n\n\tgetTangent( t, optionalTarget ) {\n\n\t\tconst delta = 0.0001;\n\t\tlet t1 = t - delta;\n\t\tlet t2 = t + delta;\n\n\t\t// Capping in case of danger\n\n\t\tif ( t1 < 0 ) t1 = 0;\n\t\tif ( t2 > 1 ) t2 = 1;\n\n\t\tconst pt1 = this.getPoint( t1 );\n\t\tconst pt2 = this.getPoint( t2 );\n\n\t\tconst tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3() );\n\n\t\ttangent.copy( pt2 ).sub( pt1 ).normalize();\n\n\t\treturn tangent;\n\n\t}\n\n\tgetTangentAt( u, optionalTarget ) {\n\n\t\tconst t = this.getUtoTmapping( u );\n\t\treturn this.getTangent( t, optionalTarget );\n\n\t}\n\n\tcomputeFrenetFrames( segments, closed ) {\n\n\t\t// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n\n\t\tconst normal = new Vector3();\n\n\t\tconst tangents = [];\n\t\tconst normals = [];\n\t\tconst binormals = [];\n\n\t\tconst vec = new Vector3();\n\t\tconst mat = new Matrix4();\n\n\t\t// compute the tangent vectors for each segment on the curve\n\n\t\tfor ( let i = 0; i <= segments; i ++ ) {\n\n\t\t\tconst u = i / segments;\n\n\t\t\ttangents[ i ] = this.getTangentAt( u, new Vector3() );\n\n\t\t}\n\n\t\t// select an initial normal vector perpendicular to the first tangent vector,\n\t\t// and in the direction of the minimum tangent xyz component\n\n\t\tnormals[ 0 ] = new Vector3();\n\t\tbinormals[ 0 ] = new Vector3();\n\t\tlet min = Number.MAX_VALUE;\n\t\tconst tx = Math.abs( tangents[ 0 ].x );\n\t\tconst ty = Math.abs( tangents[ 0 ].y );\n\t\tconst tz = Math.abs( tangents[ 0 ].z );\n\n\t\tif ( tx <= min ) {\n\n\t\t\tmin = tx;\n\t\t\tnormal.set( 1, 0, 0 );\n\n\t\t}\n\n\t\tif ( ty <= min ) {\n\n\t\t\tmin = ty;\n\t\t\tnormal.set( 0, 1, 0 );\n\n\t\t}\n\n\t\tif ( tz <= min ) {\n\n\t\t\tnormal.set( 0, 0, 1 );\n\n\t\t}\n\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\n\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\n\n\n\t\t// compute the slowly-varying normal and binormal vectors for each segment on the curve\n\n\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\n\n\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\n\n\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\n\n\t\t\tif ( vec.length() > Number.EPSILON ) {\n\n\t\t\t\tvec.normalize();\n\n\t\t\t\tconst theta = Math.acos( MathUtils.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\n\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\n\n\t\t\t}\n\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t}\n\n\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n\n\t\tif ( closed === true ) {\n\n\t\t\tlet theta = Math.acos( MathUtils.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );\n\t\t\ttheta /= segments;\n\n\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {\n\n\t\t\t\ttheta = - theta;\n\n\t\t\t}\n\n\t\t\tfor ( let i = 1; i <= segments; i ++ ) {\n\n\t\t\t\t// twist a little...\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\ttangents: tangents,\n\t\t\tnormals: normals,\n\t\t\tbinormals: binormals\n\t\t};\n\n\t}\n\n\tclone() {\n\n\t\treturn new this.constructor().copy( this );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tthis.arcLengthDivisions = source.arcLengthDivisions;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = {\n\t\t\tmetadata: {\n\t\t\t\tversion: 4.5,\n\t\t\t\ttype: 'Curve',\n\t\t\t\tgenerator: 'Curve.toJSON'\n\t\t\t}\n\t\t};\n\n\t\tdata.arcLengthDivisions = this.arcLengthDivisions;\n\t\tdata.type = this.type;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tthis.arcLengthDivisions = json.arcLengthDivisions;\n\n\t\treturn this;\n\n\t}\n\n}\n\n\nexport { Curve };\n","import { Curve } from '../core/Curve.js';\nimport { Vector2 } from '../../math/Vector2.js';\n\nclass EllipseCurve extends Curve {\n\n\tconstructor( aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'EllipseCurve';\n\n\t\tthis.aX = aX;\n\t\tthis.aY = aY;\n\n\t\tthis.xRadius = xRadius;\n\t\tthis.yRadius = yRadius;\n\n\t\tthis.aStartAngle = aStartAngle;\n\t\tthis.aEndAngle = aEndAngle;\n\n\t\tthis.aClockwise = aClockwise;\n\n\t\tthis.aRotation = aRotation;\n\n\t}\n\n\tgetPoint( t, optionalTarget ) {\n\n\t\tconst point = optionalTarget || new Vector2();\n\n\t\tconst twoPi = Math.PI * 2;\n\t\tlet deltaAngle = this.aEndAngle - this.aStartAngle;\n\t\tconst samePoints = Math.abs( deltaAngle ) < Number.EPSILON;\n\n\t\t// ensures that deltaAngle is 0 .. 2 PI\n\t\twhile ( deltaAngle < 0 ) deltaAngle += twoPi;\n\t\twhile ( deltaAngle > twoPi ) deltaAngle -= twoPi;\n\n\t\tif ( deltaAngle < Number.EPSILON ) {\n\n\t\t\tif ( samePoints ) {\n\n\t\t\t\tdeltaAngle = 0;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.aClockwise === true && ! samePoints ) {\n\n\t\t\tif ( deltaAngle === twoPi ) {\n\n\t\t\t\tdeltaAngle = - twoPi;\n\n\t\t\t} else {\n\n\t\t\t\tdeltaAngle = deltaAngle - twoPi;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst angle = this.aStartAngle + t * deltaAngle;\n\t\tlet x = this.aX + this.xRadius * Math.cos( angle );\n\t\tlet y = this.aY + this.yRadius * Math.sin( angle );\n\n\t\tif ( this.aRotation !== 0 ) {\n\n\t\t\tconst cos = Math.cos( this.aRotation );\n\t\t\tconst sin = Math.sin( this.aRotation );\n\n\t\t\tconst tx = x - this.aX;\n\t\t\tconst ty = y - this.aY;\n\n\t\t\t// Rotate the point about the center of the ellipse.\n\t\t\tx = tx * cos - ty * sin + this.aX;\n\t\t\ty = tx * sin + ty * cos + this.aY;\n\n\t\t}\n\n\t\treturn point.set( x, y );\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.aX = source.aX;\n\t\tthis.aY = source.aY;\n\n\t\tthis.xRadius = source.xRadius;\n\t\tthis.yRadius = source.yRadius;\n\n\t\tthis.aStartAngle = source.aStartAngle;\n\t\tthis.aEndAngle = source.aEndAngle;\n\n\t\tthis.aClockwise = source.aClockwise;\n\n\t\tthis.aRotation = source.aRotation;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.aX = this.aX;\n\t\tdata.aY = this.aY;\n\n\t\tdata.xRadius = this.xRadius;\n\t\tdata.yRadius = this.yRadius;\n\n\t\tdata.aStartAngle = this.aStartAngle;\n\t\tdata.aEndAngle = this.aEndAngle;\n\n\t\tdata.aClockwise = this.aClockwise;\n\n\t\tdata.aRotation = this.aRotation;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.aX = json.aX;\n\t\tthis.aY = json.aY;\n\n\t\tthis.xRadius = json.xRadius;\n\t\tthis.yRadius = json.yRadius;\n\n\t\tthis.aStartAngle = json.aStartAngle;\n\t\tthis.aEndAngle = json.aEndAngle;\n\n\t\tthis.aClockwise = json.aClockwise;\n\n\t\tthis.aRotation = json.aRotation;\n\n\t\treturn this;\n\n\t}\n\n}\n\nEllipseCurve.prototype.isEllipseCurve = true;\n\nexport { EllipseCurve };\n","import { EllipseCurve } from './EllipseCurve.js';\n\nclass ArcCurve extends EllipseCurve {\n\n\tconstructor( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tsuper( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t\tthis.type = 'ArcCurve';\n\n\t}\n\n}\n\nArcCurve.prototype.isArcCurve = true;\n\nexport { ArcCurve };\n","import { Vector3 } from '../../math/Vector3.js';\nimport { Curve } from '../core/Curve.js';\n\n/**\n * Centripetal CatmullRom Curve - which is useful for avoiding\n * cusps and self-intersections in non-uniform catmull rom curves.\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\n *\n * curve.type accepts centripetal(default), chordal and catmullrom\n * curve.tension is used for catmullrom which defaults to 0.5\n */\n\n\n/*\nBased on an optimized c++ solution in\n - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\n - http://ideone.com/NoEbVM\n\nThis CubicPoly class could be used for reusing some variables and calculations,\nbut for three.js curve use, it could be possible inlined and flatten into a single function call\nwhich can be placed in CurveUtils.\n*/\n\nfunction CubicPoly() {\n\n\tlet c0 = 0, c1 = 0, c2 = 0, c3 = 0;\n\n\t/*\n\t * Compute coefficients for a cubic polynomial\n\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\n\t * such that\n\t *   p(0) = x0, p(1) = x1\n\t *  and\n\t *   p'(0) = t0, p'(1) = t1.\n\t */\n\tfunction init( x0, x1, t0, t1 ) {\n\n\t\tc0 = x0;\n\t\tc1 = t0;\n\t\tc2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\n\t\tc3 = 2 * x0 - 2 * x1 + t0 + t1;\n\n\t}\n\n\treturn {\n\n\t\tinitCatmullRom: function ( x0, x1, x2, x3, tension ) {\n\n\t\t\tinit( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\n\n\t\t},\n\n\t\tinitNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {\n\n\t\t\t// compute tangents when parameterized in [t1,t2]\n\t\t\tlet t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\n\t\t\tlet t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\n\n\t\t\t// rescale tangents for parametrization in [0,1]\n\t\t\tt1 *= dt1;\n\t\t\tt2 *= dt1;\n\n\t\t\tinit( x1, x2, t1, t2 );\n\n\t\t},\n\n\t\tcalc: function ( t ) {\n\n\t\t\tconst t2 = t * t;\n\t\t\tconst t3 = t2 * t;\n\t\t\treturn c0 + c1 * t + c2 * t2 + c3 * t3;\n\n\t\t}\n\n\t};\n\n}\n\n//\n\nconst tmp = new Vector3();\nconst px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();\n\nclass CatmullRomCurve3 extends Curve {\n\n\tconstructor( points = [], closed = false, curveType = 'centripetal', tension = 0.5 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CatmullRomCurve3';\n\n\t\tthis.points = points;\n\t\tthis.closed = closed;\n\t\tthis.curveType = curveType;\n\t\tthis.tension = tension;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst points = this.points;\n\t\tconst l = points.length;\n\n\t\tconst p = ( l - ( this.closed ? 0 : 1 ) ) * t;\n\t\tlet intPoint = Math.floor( p );\n\t\tlet weight = p - intPoint;\n\n\t\tif ( this.closed ) {\n\n\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;\n\n\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\n\n\t\t\tintPoint = l - 2;\n\t\t\tweight = 1;\n\n\t\t}\n\n\t\tlet p0, p3; // 4 points (p1 & p2 defined below)\n\n\t\tif ( this.closed || intPoint > 0 ) {\n\n\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\n\n\t\t} else {\n\n\t\t\t// extrapolate first point\n\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\n\t\t\tp0 = tmp;\n\n\t\t}\n\n\t\tconst p1 = points[ intPoint % l ];\n\t\tconst p2 = points[ ( intPoint + 1 ) % l ];\n\n\t\tif ( this.closed || intPoint + 2 < l ) {\n\n\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\n\n\t\t} else {\n\n\t\t\t// extrapolate last point\n\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\n\t\t\tp3 = tmp;\n\n\t\t}\n\n\t\tif ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {\n\n\t\t\t// init Centripetal / Chordal Catmull-Rom\n\t\t\tconst pow = this.curveType === 'chordal' ? 0.5 : 0.25;\n\t\t\tlet dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\n\t\t\tlet dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\n\t\t\tlet dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\n\n\t\t\t// safety check for repeated points\n\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\n\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\n\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\n\n\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\n\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\n\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\n\n\t\t} else if ( this.curveType === 'catmullrom' ) {\n\n\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );\n\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );\n\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );\n\n\t\t}\n\n\t\tpoint.set(\n\t\t\tpx.calc( weight ),\n\t\t\tpy.calc( weight ),\n\t\t\tpz.calc( weight )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = source.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = source.points[ i ];\n\n\t\t\tthis.points.push( point.clone() );\n\n\t\t}\n\n\t\tthis.closed = source.closed;\n\t\tthis.curveType = source.curveType;\n\t\tthis.tension = source.tension;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.points = [];\n\n\t\tfor ( let i = 0, l = this.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = this.points[ i ];\n\t\t\tdata.points.push( point.toArray() );\n\n\t\t}\n\n\t\tdata.closed = this.closed;\n\t\tdata.curveType = this.curveType;\n\t\tdata.tension = this.tension;\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = json.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = json.points[ i ];\n\t\t\tthis.points.push( new Vector3().fromArray( point ) );\n\n\t\t}\n\n\t\tthis.closed = json.closed;\n\t\tthis.curveType = json.curveType;\n\t\tthis.tension = json.tension;\n\n\t\treturn this;\n\n\t}\n\n}\n\nCatmullRomCurve3.prototype.isCatmullRomCurve3 = true;\n\nexport { CatmullRomCurve3 };\n","/**\n * Bezier Curves formulas obtained from\n * https://en.wikipedia.org/wiki/B%C3%A9zier_curve\n */\n\nfunction CatmullRom( t, p0, p1, p2, p3 ) {\n\n\tconst v0 = ( p2 - p0 ) * 0.5;\n\tconst v1 = ( p3 - p1 ) * 0.5;\n\tconst t2 = t * t;\n\tconst t3 = t * t2;\n\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\n\n}\n\n//\n\nfunction QuadraticBezierP0( t, p ) {\n\n\tconst k = 1 - t;\n\treturn k * k * p;\n\n}\n\nfunction QuadraticBezierP1( t, p ) {\n\n\treturn 2 * ( 1 - t ) * t * p;\n\n}\n\nfunction QuadraticBezierP2( t, p ) {\n\n\treturn t * t * p;\n\n}\n\nfunction QuadraticBezier( t, p0, p1, p2 ) {\n\n\treturn QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +\n\t\tQuadraticBezierP2( t, p2 );\n\n}\n\n//\n\nfunction CubicBezierP0( t, p ) {\n\n\tconst k = 1 - t;\n\treturn k * k * k * p;\n\n}\n\nfunction CubicBezierP1( t, p ) {\n\n\tconst k = 1 - t;\n\treturn 3 * k * k * t * p;\n\n}\n\nfunction CubicBezierP2( t, p ) {\n\n\treturn 3 * ( 1 - t ) * t * t * p;\n\n}\n\nfunction CubicBezierP3( t, p ) {\n\n\treturn t * t * t * p;\n\n}\n\nfunction CubicBezier( t, p0, p1, p2, p3 ) {\n\n\treturn CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +\n\t\tCubicBezierP3( t, p3 );\n\n}\n\nexport { CatmullRom, QuadraticBezier, CubicBezier };\n","import { Curve } from '../core/Curve.js';\nimport { CubicBezier } from '../core/Interpolations.js';\nimport { Vector2 } from '../../math/Vector2.js';\n\nclass CubicBezierCurve extends Curve {\n\n\tconstructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2() ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CubicBezierCurve';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n\n\t\tpoint.set(\n\t\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\n\t\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\t\tthis.v3.copy( source.v3 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\t\tdata.v3 = this.v3.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\t\tthis.v3.fromArray( json.v3 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nCubicBezierCurve.prototype.isCubicBezierCurve = true;\n\nexport { CubicBezierCurve };\n","import { Curve } from '../core/Curve.js';\nimport { CubicBezier } from '../core/Interpolations.js';\nimport { Vector3 } from '../../math/Vector3.js';\n\nclass CubicBezierCurve3 extends Curve {\n\n\tconstructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3(), v3 = new Vector3() ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'CubicBezierCurve3';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\t\tthis.v3 = v3;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;\n\n\t\tpoint.set(\n\t\t\tCubicBezier( t, v0.x, v1.x, v2.x, v3.x ),\n\t\t\tCubicBezier( t, v0.y, v1.y, v2.y, v3.y ),\n\t\t\tCubicBezier( t, v0.z, v1.z, v2.z, v3.z )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\t\tthis.v3.copy( source.v3 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\t\tdata.v3 = this.v3.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\t\tthis.v3.fromArray( json.v3 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nCubicBezierCurve3.prototype.isCubicBezierCurve3 = true;\n\nexport { CubicBezierCurve3 };\n","import { Vector2 } from '../../math/Vector2.js';\nimport { Curve } from '../core/Curve.js';\n\nclass LineCurve extends Curve {\n\n\tconstructor( v1 = new Vector2(), v2 = new Vector2() ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'LineCurve';\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tif ( t === 1 ) {\n\n\t\t\tpoint.copy( this.v2 );\n\n\t\t} else {\n\n\t\t\tpoint.copy( this.v2 ).sub( this.v1 );\n\t\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t\t}\n\n\t\treturn point;\n\n\t}\n\n\t// Line curve is linear, so we can overwrite default getPointAt\n\tgetPointAt( u, optionalTarget ) {\n\n\t\treturn this.getPoint( u, optionalTarget );\n\n\t}\n\n\tgetTangent( t, optionalTarget ) {\n\n\t\tconst tangent = optionalTarget || new Vector2();\n\n\t\ttangent.copy( this.v2 ).sub( this.v1 ).normalize();\n\n\t\treturn tangent;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nLineCurve.prototype.isLineCurve = true;\n\nexport { LineCurve };\n","import { Vector3 } from '../../math/Vector3.js';\nimport { Curve } from '../core/Curve.js';\n\nclass LineCurve3 extends Curve {\n\n\tconstructor( v1 = new Vector3(), v2 = new Vector3() ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'LineCurve3';\n\t\tthis.isLineCurve3 = true;\n\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tif ( t === 1 ) {\n\n\t\t\tpoint.copy( this.v2 );\n\n\t\t} else {\n\n\t\t\tpoint.copy( this.v2 ).sub( this.v1 );\n\t\t\tpoint.multiplyScalar( t ).add( this.v1 );\n\n\t\t}\n\n\t\treturn point;\n\n\t}\n\t// Line curve is linear, so we can overwrite default getPointAt\n\tgetPointAt( u, optionalTarget ) {\n\n\t\treturn this.getPoint( u, optionalTarget );\n\n\t}\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nexport { LineCurve3 };\n","import { Curve } from '../core/Curve.js';\nimport { QuadraticBezier } from '../core/Interpolations.js';\nimport { Vector2 } from '../../math/Vector2.js';\n\nclass QuadraticBezierCurve extends Curve {\n\n\tconstructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2() ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'QuadraticBezierCurve';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2;\n\n\t\tpoint.set(\n\t\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\n\t\t\tQuadraticBezier( t, v0.y, v1.y, v2.y )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nQuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;\n\nexport { QuadraticBezierCurve };\n","import { Curve } from '../core/Curve.js';\nimport { QuadraticBezier } from '../core/Interpolations.js';\nimport { Vector3 } from '../../math/Vector3.js';\n\nclass QuadraticBezierCurve3 extends Curve {\n\n\tconstructor( v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3() ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'QuadraticBezierCurve3';\n\n\t\tthis.v0 = v0;\n\t\tthis.v1 = v1;\n\t\tthis.v2 = v2;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector3() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst v0 = this.v0, v1 = this.v1, v2 = this.v2;\n\n\t\tpoint.set(\n\t\t\tQuadraticBezier( t, v0.x, v1.x, v2.x ),\n\t\t\tQuadraticBezier( t, v0.y, v1.y, v2.y ),\n\t\t\tQuadraticBezier( t, v0.z, v1.z, v2.z )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.v0.copy( source.v0 );\n\t\tthis.v1.copy( source.v1 );\n\t\tthis.v2.copy( source.v2 );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.v0 = this.v0.toArray();\n\t\tdata.v1 = this.v1.toArray();\n\t\tdata.v2 = this.v2.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.v0.fromArray( json.v0 );\n\t\tthis.v1.fromArray( json.v1 );\n\t\tthis.v2.fromArray( json.v2 );\n\n\t\treturn this;\n\n\t}\n\n}\n\nQuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;\n\nexport { QuadraticBezierCurve3 };\n","import { Curve } from '../core/Curve.js';\nimport { CatmullRom } from '../core/Interpolations.js';\nimport { Vector2 } from '../../math/Vector2.js';\n\nclass SplineCurve extends Curve {\n\n\tconstructor( points = [] ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'SplineCurve';\n\n\t\tthis.points = points;\n\n\t}\n\n\tgetPoint( t, optionalTarget = new Vector2() ) {\n\n\t\tconst point = optionalTarget;\n\n\t\tconst points = this.points;\n\t\tconst p = ( points.length - 1 ) * t;\n\n\t\tconst intPoint = Math.floor( p );\n\t\tconst weight = p - intPoint;\n\n\t\tconst p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\n\t\tconst p1 = points[ intPoint ];\n\t\tconst p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\n\t\tconst p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\n\n\t\tpoint.set(\n\t\t\tCatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),\n\t\t\tCatmullRom( weight, p0.y, p1.y, p2.y, p3.y )\n\t\t);\n\n\t\treturn point;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = source.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = source.points[ i ];\n\n\t\t\tthis.points.push( point.clone() );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.points = [];\n\n\t\tfor ( let i = 0, l = this.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = this.points[ i ];\n\t\t\tdata.points.push( point.toArray() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.points = [];\n\n\t\tfor ( let i = 0, l = json.points.length; i < l; i ++ ) {\n\n\t\t\tconst point = json.points[ i ];\n\t\t\tthis.points.push( new Vector2().fromArray( point ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\nSplineCurve.prototype.isSplineCurve = true;\n\nexport { SplineCurve };\n","import { Curve } from './Curve.js';\nimport * as Curves from '../curves/Curves.js';\n\n/**************************************************************\n *\tCurved Path - a curve path is simply a array of connected\n *  curves, but retains the api of a curve\n **************************************************************/\n\nclass CurvePath extends Curve {\n\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tthis.type = 'CurvePath';\n\n\t\tthis.curves = [];\n\t\tthis.autoClose = false; // Automatically closes the path\n\n\t}\n\n\tadd( curve ) {\n\n\t\tthis.curves.push( curve );\n\n\t}\n\n\tclosePath() {\n\n\t\t// Add a line curve if start and end of lines are not connected\n\t\tconst startPoint = this.curves[ 0 ].getPoint( 0 );\n\t\tconst endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\n\n\t\tif ( ! startPoint.equals( endPoint ) ) {\n\n\t\t\tthis.curves.push( new Curves[ 'LineCurve' ]( endPoint, startPoint ) );\n\n\t\t}\n\n\t}\n\n\t// To get accurate point with reference to\n\t// entire path distance at time t,\n\t// following has to be done:\n\n\t// 1. Length of each sub path have to be known\n\t// 2. Locate and identify type of curve\n\t// 3. Get t for the curve\n\t// 4. Return curve.getPointAt(t')\n\n\tgetPoint( t, optionalTarget ) {\n\n\t\tconst d = t * this.getLength();\n\t\tconst curveLengths = this.getCurveLengths();\n\t\tlet i = 0;\n\n\t\t// To think about boundaries points.\n\n\t\twhile ( i < curveLengths.length ) {\n\n\t\t\tif ( curveLengths[ i ] >= d ) {\n\n\t\t\t\tconst diff = curveLengths[ i ] - d;\n\t\t\t\tconst curve = this.curves[ i ];\n\n\t\t\t\tconst segmentLength = curve.getLength();\n\t\t\t\tconst u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;\n\n\t\t\t\treturn curve.getPointAt( u, optionalTarget );\n\n\t\t\t}\n\n\t\t\ti ++;\n\n\t\t}\n\n\t\treturn null;\n\n\t\t// loop where sum != 0, sum > d , sum+1 <d\n\n\t}\n\n\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\n\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\n\t// getPoint() depends on getLength\n\n\tgetLength() {\n\n\t\tconst lens = this.getCurveLengths();\n\t\treturn lens[ lens.length - 1 ];\n\n\t}\n\n\t// cacheLengths must be recalculated.\n\tupdateArcLengths() {\n\n\t\tthis.needsUpdate = true;\n\t\tthis.cacheLengths = null;\n\t\tthis.getCurveLengths();\n\n\t}\n\n\t// Compute lengths and cache them\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\n\n\tgetCurveLengths() {\n\n\t\t// We use cache values if curves and cache array are same length\n\n\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\n\n\t\t\treturn this.cacheLengths;\n\n\t\t}\n\n\t\t// Get length of sub-curve\n\t\t// Push sums into cached array\n\n\t\tconst lengths = [];\n\t\tlet sums = 0;\n\n\t\tfor ( let i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tsums += this.curves[ i ].getLength();\n\t\t\tlengths.push( sums );\n\n\t\t}\n\n\t\tthis.cacheLengths = lengths;\n\n\t\treturn lengths;\n\n\t}\n\n\tgetSpacedPoints( divisions = 40 ) {\n\n\t\tconst points = [];\n\n\t\tfor ( let i = 0; i <= divisions; i ++ ) {\n\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\n\n\t\t}\n\n\t\tif ( this.autoClose ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\tgetPoints( divisions = 12 ) {\n\n\t\tconst points = [];\n\t\tlet last;\n\n\t\tfor ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {\n\n\t\t\tconst curve = curves[ i ];\n\t\t\tconst resolution = curve.isEllipseCurve ? divisions * 2\n\t\t\t\t: ( curve.isLineCurve || curve.isLineCurve3 ) ? 1\n\t\t\t\t\t: curve.isSplineCurve ? divisions * curve.points.length\n\t\t\t\t\t\t: divisions;\n\n\t\t\tconst pts = curve.getPoints( resolution );\n\n\t\t\tfor ( let j = 0; j < pts.length; j ++ ) {\n\n\t\t\t\tconst point = pts[ j ];\n\n\t\t\t\tif ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates\n\n\t\t\t\tpoints.push( point );\n\t\t\t\tlast = point;\n\n\t\t\t}\n\n\t\t}\n\n\t\tif ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {\n\n\t\t\tpoints.push( points[ 0 ] );\n\n\t\t}\n\n\t\treturn points;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.curves = [];\n\n\t\tfor ( let i = 0, l = source.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = source.curves[ i ];\n\n\t\t\tthis.curves.push( curve.clone() );\n\n\t\t}\n\n\t\tthis.autoClose = source.autoClose;\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.autoClose = this.autoClose;\n\t\tdata.curves = [];\n\n\t\tfor ( let i = 0, l = this.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = this.curves[ i ];\n\t\t\tdata.curves.push( curve.toJSON() );\n\n\t\t}\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.autoClose = json.autoClose;\n\t\tthis.curves = [];\n\n\t\tfor ( let i = 0, l = json.curves.length; i < l; i ++ ) {\n\n\t\t\tconst curve = json.curves[ i ];\n\t\t\tthis.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n}\n\n\nexport { CurvePath };\n","import { Vector2 } from '../../math/Vector2.js';\nimport { CurvePath } from './CurvePath.js';\nimport { EllipseCurve } from '../curves/EllipseCurve.js';\nimport { SplineCurve } from '../curves/SplineCurve.js';\nimport { CubicBezierCurve } from '../curves/CubicBezierCurve.js';\nimport { QuadraticBezierCurve } from '../curves/QuadraticBezierCurve.js';\nimport { LineCurve } from '../curves/LineCurve.js';\n\nclass Path extends CurvePath {\n\n\tconstructor( points ) {\n\n\t\tsuper();\n\t\tthis.type = 'Path';\n\n\t\tthis.currentPoint = new Vector2();\n\n\t\tif ( points ) {\n\n\t\t\tthis.setFromPoints( points );\n\n\t\t}\n\n\t}\n\n\tsetFromPoints( points ) {\n\n\t\tthis.moveTo( points[ 0 ].x, points[ 0 ].y );\n\n\t\tfor ( let i = 1, l = points.length; i < l; i ++ ) {\n\n\t\t\tthis.lineTo( points[ i ].x, points[ i ].y );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tmoveTo( x, y ) {\n\n\t\tthis.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?\n\n\t\treturn this;\n\n\t}\n\n\tlineTo( x, y ) {\n\n\t\tconst curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( x, y );\n\n\t\treturn this;\n\n\t}\n\n\tquadraticCurveTo( aCPx, aCPy, aX, aY ) {\n\n\t\tconst curve = new QuadraticBezierCurve(\n\t\t\tthis.currentPoint.clone(),\n\t\t\tnew Vector2( aCPx, aCPy ),\n\t\t\tnew Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tbezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\n\n\t\tconst curve = new CubicBezierCurve(\n\t\t\tthis.currentPoint.clone(),\n\t\t\tnew Vector2( aCP1x, aCP1y ),\n\t\t\tnew Vector2( aCP2x, aCP2y ),\n\t\t\tnew Vector2( aX, aY )\n\t\t);\n\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.set( aX, aY );\n\n\t\treturn this;\n\n\t}\n\n\tsplineThru( pts /*Array of Vector*/ ) {\n\n\t\tconst npts = [ this.currentPoint.clone() ].concat( pts );\n\n\t\tconst curve = new SplineCurve( npts );\n\t\tthis.curves.push( curve );\n\n\t\tthis.currentPoint.copy( pts[ pts.length - 1 ] );\n\n\t\treturn this;\n\n\t}\n\n\tarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tconst x0 = this.currentPoint.x;\n\t\tconst y0 = this.currentPoint.y;\n\n\t\tthis.absarc( aX + x0, aY + y0, aRadius,\n\t\t\taStartAngle, aEndAngle, aClockwise );\n\n\t\treturn this;\n\n\t}\n\n\tabsarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\n\n\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\n\n\t\treturn this;\n\n\t}\n\n\tellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tconst x0 = this.currentPoint.x;\n\t\tconst y0 = this.currentPoint.y;\n\n\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\treturn this;\n\n\t}\n\n\tabsellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\n\n\t\tconst curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\n\n\t\tif ( this.curves.length > 0 ) {\n\n\t\t\t// if a previous curve is present, attempt to join\n\t\t\tconst firstPoint = curve.getPoint( 0 );\n\n\t\t\tif ( ! firstPoint.equals( this.currentPoint ) ) {\n\n\t\t\t\tthis.lineTo( firstPoint.x, firstPoint.y );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.curves.push( curve );\n\n\t\tconst lastPoint = curve.getPoint( 1 );\n\t\tthis.currentPoint.copy( lastPoint );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( source ) {\n\n\t\tsuper.copy( source );\n\n\t\tthis.currentPoint.copy( source.currentPoint );\n\n\t\treturn this;\n\n\t}\n\n\ttoJSON() {\n\n\t\tconst data = super.toJSON();\n\n\t\tdata.currentPoint = this.currentPoint.toArray();\n\n\t\treturn data;\n\n\t}\n\n\tfromJSON( json ) {\n\n\t\tsuper.fromJSON( json );\n\n\t\tthis.currentPoint.fromArray( json.currentPoint );\n\n\t\treturn this;\n\n\t}\n\n}\n\n\nexport { Path };\n","import { Float32BufferAttribute } from '../core/BufferAttribute.js';\nimport { BufferGeometry } from '../core/BufferGeometry.js';\nimport { Vector3 } from '../math/Vector3.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport * as MathUtils from '../math/MathUtils.js';\n\nclass LatheGeometry extends BufferGeometry {\n\n\tconstructor( points = [ new Vector2( 0, 0.5 ), new Vector2( 0.5, 0 ), new Vector2( 0, - 0.5 ) ], segments = 12, phiStart = 0, phiLength = Math.PI * 2 ) {\n\n\t\tsuper();\n\n\t\tthis.type = 'LatheGeometry';\n\n\t\tthis.parameters = {\n\t\t\tpoints: points,\n\t\t\tsegments: segments,\n\t\t\tphiStart: phiStart,\n\t\t\tphiLength: phiLength\n\t\t};\n\n\t\tsegments = Math.floor( segments );\n\n\t\t// clamp phiLength so it's in range of [ 0, 2PI ]\n\n\t\tphiLength = MathUtils.clamp( phiLength, 0, Math.PI * 2 );\n\n\t\t// buffers\n\n\t\tconst indices = [];\n\t\tconst vertices = [];\n\t\tconst uvs = [];\n\t\tconst initNormals = [];\n\t\tconst normals = [];\n\n\t\t// helper variables\n\n\t\tconst inverseSegments = 1.0 / segments;\n\t\tconst vertex = new Vector3();\n\t\tconst uv = new Vector2();\n\t\tconst normal = new Vector3();\n\t\tconst curNormal = new Vector3();\n\t\tconst prevNormal = new Vector3();\n\t\tlet dx = 0;\n\t\tlet dy = 0;\n\n\t\t// pre-compute normals for initial \"meridian\"\n\n\t\tfor ( let j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\tswitch ( j ) {\n\n\t\t\t\tcase 0:\t\t\t\t// special handling for 1st vertex on path\n\n\t\t\t\t\tdx = points[ j + 1 ].x - points[ j ].x;\n\t\t\t\t\tdy = points[ j + 1 ].y - points[ j ].y;\n\n\t\t\t\t\tnormal.x = dy * 1.0;\n\t\t\t\t\tnormal.y = - dx;\n\t\t\t\t\tnormal.z = dy * 0.0;\n\n\t\t\t\t\tprevNormal.copy( normal );\n\n\t\t\t\t\tnormal.normalize();\n\n\t\t\t\t\tinitNormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase ( points.length - 1 ):\t// special handling for last Vertex on path\n\n\t\t\t\t\tinitNormals.push( prevNormal.x, prevNormal.y, prevNormal.z );\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\t\t\t// default handling for all vertices in between\n\n\t\t\t\t\tdx = points[ j + 1 ].x - points[ j ].x;\n\t\t\t\t\tdy = points[ j + 1 ].y - points[ j ].y;\n\n\t\t\t\t\tnormal.x = dy * 1.0;\n\t\t\t\t\tnormal.y = - dx;\n\t\t\t\t\tnormal.z = dy * 0.0;\n\n\t\t\t\t\tcurNormal.copy( normal );\n\n\t\t\t\t\tnormal.x += prevNormal.x;\n\t\t\t\t\tnormal.y += prevNormal.y;\n\t\t\t\t\tnormal.z += prevNormal.z;\n\n\t\t\t\t\tnormal.normalize();\n\n\t\t\t\t\tinitNormals.push( normal.x, normal.y, normal.z );\n\n\t\t\t\t\tprevNormal.copy( curNormal );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// generate vertices, uvs and normals\n\n\t\tfor ( let i = 0; i <= segments; i ++ ) {\n\n\t\t\tconst phi = phiStart + i * inverseSegments * phiLength;\n\n\t\t\tconst sin = Math.sin( phi );\n\t\t\tconst cos = Math.cos( phi );\n\n\t\t\tfor ( let j = 0; j <= ( points.length - 1 ); j ++ ) {\n\n\t\t\t\t// vertex\n\n\t\t\t\tvertex.x = points[ j ].x * sin;\n\t\t\t\tvertex.y = points[ j ].y;\n\t\t\t\tvertex.z = points[ j ].x * cos;\n\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\n\n\t\t\t\t// uv\n\n\t\t\t\tuv.x = i / segments;\n\t\t\t\tuv.y = j / ( points.length - 1 );\n\n\t\t\t\tuvs.push( uv.x, uv.y );\n\n\t\t\t\t// normal\n\n\t\t\t\tconst x = initNormals[ 3 * j + 0 ] * sin;\n\t\t\t\tconst y = initNormals[ 3 * j + 1 ];\n\t\t\t\tconst z = initNormals[ 3 * j + 0 ] * cos;\n\n\t\t\t\tnormals.push( x, y, z );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// indices\n\n\t\tfor ( let i = 0; i < segments; i ++ ) {\n\n\t\t\tfor ( let j = 0; j < ( points.length - 1 ); j ++ ) {\n\n\t\t\t\tconst base = j + i * points.length;\n\n\t\t\t\tconst a = base;\n\t\t\t\tconst b = base + points.length;\n\t\t\t\tconst c = base + points.length + 1;\n\t\t\t\tconst d = base + 1;\n\n\t\t\t\t// faces\n\n\t\t\t\tindices.push( a, b, d );\n\t\t\t\tindices.push( c, d, b );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// build geometry\n\n\t\tthis.setIndex( indices );\n\t\tthis.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tthis.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\t\tthis.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new LatheGeometry( data.points, data.segments, data.phiStart, data.phiLength );\n\n\t}\n\n}\n\n\nexport { LatheGeometry, LatheGeometry as LatheBufferGeometry };\n","import { Path } from '../extras/core/Path.js';\nimport { LatheGeometry } from './LatheGeometry.js';\n\nclass CapsuleGeometry extends LatheGeometry {\n\n\tconstructor( radius = 1, length = 1, capSegments = 4, radialSegments = 8 ) {\n\n\t\tconst path = new Path();\n\t\tpath.absarc( 0, - length / 2, radius, Math.PI * 1.5, 0 );\n\t\tpath.absarc( 0, length / 2, radius, 0, Math.PI * 0.5 );\n\n\t\tsuper( path.getPoints( capSegments ), radialSegments );\n\n\t\tthis.type = 'CapsuleGeometry';\n\n\t\tthis.parameters = {\n\t\t\tradius: radius,\n\t\t\theight: length,\n\t\t\tcapSegments: capSegments,\n\t\t\tradialSegments: radialSegments,\n\t\t};\n\n\t}\n\n\tstatic fromJSON( data ) {\n\n\t\treturn new CapsuleGeometry( data.radius, data.length, data.capSegments, data.radialSegments );\n\n\t}\n\n}\n\nexport { CapsuleGeometry, CapsuleGeometry as CapsuleBufferGeometry };\n"],"names":["Curve","constructor","this","type","arcLengthDivisions","getPoint","console","warn","getPointAt","u","optionalTarget","t","getUtoTmapping","getPoints","divisions","points","d","push","getSpacedPoints","getLength","lengths","getLengths","length","cacheArcLengths","needsUpdate","cache","current","last","sum","p","distanceTo","updateArcLengths","distance","arcLengths","i","il","targetArcLength","comparison","low","high","Math","floor","lengthBefore","getTangent","delta","t1","t2","pt1","pt2","tangent","Vector2","Vector3","copy","sub","normalize","getTangentAt","computeFrenetFrames","segments","closed","normal","tangents","normals","binormals","vec","mat","Matrix4","min","Number","MAX_VALUE","tx","abs","x","ty","y","tz","z","set","crossVectors","clone","EPSILON","theta","acos","MathUtils","dot","applyMatrix4","makeRotationAxis","source","toJSON","data","metadata","version","generator","fromJSON","json","EllipseCurve","aX","aY","xRadius","yRadius","aStartAngle","aEndAngle","PI","aClockwise","aRotation","super","point","twoPi","deltaAngle","samePoints","angle","cos","sin","prototype","isEllipseCurve","ArcCurve","aRadius","CubicPoly","c0","c1","c2","c3","init","x0","x1","t0","initCatmullRom","x2","x3","tension","initNonuniformCatmullRom","dt0","dt1","dt2","calc","isArcCurve","tmp","px","py","pz","CatmullRomCurve3","curveType","l","p0","p3","intPoint","weight","subVectors","add","p1","p2","pow","distanceToSquared","toArray","fromArray","CatmullRom","v0","v1","QuadraticBezier","k","QuadraticBezierP0","QuadraticBezierP1","QuadraticBezierP2","CubicBezier","CubicBezierP0","CubicBezierP1","CubicBezierP2","CubicBezierP3","isCatmullRomCurve3","CubicBezierCurve","v2","v3","isCubicBezierCurve","CubicBezierCurve3","isCubicBezierCurve3","LineCurve","multiplyScalar","isLineCurve","LineCurve3","isLineCurve3","QuadraticBezierCurve","isQuadraticBezierCurve","QuadraticBezierCurve3","isQuadraticBezierCurve3","SplineCurve","isSplineCurve","CurvePath","curves","autoClose","curve","closePath","startPoint","endPoint","equals","curveLengths","getCurveLengths","diff","segmentLength","lens","cacheLengths","sums","resolution","pts","j","Path","currentPoint","setFromPoints","moveTo","lineTo","quadraticCurveTo","aCPx","aCPy","bezierCurveTo","aCP1x","aCP1y","aCP2x","aCP2y","splineThru","npts","concat","arc","y0","absarc","absellipse","ellipse","firstPoint","lastPoint","LatheGeometry","BufferGeometry","phiStart","phiLength","parameters","indices","vertices","uvs","initNormals","inverseSegments","vertex","uv","curNormal","prevNormal","dx","dy","phi","base","a","b","c","setIndex","setAttribute","Float32BufferAttribute","static","CapsuleGeometry","radius","capSegments","radialSegments","path","height"],"sourceRoot":""}